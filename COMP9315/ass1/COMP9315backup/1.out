/srvr/z5089358/postgresql-10.4/config/c-library.m4:# external array `tzname' is found, define `HAVE_TZNAME'.
/srvr/z5089358/postgresql-10.4/config/c-library.m4:              [Define to 1 if you have the external array `tzname'.])
/srvr/z5089358/postgresql-10.4/config/c-library.m4:# union semun { int val; struct semid_ds *buf; unsigned short *array; }
/srvr/z5089358/postgresql-10.4/config.log:configure:11646: checking for flexible array members
/srvr/z5089358/postgresql-10.4/config.log:conftest.c:90: error: size of array 'off_t_is_large' is negative
/srvr/z5089358/postgresql-10.4/configure:static int test_array [1 - 2 * !(($2) >= 0)];
/srvr/z5089358/postgresql-10.4/configure:test_array [0] = 0;
/srvr/z5089358/postgresql-10.4/configure:return test_array [0];
/srvr/z5089358/postgresql-10.4/configure:static int test_array [1 - 2 * !(($2) <= $ac_mid)];
/srvr/z5089358/postgresql-10.4/configure:test_array [0] = 0;
/srvr/z5089358/postgresql-10.4/configure:return test_array [0];
/srvr/z5089358/postgresql-10.4/configure:static int test_array [1 - 2 * !(($2) < 0)];
/srvr/z5089358/postgresql-10.4/configure:test_array [0] = 0;
/srvr/z5089358/postgresql-10.4/configure:return test_array [0];
/srvr/z5089358/postgresql-10.4/configure:static int test_array [1 - 2 * !(($2) >= $ac_mid)];
/srvr/z5089358/postgresql-10.4/configure:test_array [0] = 0;
/srvr/z5089358/postgresql-10.4/configure:return test_array [0];
/srvr/z5089358/postgresql-10.4/configure:static int test_array [1 - 2 * !(($2) <= $ac_mid)];
/srvr/z5089358/postgresql-10.4/configure:test_array [0] = 0;
/srvr/z5089358/postgresql-10.4/configure:return test_array [0];
/srvr/z5089358/postgresql-10.4/configure:   array size at least.  It's necessary to write '\x00'==0 to get something
/srvr/z5089358/postgresql-10.4/configure:int osf4_cc_array ['\x00' == 0 ? 1 : -1];
/srvr/z5089358/postgresql-10.4/configure:int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
/srvr/z5089358/postgresql-10.4/configure:  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for flexible array members" >&5
/srvr/z5089358/postgresql-10.4/configure:$as_echo_n "checking for flexible array members... " >&6; }
/srvr/z5089358/postgresql-10.4/configure:static int test_array [1 - 2 * !(sizeof (void *) <= sizeof ($ac_type))];
/srvr/z5089358/postgresql-10.4/configure:test_array [0] = 0;
/srvr/z5089358/postgresql-10.4/configure:return test_array [0];
/srvr/z5089358/postgresql-10.4/configure:static int test_array [1 - 2 * !(sizeof (void *) <= sizeof ($ac_type))];
/srvr/z5089358/postgresql-10.4/configure:test_array [0] = 0;
/srvr/z5089358/postgresql-10.4/configure:return test_array [0];
/srvr/z5089358/postgresql-10.4/configure:static int test_array [1 - 2 * !(sizeof(long int) == 8)];
/srvr/z5089358/postgresql-10.4/configure:test_array [0] = 0;
/srvr/z5089358/postgresql-10.4/configure:return test_array [0];
/srvr/z5089358/postgresql-10.4/configure:static int test_array [1 - 2 * !(sizeof(long long int) == 8)];
/srvr/z5089358/postgresql-10.4/configure:test_array [0] = 0;
/srvr/z5089358/postgresql-10.4/configure:return test_array [0];
/srvr/z5089358/postgresql-10.4/configure:# For the awk script, D is an array of macro values keyed by name,
/srvr/z5089358/postgresql-10.4/contrib/ltree/lquery_op.c:				 errmsg("array must be one-dimensional")));
/srvr/z5089358/postgresql-10.4/contrib/ltree/lquery_op.c:	if (array_contains_nulls(_query))
/srvr/z5089358/postgresql-10.4/contrib/ltree/lquery_op.c:				 errmsg("array must not contain nulls")));
/srvr/z5089358/postgresql-10.4/contrib/ltree/sql/ltree.sql:--arrays
/srvr/z5089358/postgresql-10.4/contrib/ltree/_ltree_gist.c:					 errmsg("array must be one-dimensional")));
/srvr/z5089358/postgresql-10.4/contrib/ltree/_ltree_gist.c:		if (array_contains_nulls(val))
/srvr/z5089358/postgresql-10.4/contrib/ltree/_ltree_gist.c:					 errmsg("array must not contain nulls")));
/srvr/z5089358/postgresql-10.4/contrib/ltree/_ltree_gist.c:				 errmsg("array must be one-dimensional")));
/srvr/z5089358/postgresql-10.4/contrib/ltree/_ltree_gist.c:	if (array_contains_nulls(_query))
/srvr/z5089358/postgresql-10.4/contrib/ltree/_ltree_gist.c:				 errmsg("array must not contain nulls")));
/srvr/z5089358/postgresql-10.4/contrib/ltree/_ltree_op.c:array_iterator(ArrayType *la, PGCALL2 callback, void *param, ltree **found)
/srvr/z5089358/postgresql-10.4/contrib/ltree/_ltree_op.c:				 errmsg("array must be one-dimensional")));
/srvr/z5089358/postgresql-10.4/contrib/ltree/_ltree_op.c:	if (array_contains_nulls(la))
/srvr/z5089358/postgresql-10.4/contrib/ltree/_ltree_op.c:				 errmsg("array must not contain nulls")));
/srvr/z5089358/postgresql-10.4/contrib/ltree/_ltree_op.c:	bool		res = array_iterator(la, ltree_isparent, (void *) query, NULL);
/srvr/z5089358/postgresql-10.4/contrib/ltree/_ltree_op.c:	bool		res = array_iterator(la, ltree_risparent, (void *) query, NULL);
/srvr/z5089358/postgresql-10.4/contrib/ltree/_ltree_op.c:	bool		res = array_iterator(la, ltq_regex, (void *) query, NULL);
/srvr/z5089358/postgresql-10.4/contrib/ltree/_ltree_op.c:				 errmsg("array must be one-dimensional")));
/srvr/z5089358/postgresql-10.4/contrib/ltree/_ltree_op.c:	if (array_contains_nulls(_query))
/srvr/z5089358/postgresql-10.4/contrib/ltree/_ltree_op.c:				 errmsg("array must not contain nulls")));
/srvr/z5089358/postgresql-10.4/contrib/ltree/_ltree_op.c:		if (array_iterator(_tree, ltq_regex, (void *) query, NULL))
/srvr/z5089358/postgresql-10.4/contrib/ltree/_ltree_op.c:	bool		res = array_iterator(la, ltxtq_exec, (void *) query, NULL);
/srvr/z5089358/postgresql-10.4/contrib/ltree/_ltree_op.c:	if (!array_iterator(la, ltree_isparent, (void *) query, &found))
/srvr/z5089358/postgresql-10.4/contrib/ltree/_ltree_op.c:	if (!array_iterator(la, ltree_risparent, (void *) query, &found))
/srvr/z5089358/postgresql-10.4/contrib/ltree/_ltree_op.c:	if (!array_iterator(la, ltq_regex, (void *) query, &found))
/srvr/z5089358/postgresql-10.4/contrib/ltree/_ltree_op.c:	if (!array_iterator(la, ltxtq_exec, (void *) query, &found))
/srvr/z5089358/postgresql-10.4/contrib/ltree/_ltree_op.c:				 errmsg("array must be one-dimensional")));
/srvr/z5089358/postgresql-10.4/contrib/ltree/_ltree_op.c:	if (array_contains_nulls(la))
/srvr/z5089358/postgresql-10.4/contrib/ltree/_ltree_op.c:				 errmsg("array must not contain nulls")));
/srvr/z5089358/postgresql-10.4/contrib/ltree/ltree--1.0--1.1.sql:  proargtypes = pg_catalog.array_to_string(newtypes::pg_catalog.oid[], ' ')::pg_catalog.oidvector,
/srvr/z5089358/postgresql-10.4/contrib/ltree/ltree--1.0--1.1.sql:  pronargs = pg_catalog.array_length(newtypes, 1)
/srvr/z5089358/postgresql-10.4/contrib/ltree/ltree.h: *		(len)(size)(array of ITEM)(array of operand in user-friendly form)
/srvr/z5089358/postgresql-10.4/contrib/ltree/ltree.h:/* use in array iterator */
/srvr/z5089358/postgresql-10.4/contrib/ltree/expected/ltree.out:--arrays
/srvr/z5089358/postgresql-10.4/contrib/ltree/ltree--1.1.sql:-- arrays of ltree
/srvr/z5089358/postgresql-10.4/contrib/ltree/ltree_gist.c:	RIX		   *array;
/srvr/z5089358/postgresql-10.4/contrib/ltree/ltree_gist.c:	array = (RIX *) palloc(sizeof(RIX) * (maxoff + 1));
/srvr/z5089358/postgresql-10.4/contrib/ltree/ltree_gist.c:		array[j].index = j;
/srvr/z5089358/postgresql-10.4/contrib/ltree/ltree_gist.c:		array[j].r = LTG_GETLNODE(lu);
/srvr/z5089358/postgresql-10.4/contrib/ltree/ltree_gist.c:	qsort((void *) &array[FirstOffsetNumber], maxoff - FirstOffsetNumber + 1,
/srvr/z5089358/postgresql-10.4/contrib/ltree/ltree_gist.c:		lu = GETENTRY(entryvec, array[j].index);	/* use as tmp val */
/srvr/z5089358/postgresql-10.4/contrib/ltree/ltree_gist.c:			v->spl_left[v->spl_nleft] = array[j].index;
/srvr/z5089358/postgresql-10.4/contrib/ltree/ltree_gist.c:			v->spl_right[v->spl_nright] = array[j].index;
/srvr/z5089358/postgresql-10.4/contrib/ltree/ltree_gist.c:	lu_l = LTG_GETLNODE(GETENTRY(entryvec, array[FirstOffsetNumber].index));
/srvr/z5089358/postgresql-10.4/contrib/ltree/ltree_gist.c:	ru_l = LTG_GETLNODE(GETENTRY(entryvec, array[1 + ((maxoff - FirstOffsetNumber + 1) / 2)].index));
/srvr/z5089358/postgresql-10.4/contrib/ltree/ltree_gist.c:				 errmsg("array must be one-dimensional")));
/srvr/z5089358/postgresql-10.4/contrib/ltree/ltree_gist.c:	if (array_contains_nulls(_query))
/srvr/z5089358/postgresql-10.4/contrib/ltree/ltree_gist.c:				 errmsg("array must not contain nulls")));
/srvr/z5089358/postgresql-10.4/contrib/intagg/intagg--1.0--1.1.sql:ALTER FUNCTION int_agg_final_array(internal) PARALLEL SAFE;
/srvr/z5089358/postgresql-10.4/contrib/intagg/intagg--1.0--1.1.sql:ALTER FUNCTION int_array_enum(int4[]) PARALLEL SAFE;
/srvr/z5089358/postgresql-10.4/contrib/intagg/intagg--1.0--1.1.sql:WHERE oid = 'int_array_aggregate(int4)'::pg_catalog.regprocedure;
/srvr/z5089358/postgresql-10.4/contrib/intagg/intagg--unpackaged--1.0.sql:ALTER EXTENSION intagg ADD function int_agg_final_array(internal);
/srvr/z5089358/postgresql-10.4/contrib/intagg/intagg--unpackaged--1.0.sql:ALTER EXTENSION intagg ADD function int_array_aggregate(integer);
/srvr/z5089358/postgresql-10.4/contrib/intagg/intagg--unpackaged--1.0.sql:ALTER EXTENSION intagg ADD function int_array_enum(integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intagg/intagg--1.1.sql:AS 'array_agg_transfn'
/srvr/z5089358/postgresql-10.4/contrib/intagg/intagg--1.1.sql:-- Is called at the end of the aggregation, and returns an array.
/srvr/z5089358/postgresql-10.4/contrib/intagg/intagg--1.1.sql:CREATE FUNCTION int_agg_final_array (internal)
/srvr/z5089358/postgresql-10.4/contrib/intagg/intagg--1.1.sql:AS 'array_agg_finalfn'
/srvr/z5089358/postgresql-10.4/contrib/intagg/intagg--1.1.sql:-- uses the above functions to create an array of integers from an aggregation.
/srvr/z5089358/postgresql-10.4/contrib/intagg/intagg--1.1.sql:CREATE AGGREGATE int_array_aggregate(int4) (
/srvr/z5089358/postgresql-10.4/contrib/intagg/intagg--1.1.sql:	FINALFUNC = int_agg_final_array,
/srvr/z5089358/postgresql-10.4/contrib/intagg/intagg--1.1.sql:-- returns each element in a one dimensional integer array
/srvr/z5089358/postgresql-10.4/contrib/intagg/intagg--1.1.sql:CREATE FUNCTION int_array_enum(int4[])
/srvr/z5089358/postgresql-10.4/contrib/intagg/intagg--1.1.sql:AS 'array_unnest'
/srvr/z5089358/postgresql-10.4/contrib/Makefile:		intarray	\
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.1--1.2.sql:/* contrib/intarray/intarray--1.1--1.2.sql */
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.1--1.2.sql:\echo Use "ALTER EXTENSION intarray UPDATE TO '1.2'" to load this file. \quit
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.1--1.2.sql:  proargtypes = pg_catalog.array_to_string(newtypes::pg_catalog.oid[], ' ')::pg_catalog.oidvector,
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.1--1.2.sql:  pronargs = pg_catalog.array_length(newtypes, 1)
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.1--1.2.sql:ALTER FUNCTION subarray(_int4, int4, int4) PARALLEL SAFE;
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.1--1.2.sql:ALTER FUNCTION subarray(_int4, int4) PARALLEL SAFE;
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.1--1.2.sql:ALTER FUNCTION intarray_push_elem(_int4, int4) PARALLEL SAFE;
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.1--1.2.sql:ALTER FUNCTION intarray_push_array(_int4, _int4) PARALLEL SAFE;
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.1--1.2.sql:ALTER FUNCTION intarray_del_elem(_int4, int4) PARALLEL SAFE;
/srvr/z5089358/postgresql-10.4/contrib/intarray/Makefile:# contrib/intarray/Makefile
/srvr/z5089358/postgresql-10.4/contrib/intarray/Makefile:EXTENSION = intarray
/srvr/z5089358/postgresql-10.4/contrib/intarray/Makefile:DATA = intarray--1.2.sql intarray--1.1--1.2.sql intarray--1.0--1.1.sql \
/srvr/z5089358/postgresql-10.4/contrib/intarray/Makefile:	intarray--unpackaged--1.0.sql
/srvr/z5089358/postgresql-10.4/contrib/intarray/Makefile:PGFILEDESC = "intarray - functions and operators for arrays of integers"
/srvr/z5089358/postgresql-10.4/contrib/intarray/Makefile:subdir = contrib/intarray
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_gist.c: * contrib/intarray/_int_gist.c
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_gist.c:			elog(NOTICE, "input array is too big (%d maximum allowed, %d current), use gist__intbig_ops opclass instead",
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.0--1.1.sql:/* contrib/intarray/intarray--1.0--1.1.sql */
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.0--1.1.sql:\echo Use "ALTER EXTENSION intarray UPDATE TO '1.1'" to load this file. \quit
/srvr/z5089358/postgresql-10.4/contrib/intarray/_intbig_gist.c: * contrib/intarray/_intbig_gist.c
/srvr/z5089358/postgresql-10.4/contrib/intarray/sql/_int.sql:CREATE EXTENSION intarray;
/srvr/z5089358/postgresql-10.4/contrib/intarray/sql/_int.sql:SELECT subarray('{1234234,-30,-30,234234,-30}',2,3);
/srvr/z5089358/postgresql-10.4/contrib/intarray/sql/_int.sql:SELECT subarray('{1234234,-30,-30,234234,-30}',-1,1);
/srvr/z5089358/postgresql-10.4/contrib/intarray/sql/_int.sql:SELECT subarray('{1234234,-30,-30,234234,-30}',0,-1);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:/* contrib/intarray/intarray--unpackaged--1.0.sql */
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:\echo Use "CREATE EXTENSION intarray FROM unpackaged" to load this file. \quit
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD type query_int;
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function bqarr_in(cstring);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function bqarr_out(query_int);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function querytree(query_int);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function boolop(integer[],query_int);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function rboolop(query_int,integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD operator ~~(query_int,integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD operator @@(integer[],query_int);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function _int_contains(integer[],integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function _int_contained(integer[],integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function _int_overlap(integer[],integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function _int_same(integer[],integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function _int_different(integer[],integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function _int_union(integer[],integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function _int_inter(integer[],integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD operator &&(integer[],integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD operator <@(integer[],integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD operator @>(integer[],integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD operator ~(integer[],integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD operator @(integer[],integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function intset(integer);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function icount(integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD operator #(NONE,integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function sort(integer[],text);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function sort(integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function sort_asc(integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function sort_desc(integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function uniq(integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function idx(integer[],integer);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD operator #(integer[],integer);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function subarray(integer[],integer,integer);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function subarray(integer[],integer);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function intarray_push_elem(integer[],integer);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD operator +(integer[],integer);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function intarray_push_array(integer[],integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD operator +(integer[],integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function intarray_del_elem(integer[],integer);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD operator -(integer[],integer);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function intset_union_elem(integer[],integer);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD operator |(integer[],integer);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD operator |(integer[],integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function intset_subtract(integer[],integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD operator -(integer[],integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD operator &(integer[],integer[]);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function g_int_consistent(internal,integer[],integer,oid,internal);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function g_int_compress(internal);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function g_int_decompress(internal);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function g_int_penalty(internal,internal,internal);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function g_int_picksplit(internal,internal);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function g_int_union(internal,internal);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function g_int_same(integer[],integer[],internal);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD operator family gist__int_ops using gist;
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD operator class gist__int_ops using gist;
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD type intbig_gkey;
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function _intbig_in(cstring);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function _intbig_out(intbig_gkey);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function g_intbig_consistent(internal,internal,integer,oid,internal);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function g_intbig_compress(internal);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function g_intbig_decompress(internal);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function g_intbig_penalty(internal,internal,internal);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function g_intbig_picksplit(internal,internal);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function g_intbig_union(internal,internal);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function g_intbig_same(internal,internal,internal);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD operator family gist__intbig_ops using gist;
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD operator class gist__intbig_ops using gist;
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD operator family gin__int_ops using gin;
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD operator class gin__int_ops using gin;
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function ginint4_queryextract(internal,internal,smallint,internal,internal);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:ALTER EXTENSION intarray ADD function ginint4_consistent(internal,smallint,internal,integer,internal,internal);
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:-- intarray also relies on the core function ginarrayextract, which changed
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:-- for ginarrayextract with both 2 and 3 args, and the former is what would
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:SET amproc = 'pg_catalog.ginarrayextract(anyarray,internal,internal)'::pg_catalog.regprocedure
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--unpackaged--1.0.sql:  AND amproc = 'pg_catalog.ginarrayextract(anyarray,internal)'::pg_catalog.regprocedure;
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_op.c: * contrib/intarray/_int_op.c
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_op.c:	/* Force copy so we can modify the arrays in-place */
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_op.c:PG_FUNCTION_INFO_V1(subarray);
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_op.c:PG_FUNCTION_INFO_V1(intarray_push_elem);
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_op.c:PG_FUNCTION_INFO_V1(intarray_push_array);
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_op.c:PG_FUNCTION_INFO_V1(intarray_del_elem);
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_op.c:		result = intarray_match_first(a, PG_GETARG_INT32(1));
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_op.c:subarray(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_op.c:intarray_push_elem(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_op.c:	result = intarray_add_elem(a, PG_GETARG_INT32(1));
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_op.c:intarray_push_array(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_op.c:	result = intarray_concat_arrays(a, b);
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_op.c:intarray_del_elem(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_op.c:	result = intarray_add_elem(a, PG_GETARG_INT32(1));
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.2.sql:/* contrib/intarray/intarray--1.2.sql */
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.2.sql:\echo Use "CREATE EXTENSION intarray" to load this file. \quit
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.2.sql:-- Create the user-defined type for the 1-D integer arrays (_int4)
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.2.sql:COMMENT ON FUNCTION boolop(_int4, query_int) IS 'boolean operation with array';
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.2.sql:COMMENT ON FUNCTION rboolop(query_int, _int4) IS 'boolean operation with array';
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.2.sql:CREATE FUNCTION subarray(_int4, int4, int4)
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.2.sql:CREATE FUNCTION subarray(_int4, int4)
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.2.sql:CREATE FUNCTION intarray_push_elem(_int4, int4)
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.2.sql:	PROCEDURE = intarray_push_elem
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.2.sql:CREATE FUNCTION intarray_push_array(_int4, _int4)
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.2.sql:	PROCEDURE = intarray_push_array
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.2.sql:CREATE FUNCTION intarray_del_elem(_int4, int4)
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.2.sql:	PROCEDURE = intarray_del_elem
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.2.sql:	OPERATOR	6	= (anyarray, anyarray),
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.2.sql:	OPERATOR	6	= (anyarray, anyarray),
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.2.sql:	OPERATOR	6	= (anyarray, anyarray),
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray--1.2.sql:	FUNCTION	2	ginarrayextract (anyarray, internal, internal),
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray.control:# intarray extension
/srvr/z5089358/postgresql-10.4/contrib/intarray/intarray.control:comment = 'functions, operators, and index support for 1-D arrays of integers'
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_bool.c: * contrib/intarray/_int_bool.c
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_bool.c: * is there value 'val' in (sorted) array or not ?
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_bool.c:execconsistent(QUERYTYPE *query, ArrayType *array, bool calcnot)
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_bool.c:	CHECKARRVALID(array);
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_bool.c:	chkval.arrb = ARRPTR(array);
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_bool.c:	chkval.arre = chkval.arrb + ARRNELEMS(array);
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_gin.c: * contrib/intarray/_int_gin.c
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_tool.c: * contrib/intarray/_int_tool.c
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_tool.c:/* Create a new int array with room for "num" elements */
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_tool.c:	/* if no elements, return a zero-dimensional array */
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_tool.c:	/* usually the array should be 1-D already, but just in case ... */
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_tool.c:intarray_match_first(ArrayType *a, int32 elem)
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_tool.c:intarray_add_elem(ArrayType *a, int32 elem)
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_tool.c:intarray_concat_arrays(ArrayType *a, ArrayType *b)
/srvr/z5089358/postgresql-10.4/contrib/intarray/bench/bench.pl:	  map { "$_->[0]\n" } @{ $dbi->selectall_arrayref("explain $sql") };
/srvr/z5089358/postgresql-10.4/contrib/intarray/bench/create_test.pl:# contrib/intarray/bench/create_test.pl
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int.h: * contrib/intarray/_int.h
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int.h:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int.h:/* useful macros for accessing int4 arrays */
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int.h:/* reject arrays we can't handle; to wit, those containing nulls */
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int.h:		if (ARR_HASNULL(x) && array_contains_nulls(x)) \
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int.h:					 errmsg("array must not contain nulls"))); \
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int.h:/* sort the elements of the array */
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int.h:/* sort the elements of the array and remove duplicates */
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int.h:typedef ArrayType *(*formarray) (ArrayType *, ArrayType *);
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int.h:int32		intarray_match_first(ArrayType *a, int32 elem);
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int.h:ArrayType  *intarray_add_elem(ArrayType *a, int32 elem);
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int.h:ArrayType  *intarray_concat_arrays(ArrayType *a, ArrayType *b);
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int.h:bool		execconsistent(QUERYTYPE *query, ArrayType *array, bool calcnot);
/srvr/z5089358/postgresql-10.4/contrib/intarray/expected/_int.out:CREATE EXTENSION intarray;
/srvr/z5089358/postgresql-10.4/contrib/intarray/expected/_int.out:SELECT subarray('{1234234,-30,-30,234234,-30}',2,3);
/srvr/z5089358/postgresql-10.4/contrib/intarray/expected/_int.out:     subarray     
/srvr/z5089358/postgresql-10.4/contrib/intarray/expected/_int.out:SELECT subarray('{1234234,-30,-30,234234,-30}',-1,1);
/srvr/z5089358/postgresql-10.4/contrib/intarray/expected/_int.out: subarray 
/srvr/z5089358/postgresql-10.4/contrib/intarray/expected/_int.out:SELECT subarray('{1234234,-30,-30,234234,-30}',0,-1);
/srvr/z5089358/postgresql-10.4/contrib/intarray/expected/_int.out:         subarray         
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_selfuncs.c: *	  Functions for selectivity estimation of intarray operators
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_selfuncs.c: *	  contrib/intarray/_int_selfuncs.c
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_selfuncs.c: * Wrappers around the default array selectivity estimation functions.
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_selfuncs.c: * The default array selectivity operators for the @>, && and @< operators
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_selfuncs.c: * work fine for integer arrays. However, if we tried to just use arraycontsel
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_selfuncs.c: * operator's OID. Our operators behave exactly like the built-in anyarray
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_selfuncs.c:	PG_RETURN_DATUM(DirectFunctionCall4(arraycontsel,
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_selfuncs.c:	PG_RETURN_DATUM(DirectFunctionCall4(arraycontsel,
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_selfuncs.c:	PG_RETURN_DATUM(DirectFunctionCall4(arraycontsel,
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_selfuncs.c:	PG_RETURN_DATUM(DirectFunctionCall5(arraycontjoinsel,
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_selfuncs.c:	PG_RETURN_DATUM(DirectFunctionCall5(arraycontjoinsel,
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_selfuncs.c:	PG_RETURN_DATUM(DirectFunctionCall5(arraycontjoinsel,
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_selfuncs.c: * _int_matchsel -- restriction selectivity function for intarray @@ query_int
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_selfuncs.c:	 * Get the statistics for the intarray column.
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_selfuncs.c:		 * For an int4 array, the default array type analyze function will
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_selfuncs.c:		 * collect a Most Common Elements list, which is an array of int4s.
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_selfuncs.c:			 * last three (for intarray) cells are taken for minimal, maximal
/srvr/z5089358/postgresql-10.4/contrib/intarray/_int_selfuncs.c: * Comparison function for binary search in mcelem array.
/srvr/z5089358/postgresql-10.4/contrib/seg/segparse.c:/* The size of an array large to enough to hold all stacks, each with
/srvr/z5089358/postgresql-10.4/contrib/seg/seg--1.0--1.1.sql:  proargtypes = pg_catalog.array_to_string(newtypes::pg_catalog.oid[], ' ')::pg_catalog.oidvector,
/srvr/z5089358/postgresql-10.4/contrib/seg/seg--1.0--1.1.sql:  pronargs = pg_catalog.array_length(newtypes, 1)
/srvr/z5089358/postgresql-10.4/contrib/seg/seg.c:	 * Prepare the auxiliary array and sort it.
/srvr/z5089358/postgresql-10.4/contrib/seg/seg.c:			 * to the buf array
/srvr/z5089358/postgresql-10.4/contrib/seg/segscan.c: * integer for use as an array index.  If the signed char is negative,
/srvr/z5089358/postgresql-10.4/contrib/seg/segscan.c:static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
/srvr/z5089358/postgresql-10.4/contrib/seg/segscan.c:		/* Extend the array by 50%, plus the number we really need. */
/srvr/z5089358/postgresql-10.4/contrib/start-scripts/macos/org.postgresql.postgres.plist:	<array>
/srvr/z5089358/postgresql-10.4/contrib/start-scripts/macos/org.postgresql.postgres.plist:	</array>
/srvr/z5089358/postgresql-10.4/contrib/start-scripts/osx/StartupParameters.plist:    <array>
/srvr/z5089358/postgresql-10.4/contrib/start-scripts/osx/StartupParameters.plist:    </array>
/srvr/z5089358/postgresql-10.4/contrib/start-scripts/osx/StartupParameters.plist:    <array>
/srvr/z5089358/postgresql-10.4/contrib/start-scripts/osx/StartupParameters.plist:    </array>
/srvr/z5089358/postgresql-10.4/contrib/start-scripts/osx/StartupParameters.plist:    <array>
/srvr/z5089358/postgresql-10.4/contrib/start-scripts/osx/StartupParameters.plist:    </array>
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/blf.c:static const uint32 parray[] = {
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/blf.c:		P[i] = parray[i];
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/sql/pgp-armor.sql:select armor('zooka', array['foo'], array['bar']);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/sql/pgp-armor.sql:select armor('zooka', array['Version', 'Comment'], array['Created by pgcrypto', 'PostgreSQL, the world''s most advanced open source database']);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/sql/pgp-armor.sql:  armor('zooka', array['Version', 'Comment'],
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/sql/pgp-armor.sql:                 array['Created by pgcrypto', 'PostgreSQL, the world''s most advanced open source database']));
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/sql/pgp-armor.sql:select armor('', array['foo'], array['too', 'many']);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/sql/pgp-armor.sql:select armor('', array['too', 'many'], array['foo']);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/sql/pgp-armor.sql:select armor('', array[['']], array['foo']);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/sql/pgp-armor.sql:select armor('', array['foo'], array[['']]);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/sql/pgp-armor.sql:select armor('', array[null], array['foo']);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/sql/pgp-armor.sql:select armor('', array['foo'], array[null]);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/sql/pgp-armor.sql:select armor('', '[0:0]={"foo"}', array['foo']);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/sql/pgp-armor.sql:select armor('', array['foo'], '[0:0]={"foo"}');
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/sql/pgp-armor.sql:select armor('', array[E'embedded\nnewline'], array['foo']);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/sql/pgp-armor.sql:select armor('', array['foo'], array[E'embedded\nnewline']);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/sql/pgp-armor.sql:select armor('', array['embedded: colon+space'], array['foo']);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/imath.c:/* Set array P of S digits to zero */
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/imath.c:/* Copy S digits from array P to array Q */
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/imath.c:/* Reverse N elements of type T in array A */
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/imath.c:/* Pack the unsigned digits of v into array t */
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/imath.c:	 * to reflect the new digit array it's using
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/crypt-des.c: *	It is assumed that the 8-byte arrays passed by reference can be
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/crypt-des.c: *	addressed as arrays of uint32's (ie. the CPU is not picky about
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/crypt-des.c:	 * Convert the inverted S-boxes into 4 arrays of 8 bits. Each will handle
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/crypt-des.c:	 * Set up the OR-mask arrays for the initial and final permutations, and
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/crypt-des.c:	 * the output of the S-box arrays setup above.
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/pgp-pgsql.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/pgp-pgsql.c: * Helper function for pgp_armor. Converts arrays of keys and values into
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/pgp-pgsql.c: * plain C arrays, and checks that they don't contain invalid characters.
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/pgp-pgsql.c:parse_key_value_arrays(ArrayType *key_array, ArrayType *val_array,
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/pgp-pgsql.c:	int			nkdims = ARR_NDIM(key_array);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/pgp-pgsql.c:	int			nvdims = ARR_NDIM(val_array);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/pgp-pgsql.c:				 errmsg("wrong number of array subscripts")));
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/pgp-pgsql.c:	deconstruct_array(key_array,
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/pgp-pgsql.c:	deconstruct_array(val_array,
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/pgp-pgsql.c:				 errmsg("mismatched array dimensions")));
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/pgp-pgsql.c:		num_headers = parse_key_value_arrays(PG_GETARG_ARRAYTYPE_P(1),
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/expected/pgp-armor.out:select armor('zooka', array['foo'], array['bar']);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/expected/pgp-armor.out:select armor('zooka', array['Version', 'Comment'], array['Created by pgcrypto', 'PostgreSQL, the world''s most advanced open source database']);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/expected/pgp-armor.out:  armor('zooka', array['Version', 'Comment'],
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/expected/pgp-armor.out:                 array['Created by pgcrypto', 'PostgreSQL, the world''s most advanced open source database']));
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/expected/pgp-armor.out:select armor('', array['foo'], array['too', 'many']);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/expected/pgp-armor.out:ERROR:  mismatched array dimensions
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/expected/pgp-armor.out:select armor('', array['too', 'many'], array['foo']);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/expected/pgp-armor.out:ERROR:  mismatched array dimensions
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/expected/pgp-armor.out:select armor('', array[['']], array['foo']);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/expected/pgp-armor.out:ERROR:  wrong number of array subscripts
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/expected/pgp-armor.out:select armor('', array['foo'], array[['']]);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/expected/pgp-armor.out:ERROR:  wrong number of array subscripts
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/expected/pgp-armor.out:select armor('', array[null], array['foo']);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/expected/pgp-armor.out:select armor('', array['foo'], array[null]);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/expected/pgp-armor.out:select armor('', '[0:0]={"foo"}', array['foo']);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/expected/pgp-armor.out:select armor('', array['foo'], '[0:0]={"foo"}');
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/expected/pgp-armor.out:select armor('', array[E'embedded\nnewline'], array['foo']);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/expected/pgp-armor.out:select armor('', array['foo'], array[E'embedded\nnewline']);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/expected/pgp-armor.out:select armor('', array['embedded: colon+space'], array['foo']);
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/pgp-armor.c:	/* Allocate return arrays */
/srvr/z5089358/postgresql-10.4/contrib/pgcrypto/pgp-armor.c:	 * pointers to the keys and values in the return arrays.
/srvr/z5089358/postgresql-10.4/contrib/oid2name/oid2name.c:/* an extensible array to keep track of elements to show */
/srvr/z5089358/postgresql-10.4/contrib/oid2name/oid2name.c:	char	  **array;
/srvr/z5089358/postgresql-10.4/contrib/oid2name/oid2name.c:		eary	  ->array = (char **) pg_malloc(8 * sizeof(char *));
/srvr/z5089358/postgresql-10.4/contrib/oid2name/oid2name.c:		eary	  ->array = (char **) pg_realloc(eary->array,
/srvr/z5089358/postgresql-10.4/contrib/oid2name/oid2name.c:	eary	  ->array[eary->num] = pg_strdup(eltname);
/srvr/z5089358/postgresql-10.4/contrib/oid2name/oid2name.c:		length += strlen(eary->array[i]);
/srvr/z5089358/postgresql-10.4/contrib/oid2name/oid2name.c:		ptr += PQescapeString(ptr, eary->array[i], strlen(eary->array[i]));
/srvr/z5089358/postgresql-10.4/contrib/pg_visibility/pg_visibility.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/contrib/pg_visibility/pg_visibility.c:	 * Guess an initial array size. We don't expect many corrupted tuples, so
/srvr/z5089358/postgresql-10.4/contrib/pg_visibility/pg_visibility.c:	 * start with a small array.  This function uses the "next" field to track
/srvr/z5089358/postgresql-10.4/contrib/pg_visibility/pg_visibility.c:	/* enlarge output array if needed. */
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/sql/spill.sql:SELECT (regexp_split_to_array(data, ':'))[4], COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/sql/spill.sql:SELECT (regexp_split_to_array(data, ':'))[4], COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/sql/spill.sql:SELECT (regexp_split_to_array(data, ':'))[4], COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/sql/spill.sql:SELECT (regexp_split_to_array(data, ':'))[4], COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/sql/spill.sql:SELECT (regexp_split_to_array(data, ':'))[4], COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/sql/spill.sql:SELECT (regexp_split_to_array(data, ':'))[4], COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/sql/spill.sql:SELECT (regexp_split_to_array(data, ':'))[4], COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/sql/spill.sql:SELECT (regexp_split_to_array(data, ':'))[4], COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/sql/spill.sql:SELECT (regexp_split_to_array(data, ':'))[4], COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/sql/spill.sql:SELECT (regexp_split_to_array(data, ':'))[4] COLLATE "C", COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/sql/spill.sql:SELECT (regexp_split_to_array(data, ':'))[4] COLLATE "C", COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/sql/spill.sql:SELECT (regexp_split_to_array(data, ':'))[4] COLLATE "C", COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/sql/spill.sql:SELECT (regexp_split_to_array(data, ':'))[4] COLLATE "C", COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/sql/spill.sql:SELECT (regexp_split_to_array(data, ':'))[4] COLLATE "C", COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:SELECT (regexp_split_to_array(data, ':'))[4], COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out: regexp_split_to_array | count |                              array_agg                              |                               array_agg                                
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:SELECT (regexp_split_to_array(data, ':'))[4], COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out: regexp_split_to_array | count |                              array_agg                              |                               array_agg                                
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:SELECT (regexp_split_to_array(data, ':'))[4], COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:    regexp_split_to_array    | count |                                   array_agg                                   |                                   array_agg                                    
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:SELECT (regexp_split_to_array(data, ':'))[4], COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:     regexp_split_to_array     | count |                                    array_agg                                    |                                    array_agg                                    
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:SELECT (regexp_split_to_array(data, ':'))[4], COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:    regexp_split_to_array    | count |                                   array_agg                                   |                                   array_agg                                    
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:SELECT (regexp_split_to_array(data, ':'))[4], COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:    regexp_split_to_array    | count |                                   array_agg                                   |                                   array_agg                                    
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:SELECT (regexp_split_to_array(data, ':'))[4], COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:     regexp_split_to_array     | count |                                    array_agg                                    |                                    array_agg                                    
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:SELECT (regexp_split_to_array(data, ':'))[4], COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:    regexp_split_to_array    | count |                                   array_agg                                   |                                   array_agg                                    
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:SELECT (regexp_split_to_array(data, ':'))[4], COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:     regexp_split_to_array     | count |                                    array_agg                                    |                                    array_agg                                    
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:SELECT (regexp_split_to_array(data, ':'))[4] COLLATE "C", COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:     regexp_split_to_array     | count |                                  array_agg                                   |                                    array_agg                                    
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:SELECT (regexp_split_to_array(data, ':'))[4] COLLATE "C", COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:       regexp_split_to_array        | count |                                      array_agg                                       |                                       array_agg                                       
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:SELECT (regexp_split_to_array(data, ':'))[4] COLLATE "C", COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:        regexp_split_to_array         | count |                                       array_agg                                        |                                       array_agg                                        
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:SELECT (regexp_split_to_array(data, ':'))[4] COLLATE "C", COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:        regexp_split_to_array         | count |                                      array_agg                                      |                                       array_agg                                        
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:SELECT (regexp_split_to_array(data, ':'))[4] COLLATE "C", COUNT(*), (array_agg(data))[1], (array_agg(data))[count(*)]
/srvr/z5089358/postgresql-10.4/contrib/test_decoding/expected/spill.out:             regexp_split_to_array             | count |                                            array_agg                                            |                                            array_agg                                             
/srvr/z5089358/postgresql-10.4/contrib/fuzzystrmatch/fuzzystrmatch.c:/*-- Character encoding array & accessing macros --*/
/srvr/z5089358/postgresql-10.4/contrib/fuzzystrmatch/fuzzystrmatch.c: * accessing the array directly... */
/srvr/z5089358/postgresql-10.4/contrib/hstore_plpython/sql/hstore_plpython.sql:SELECT test1arr(array['aa=>bb, cc=>NULL'::hstore, 'dd=>ee']);
/srvr/z5089358/postgresql-10.4/contrib/hstore_plpython/expected/hstore_plpython.out:SELECT test1arr(array['aa=>bb, cc=>NULL'::hstore, 'dd=>ee']);
/srvr/z5089358/postgresql-10.4/contrib/file_fdw/file_fdw.c:	 * Note that the valid_options[] array disallows setting filename and
/srvr/z5089358/postgresql-10.4/contrib/file_fdw/file_fdw.c:	 * ExecClearTuple, then fill the values/isnull arrays, then
/srvr/z5089358/postgresql-10.4/contrib/file_fdw/file_fdw.c: * Selected rows are returned in the caller-allocated array rows[],
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:PG_FUNCTION_INFO_V1(hstore_from_arrays);
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:hstore_from_arrays(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:	ArrayType  *key_array;
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:	ArrayType  *value_array;
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:	key_array = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:	Assert(ARR_ELEMTYPE(key_array) == TEXTOID);
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:	 * must check >1 rather than != 1 because empty arrays have 0 dimensions,
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:	if (ARR_NDIM(key_array) > 1)
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:				 errmsg("wrong number of array subscripts")));
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:	deconstruct_array(key_array,
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:	/* value_array might be NULL */
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:		value_array = NULL;
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:		value_array = PG_GETARG_ARRAYTYPE_P(1);
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:		Assert(ARR_ELEMTYPE(value_array) == TEXTOID);
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:		if (ARR_NDIM(value_array) > 1)
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:					 errmsg("wrong number of array subscripts")));
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:		if ((ARR_NDIM(key_array) > 0 || ARR_NDIM(value_array) > 0) &&
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:			(ARR_NDIM(key_array) != ARR_NDIM(value_array) ||
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:			 ARR_DIMS(key_array)[0] != ARR_DIMS(value_array)[0] ||
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:			 ARR_LBOUND(key_array)[0] != ARR_LBOUND(value_array)[0]))
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:					 errmsg("arrays must have same bounds")));
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:		deconstruct_array(value_array,
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:PG_FUNCTION_INFO_V1(hstore_from_array);
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:hstore_from_array(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:	ArrayType  *in_array = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:	int			ndims = ARR_NDIM(in_array);
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:	Assert(ARR_ELEMTYPE(in_array) == TEXTOID);
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:			if ((ARR_DIMS(in_array)[0]) % 2)
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:						 errmsg("array must have even number of elements")));
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:			if ((ARR_DIMS(in_array)[1]) != 2)
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:						 errmsg("array must have two columns")));
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:					 errmsg("wrong number of array subscripts")));
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_io.c:	deconstruct_array(in_array,
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore--unpackaged--1.0.sql:ALTER EXTENSION hstore ADD function slice_array(hstore,text[]);
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore--unpackaged--1.0.sql:ALTER EXTENSION hstore ADD function hstore_to_array(hstore);
/srvr/z5089358/postgresql-10.4/contrib/hstore/sql/hstore.sql:-- -> array operator
/srvr/z5089358/postgresql-10.4/contrib/hstore/sql/hstore.sql:-- delete (array)
/srvr/z5089358/postgresql-10.4/contrib/hstore/sql/hstore.sql:-- array input
/srvr/z5089358/postgresql-10.4/contrib/hstore/sql/hstore.sql:-- pairs of arrays
/srvr/z5089358/postgresql-10.4/contrib/hstore/sql/hstore.sql:select hstore_to_array('aa=>1, cq=>l, b=>g, fg=>NULL'::hstore);
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore--1.4.sql:CREATE FUNCTION slice_array(hstore,text[])
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore--1.4.sql:AS 'MODULE_PATHNAME','hstore_slice_to_array'
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore--1.4.sql:	PROCEDURE = slice_array
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore--1.4.sql:AS 'MODULE_PATHNAME','hstore_delete_array'
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore--1.4.sql:AS 'MODULE_PATHNAME', 'hstore_from_arrays'
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore--1.4.sql:AS 'MODULE_PATHNAME', 'hstore_from_array'
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore--1.4.sql:CREATE FUNCTION hstore_to_array(hstore)
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore--1.4.sql:AS 'MODULE_PATHNAME','hstore_to_array'
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore--1.4.sql:       PROCEDURE = hstore_to_array
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_gist.c:		deconstruct_array(query,
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_gist.c:		deconstruct_array(query,
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore--1.3--1.4.sql:  proargtypes = pg_catalog.array_to_string(newtypes::pg_catalog.oid[], ' ')::pg_catalog.oidvector,
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore--1.3--1.4.sql:  pronargs = pg_catalog.array_length(newtypes, 1)
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore--1.3--1.4.sql:ALTER FUNCTION slice_array(hstore, text[]) PARALLEL SAFE;
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore--1.3--1.4.sql:ALTER FUNCTION hstore_to_array(hstore) PARALLEL SAFE;
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore.h:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore.h:/* note possible multiple evaluations, also access to prior array element */
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore.h:	/* array of HEntry follows */
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore.h: * Pairs array length (due to MaxAllocSize, <= INT_MAX/40).  "lenstr" is no
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore.h: * more than INT_MAX, that extreme case arising in hstore_from_arrays().
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:	deconstruct_array(a,
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:	 * A text array uses at least eight bytes per element, so any overflow in
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:	 * However, credible improvements to the array format could invalidate
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:PG_FUNCTION_INFO_V1(hstore_delete_array);
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:hstore_delete_array(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:	ArrayType  *key_array = PG_GETARG_ARRAYTYPE_P(1);
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:	Pairs	   *key_pairs = hstoreArrayToPairs(key_array, &nkeys);
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:PG_FUNCTION_INFO_V1(hstore_slice_to_array);
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:hstore_slice_to_array(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:	ArrayType  *key_array = PG_GETARG_ARRAYTYPE_P(1);
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:	deconstruct_array(key_array,
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:		aout = construct_empty_array(TEXTOID);
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:	aout = construct_md_array(out_datums, out_nulls,
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:							  ARR_NDIM(key_array),
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:							  ARR_DIMS(key_array),
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:							  ARR_LBOUND(key_array),
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:	ArrayType  *key_array = PG_GETARG_ARRAYTYPE_P(1);
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:	Pairs	   *key_pairs = hstoreArrayToPairs(key_array, &nkeys);
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:		a = construct_empty_array(TEXTOID);
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:	a = construct_array(d, count,
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:		a = construct_empty_array(TEXTOID);
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:	a = construct_md_array(d, nulls, 1, &count, &lb,
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:hstore_to_array_internal(HStore *hs, int ndims)
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:		return construct_empty_array(TEXTOID);
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:	return construct_md_array(out_datums, out_nulls,
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:PG_FUNCTION_INFO_V1(hstore_to_array);
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:hstore_to_array(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:	ArrayType  *out = hstore_to_array_internal(hs, 1);
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c:	ArrayType  *out = hstore_to_array_internal(hs, 2);
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_op.c: * buffer first, then the entry pos array.
/srvr/z5089358/postgresql-10.4/contrib/hstore/expected/hstore.out:-- -> array operator
/srvr/z5089358/postgresql-10.4/contrib/hstore/expected/hstore.out:-- delete (array)
/srvr/z5089358/postgresql-10.4/contrib/hstore/expected/hstore.out:-- array input
/srvr/z5089358/postgresql-10.4/contrib/hstore/expected/hstore.out:ERROR:  array must have even number of elements
/srvr/z5089358/postgresql-10.4/contrib/hstore/expected/hstore.out:             array              
/srvr/z5089358/postgresql-10.4/contrib/hstore/expected/hstore.out:             array              
/srvr/z5089358/postgresql-10.4/contrib/hstore/expected/hstore.out:ERROR:  array must have two columns
/srvr/z5089358/postgresql-10.4/contrib/hstore/expected/hstore.out:ERROR:  wrong number of array subscripts
/srvr/z5089358/postgresql-10.4/contrib/hstore/expected/hstore.out:ERROR:  array must have even number of elements
/srvr/z5089358/postgresql-10.4/contrib/hstore/expected/hstore.out:ERROR:  array must have two columns
/srvr/z5089358/postgresql-10.4/contrib/hstore/expected/hstore.out:ERROR:  wrong number of array subscripts
/srvr/z5089358/postgresql-10.4/contrib/hstore/expected/hstore.out:-- pairs of arrays
/srvr/z5089358/postgresql-10.4/contrib/hstore/expected/hstore.out:ERROR:  arrays must have same bounds
/srvr/z5089358/postgresql-10.4/contrib/hstore/expected/hstore.out:ERROR:  arrays must have same bounds
/srvr/z5089358/postgresql-10.4/contrib/hstore/expected/hstore.out:select hstore_to_array('aa=>1, cq=>l, b=>g, fg=>NULL'::hstore);
/srvr/z5089358/postgresql-10.4/contrib/hstore/expected/hstore.out:     hstore_to_array     
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_gin.c:		deconstruct_array(query,
/srvr/z5089358/postgresql-10.4/contrib/hstore/hstore_gin.c:			/* Nulls in the array are ignored, cf hstoreArrayToPairs */
/srvr/z5089358/postgresql-10.4/contrib/pgrowlocks/pgrowlocks.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/pg_trgm--1.2--1.3.sql:  proargtypes = pg_catalog.array_to_string(newtypes::pg_catalog.oid[], ' ')::pg_catalog.oidvector,
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/pg_trgm--1.2--1.3.sql:  pronargs = pg_catalog.array_length(newtypes, 1)
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_gist.c:				/* just in case an empty array is returned ... */
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_gist.c:					 * size of the sign array.  But since trigramsMatchGraph()
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_gist.c:					 * in the check array can't lead to false negative answer.
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_regexp.c: *	wordChars				- array of this color's word characters
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_regexp.c: *	colorTrgms		- array of all color trigrams present in graph
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_regexp.c:	TrgmPackedArc *arcs;		/* array of arcsCount packed arcs */
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_regexp.c:	 * simple trigrams for each color trigram.  The array of simple trigrams
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_regexp.c:	int		   *colorTrigramGroups; /* array of size colorTrigramsCount */
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_regexp.c:	TrgmPackedState *states;	/* array of size statesCount */
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_regexp.c:	bool	   *colorTrigramsActive;	/* array of size colorTrigramsCount */
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_regexp.c:	bool	   *statesActive;	/* array of size statesCount */
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_regexp.c:	int		   *statesQueue;	/* array of size statesCount */
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_regexp.c: * Returns an array of trigrams required by the regular expression, or NULL if
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_regexp.c: * The check[] array is indexed by trigram number (in the array of simple
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_regexp.c:	 * statesActive array marks which states have been queued.
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_regexp.c: * Returns the TRGM array to be passed to the index machinery.
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_regexp.c: * The array must be allocated in rcontext.
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_regexp.c:	/* Construct the trgm array */
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_regexp.c:	/* Collect array of all arcs */
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_gin.c:				 * extra_data.  GIN API requires an array of nentries
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c:unique_array(trgm *a, int len)
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c: * Make array of trigrams without sorting and removing duplicate items.
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c: * trg: where to return the array of trigrams.
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c: * Returns length of the generated array.
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c: * Make array of trigrams with sorting and removing duplicate items.
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c: * Returns the sorted array of unique trigrams.
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c:		len = unique_array(GETARR(trg), len);
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c: * Make array of positional trigrams from two trigram arrays trg1 and trg2.
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c: * trg1: trigram array of search pattern, of length len1. trg1 is required
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c: * trg2: trigram array of text, of length len2. trg2 is haystack where we
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c: * Returns concatenated trigram array.
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c: * trg2indexes: array which stores indexes of the array "found".
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c: * found: array which stores true of false values.
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c: * ulen1: count of unique trigrams of array "trg1".
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c: * len2: length of array "trg2" and array "trg2indexes".
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c: * len: length of the array "found".
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c: * This function prepare two arrays: "trg2indexes" and "found". Then this arrays
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c: * "trg2indexes" is array which stores indexes of the array "found".
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c: * If found[i] == true then there is trigram trg2[j] in array "trg1".
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c: * If found[i] == false then there is not trigram trg2[j] in array "trg1".
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c:	 * Merge positional trigrams array: enumerate each trigram and find its
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c: * Returns array of trigrams that must occur in any string that matches the
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c:		len = unique_array(GETARR(trg), len);
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c:	a = construct_array(
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c: * This relies on the trigram arrays being sorted.
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c: * Return a palloc'd boolean array showing, for each trigram in "query",
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c: * whether it is present in the trigram array "key".
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c: * This relies on the "key" array being sorted, but "query" need not be.
/srvr/z5089358/postgresql-10.4/contrib/pg_trgm/trgm_op.c:	/* for each query trigram, do a binary search in the key array */
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:select array_agg(c1 order by c1) from ft1 where c1 < 100 group by c2 order by 1;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:select array_agg(c1 order by c1) from ft1 where c1 < 100 group by c2 order by 1;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:select array_agg(c5 order by c1 desc) from ft2 where c2 = 6 and c1 < 50;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:select array_agg(c5 order by c1 desc) from ft2 where c2 = 6 and c1 < 50;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:select array_agg(distinct (t1.c1)%5) from ft4 t1 full join ft5 t2 on (t1.c1 = t2.c1) where t1.c1 < 20 or (t1.c1 is null and t2.c1 < 5) group by (t2.c1)%3 order by 1;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:select array_agg(distinct (t1.c1)%5) from ft4 t1 full join ft5 t2 on (t1.c1 = t2.c1) where t1.c1 < 20 or (t1.c1 is null and t2.c1 < 5) group by (t2.c1)%3 order by 1;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:select array_agg(distinct (t1.c1)%5 order by (t1.c1)%5) from ft4 t1 full join ft5 t2 on (t1.c1 = t2.c1) where t1.c1 < 20 or (t1.c1 is null and t2.c1 < 5) group by (t2.c1)%3 order by 1;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:select array_agg(distinct (t1.c1)%5 order by (t1.c1)%5) from ft4 t1 full join ft5 t2 on (t1.c1 = t2.c1) where t1.c1 < 20 or (t1.c1 is null and t2.c1 < 5) group by (t2.c1)%3 order by 1;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:select array_agg(distinct (t1.c1)%5 order by (t1.c1)%5 desc nulls last) from ft4 t1 full join ft5 t2 on (t1.c1 = t2.c1) where t1.c1 < 20 or (t1.c1 is null and t2.c1 < 5) group by (t2.c1)%3 order by 1;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:select array_agg(distinct (t1.c1)%5 order by (t1.c1)%5 desc nulls last) from ft4 t1 full join ft5 t2 on (t1.c1 = t2.c1) where t1.c1 < 20 or (t1.c1 is null and t2.c1 < 5) group by (t2.c1)%3 order by 1;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:create function least_accum(anyelement, variadic anyarray)
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:create aggregate least_agg(variadic items anyarray) (
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:alter extension postgres_fdw add function least_accum(anyelement, variadic anyarray);
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:alter extension postgres_fdw add aggregate least_agg(variadic items anyarray);
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:alter extension postgres_fdw drop function least_accum(anyelement, variadic anyarray);
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:alter extension postgres_fdw drop aggregate least_agg(variadic items anyarray);
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:drop aggregate least_agg(variadic items anyarray);
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:drop function least_accum(anyelement, variadic anyarray);
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:select array_agg(c1 order by c1 using operator(public.<^)) from ft2 where c2 = 6 and c1 < 100 group by c2;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:select array_agg(c1 order by c1 using operator(public.<^)) from ft2 where c2 = 6 and c1 < 100 group by c2;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:select array_agg(c1 order by c1 using operator(public.<^)) from ft2 where c2 = 6 and c1 < 100 group by c2;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:select array_agg(c1 order by c1 using operator(public.<^)) from ft2 where c2 = 6 and c1 < 100 group by c2;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:select c2, array_agg(c2) over (partition by c2%2 order by c2 desc) from ft1 where c2 < 10 group by c2 order by 1;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:select c2, array_agg(c2) over (partition by c2%2 order by c2 desc) from ft1 where c2 < 10 group by c2 order by 1;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:select c2, array_agg(c2) over (partition by c2%2 order by c2 range between current row and unbounded following) from ft1 where c2 < 10 group by c2 order by 1;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:select c2, array_agg(c2) over (partition by c2%2 order by c2 range between current row and unbounded following) from ft1 where c2 < 10 group by c2 order by 1;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:SELECT sum(c2), array_agg(c8) FROM ft1 GROUP BY c8; -- ERROR
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:		oldnew := array_append(oldnew, format('OLD: %s', OLD));
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:		oldnew := array_append(oldnew, format('NEW: %s', NEW));
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:    RAISE NOTICE '%', array_to_string(oldnew, ',');
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:AND srvoptions @> array['fetch_size=101'];
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:AND srvoptions @> array['fetch_size=101'];
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:AND srvoptions @> array['fetch_size=202'];
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:AND ftoptions @> array['fetch_size=30000'];
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:AND ftoptions @> array['fetch_size=30000'];
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/sql/postgres_fdw.sql:AND ftoptions @> array['fetch_size=60000'];
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/postgres_fdw.c:	HeapTuple  *tuples;			/* array of currently-retrieved tuples */
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/postgres_fdw.c:	int			num_tuples;		/* # of tuples in array */
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/postgres_fdw.c:	HeapTuple  *rows;			/* array of size targrows */
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/postgres_fdw.c:	foreignrel = root->simple_rel_array[resultRelation];
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/postgres_fdw.c:	rte = root->simple_rte_array[resultRelation];
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/postgres_fdw.c:	 * Construct array of query parameter values in text format.  We do the
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/postgres_fdw.c: *		Create array of text strings representing parameter values
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/postgres_fdw.c:	 * Construct array of query parameter values in text format.
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/postgres_fdw.c: * Construct array of query parameter values in text format.
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/postgres_fdw.c: * Selected rows are returned in the caller-allocated array rows[],
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/postgres_fdw.c:	int			pos;			/* array index to store tuple in */
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/connection.c:		 * which case we'll just waste a few array slots.)  Add 3 extra slots
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:select array_agg(c1 order by c1) from ft1 where c1 < 100 group by c2 order by 1;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:   Output: (array_agg(c1 ORDER BY c1)), c2
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:   Sort Key: (array_agg(ft1.c1 ORDER BY ft1.c1))
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:         Output: (array_agg(c1 ORDER BY c1)), c2
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:         Remote SQL: SELECT array_agg("C 1" ORDER BY "C 1" ASC NULLS LAST), c2 FROM "S 1"."T 1" WHERE (("C 1" < 100)) GROUP BY 2
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:select array_agg(c1 order by c1) from ft1 where c1 < 100 group by c2 order by 1;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:           array_agg            
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:select array_agg(c5 order by c1 desc) from ft2 where c2 = 6 and c1 < 50;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:   Output: (array_agg(c5 ORDER BY c1 DESC))
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:   Remote SQL: SELECT array_agg(c5 ORDER BY "C 1" DESC NULLS FIRST) FROM "S 1"."T 1" WHERE (("C 1" < 50)) AND ((c2 = 6))
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:select array_agg(c5 order by c1 desc) from ft2 where c2 = 6 and c1 < 50;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:                                                                array_agg                                                                 
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:select array_agg(distinct (t1.c1)%5) from ft4 t1 full join ft5 t2 on (t1.c1 = t2.c1) where t1.c1 < 20 or (t1.c1 is null and t2.c1 < 5) group by (t2.c1)%3 order by 1;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:   Output: (array_agg(DISTINCT (t1.c1 % 5))), ((t2.c1 % 3))
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:   Sort Key: (array_agg(DISTINCT (t1.c1 % 5)))
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:         Output: (array_agg(DISTINCT (t1.c1 % 5))), ((t2.c1 % 3))
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:         Remote SQL: SELECT array_agg(DISTINCT (r1.c1 % 5)), (r2.c1 % 3) FROM ("S 1"."T 3" r1 FULL JOIN "S 1"."T 4" r2 ON (((r1.c1 = r2.c1)))) WHERE (((r1.c1 < 20) OR ((r1.c1 IS NULL) AND (r2.c1 < 5)))) GROUP BY 2
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:select array_agg(distinct (t1.c1)%5) from ft4 t1 full join ft5 t2 on (t1.c1 = t2.c1) where t1.c1 < 20 or (t1.c1 is null and t2.c1 < 5) group by (t2.c1)%3 order by 1;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:  array_agg   
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:select array_agg(distinct (t1.c1)%5 order by (t1.c1)%5) from ft4 t1 full join ft5 t2 on (t1.c1 = t2.c1) where t1.c1 < 20 or (t1.c1 is null and t2.c1 < 5) group by (t2.c1)%3 order by 1;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:   Output: (array_agg(DISTINCT (t1.c1 % 5) ORDER BY (t1.c1 % 5))), ((t2.c1 % 3))
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:   Sort Key: (array_agg(DISTINCT (t1.c1 % 5) ORDER BY (t1.c1 % 5)))
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:         Output: (array_agg(DISTINCT (t1.c1 % 5) ORDER BY (t1.c1 % 5))), ((t2.c1 % 3))
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:         Remote SQL: SELECT array_agg(DISTINCT (r1.c1 % 5) ORDER BY ((r1.c1 % 5)) ASC NULLS LAST), (r2.c1 % 3) FROM ("S 1"."T 3" r1 FULL JOIN "S 1"."T 4" r2 ON (((r1.c1 = r2.c1)))) WHERE (((r1.c1 < 20) OR ((r1.c1 IS NULL) AND (r2.c1 < 5)))) GROUP BY 2
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:select array_agg(distinct (t1.c1)%5 order by (t1.c1)%5) from ft4 t1 full join ft5 t2 on (t1.c1 = t2.c1) where t1.c1 < 20 or (t1.c1 is null and t2.c1 < 5) group by (t2.c1)%3 order by 1;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:  array_agg   
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:select array_agg(distinct (t1.c1)%5 order by (t1.c1)%5 desc nulls last) from ft4 t1 full join ft5 t2 on (t1.c1 = t2.c1) where t1.c1 < 20 or (t1.c1 is null and t2.c1 < 5) group by (t2.c1)%3 order by 1;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:   Output: (array_agg(DISTINCT (t1.c1 % 5) ORDER BY (t1.c1 % 5) DESC NULLS LAST)), ((t2.c1 % 3))
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:   Sort Key: (array_agg(DISTINCT (t1.c1 % 5) ORDER BY (t1.c1 % 5) DESC NULLS LAST))
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:         Output: (array_agg(DISTINCT (t1.c1 % 5) ORDER BY (t1.c1 % 5) DESC NULLS LAST)), ((t2.c1 % 3))
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:         Remote SQL: SELECT array_agg(DISTINCT (r1.c1 % 5) ORDER BY ((r1.c1 % 5)) DESC NULLS LAST), (r2.c1 % 3) FROM ("S 1"."T 3" r1 FULL JOIN "S 1"."T 4" r2 ON (((r1.c1 = r2.c1)))) WHERE (((r1.c1 < 20) OR ((r1.c1 IS NULL) AND (r2.c1 < 5)))) GROUP BY 2
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:select array_agg(distinct (t1.c1)%5 order by (t1.c1)%5 desc nulls last) from ft4 t1 full join ft5 t2 on (t1.c1 = t2.c1) where t1.c1 < 20 or (t1.c1 is null and t2.c1 < 5) group by (t2.c1)%3 order by 1;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:  array_agg   
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:create function least_accum(anyelement, variadic anyarray)
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:create aggregate least_agg(variadic items anyarray) (
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:alter extension postgres_fdw add function least_accum(anyelement, variadic anyarray);
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:alter extension postgres_fdw add aggregate least_agg(variadic items anyarray);
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:alter extension postgres_fdw drop function least_accum(anyelement, variadic anyarray);
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:alter extension postgres_fdw drop aggregate least_agg(variadic items anyarray);
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:drop aggregate least_agg(variadic items anyarray);
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:drop function least_accum(anyelement, variadic anyarray);
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:select array_agg(c1 order by c1 using operator(public.<^)) from ft2 where c2 = 6 and c1 < 100 group by c2;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:   Output: array_agg(c1 ORDER BY c1 USING <^ NULLS LAST), c2
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:select array_agg(c1 order by c1 using operator(public.<^)) from ft2 where c2 = 6 and c1 < 100 group by c2;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:   Output: (array_agg(c1 ORDER BY c1 USING <^ NULLS LAST)), c2
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:   Remote SQL: SELECT array_agg("C 1" ORDER BY "C 1" USING OPERATOR(public.<^) NULLS LAST), c2 FROM "S 1"."T 1" WHERE (("C 1" < 100)) AND ((c2 = 6)) GROUP BY 2
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:select array_agg(c1 order by c1 using operator(public.<^)) from ft2 where c2 = 6 and c1 < 100 group by c2;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:           array_agg            
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:select array_agg(c1 order by c1 using operator(public.<^)) from ft2 where c2 = 6 and c1 < 100 group by c2;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:   Output: array_agg(c1 ORDER BY c1 USING <^ NULLS LAST), c2
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:select c2, array_agg(c2) over (partition by c2%2 order by c2 desc) from ft1 where c2 < 10 group by c2 order by 1;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:   Output: c2, (array_agg(c2) OVER (?)), ((c2 % 2))
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:         Output: c2, array_agg(c2) OVER (?), ((c2 % 2))
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:select c2, array_agg(c2) over (partition by c2%2 order by c2 desc) from ft1 where c2 < 10 group by c2 order by 1;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out: c2 |  array_agg  
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:select c2, array_agg(c2) over (partition by c2%2 order by c2 range between current row and unbounded following) from ft1 where c2 < 10 group by c2 order by 1;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:   Output: c2, (array_agg(c2) OVER (?)), ((c2 % 2))
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:         Output: c2, array_agg(c2) OVER (?), ((c2 % 2))
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:select c2, array_agg(c2) over (partition by c2%2 order by c2 range between current row and unbounded following) from ft1 where c2 < 10 group by c2 order by 1;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out: c2 |  array_agg  
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:SELECT sum(c2), array_agg(c8) FROM ft1 GROUP BY c8; -- ERROR
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:		oldnew := array_append(oldnew, format('OLD: %s', OLD));
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:		oldnew := array_append(oldnew, format('NEW: %s', NEW));
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:    RAISE NOTICE '%', array_to_string(oldnew, ',');
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:AND srvoptions @> array['fetch_size=101'];
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:AND srvoptions @> array['fetch_size=101'];
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:AND srvoptions @> array['fetch_size=202'];
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:AND ftoptions @> array['fetch_size=30000'];
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:AND ftoptions @> array['fetch_size=30000'];
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/expected/postgres_fdw.out:AND ftoptions @> array['fetch_size=60000'];
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/deparse.c:				 * Recurse to remaining subexpressions.  Since the array
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/deparse.c:				collation = a->array_collid;
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/deparse.c:	RelOptInfo *baserel = root->simple_rel_array[rtindex];
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/deparse.c:	RelOptInfo *baserel = root->simple_rel_array[rtindex];
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/deparse.c:		/* Get RangeTblEntry from array in PlannerInfo. */
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/deparse.c:		/* Get RangeTblEntry from array in PlannerInfo. */
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/deparse.c: * Deparse an array subscript expression.
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/deparse.c:	 * Deparse referenced array expression first.  If that expression includes
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/deparse.c:	 * a cast, we have to parenthesize to prevent the array subscript from
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/deparse.c:	/* If the array is empty, we need an explicit cast to the array type. */
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/deparse.c:						 deparse_type_name(node->array_typeid, -1));
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/option.c:	 * Construct an array which consists of all valid options for
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/option.c: * Generate key-value arrays which include only libpq options from the
/srvr/z5089358/postgresql-10.4/contrib/postgres_fdw/option.c: * allocated large-enough arrays.  Returns number of options found.
/srvr/z5089358/postgresql-10.4/contrib/pg_stat_statements/pg_stat_statements.c:	/* Allocated length of clocations array */
/srvr/z5089358/postgresql-10.4/contrib/pg_stat_statements/pg_stat_statements.c:	/* Current number of valid entries in clocations array */
/srvr/z5089358/postgresql-10.4/contrib/pg_stat_statements/pg_stat_statements.c:		/* enlarge array if needed */
/srvr/z5089358/postgresql-10.4/contrib/pg_stat_statements/pg_stat_statements.c: * Given a valid SQL string and an array of constant-location records,
/srvr/z5089358/postgresql-10.4/contrib/hstore_plperl/sql/hstore_plperlu.sql:SELECT test1arr(array['aa=>bb, cc=>NULL'::hstore, 'dd=>ee']);
/srvr/z5089358/postgresql-10.4/contrib/hstore_plperl/expected/hstore_plperlu.out:SELECT test1arr(array['aa=>bb, cc=>NULL'::hstore, 'dd=>ee']);
/srvr/z5089358/postgresql-10.4/contrib/btree_gist/btree_gist--1.1--1.2.sql:  proargtypes = pg_catalog.array_to_string(newtypes::pg_catalog.oid[], ' ')::pg_catalog.oidvector,
/srvr/z5089358/postgresql-10.4/contrib/btree_gist/btree_gist--1.1--1.2.sql:  pronargs = pg_catalog.array_length(newtypes, 1)
/srvr/z5089358/postgresql-10.4/contrib/dict_int/dict_int.c:			/* reject by returning void array */
/srvr/z5089358/postgresql-10.4/contrib/cube/CHANGES:cube(float[]), which makes a zero volume cube from a float array
/srvr/z5089358/postgresql-10.4/contrib/cube/CHANGES:two float arrays; one for the upper right and one for the lower left
/srvr/z5089358/postgresql-10.4/contrib/cube/CHANGES:dimensions from a cube, using index values specified in the array.
/srvr/z5089358/postgresql-10.4/contrib/cube/cubescan.c: * integer for use as an array index.  If the signed char is negative,
/srvr/z5089358/postgresql-10.4/contrib/cube/cubescan.c:static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
/srvr/z5089358/postgresql-10.4/contrib/cube/cubescan.c:		/* Extend the array by 50%, plus the number we really need. */
/srvr/z5089358/postgresql-10.4/contrib/cube/sql/cube.sql:SELECT cube(array[10,20,30], array[40,50,60])->1;
/srvr/z5089358/postgresql-10.4/contrib/cube/sql/cube.sql:SELECT cube(array[40,50,60], array[10,20,30])->1;
/srvr/z5089358/postgresql-10.4/contrib/cube/sql/cube.sql:SELECT cube(array[10,20,30], array[40,50,60])->6;
/srvr/z5089358/postgresql-10.4/contrib/cube/sql/cube.sql:SELECT cube(array[10,20,30], array[40,50,60])->0;
/srvr/z5089358/postgresql-10.4/contrib/cube/sql/cube.sql:SELECT cube(array[10,20,30], array[40,50,60])->7;
/srvr/z5089358/postgresql-10.4/contrib/cube/sql/cube.sql:SELECT cube(array[10,20,30], array[40,50,60])->-1;
/srvr/z5089358/postgresql-10.4/contrib/cube/sql/cube.sql:SELECT cube(array[10,20,30], array[40,50,60])->-6;
/srvr/z5089358/postgresql-10.4/contrib/cube/sql/cube.sql:SELECT cube(array[10,20,30])->3;
/srvr/z5089358/postgresql-10.4/contrib/cube/sql/cube.sql:SELECT cube(array[10,20,30])->6;
/srvr/z5089358/postgresql-10.4/contrib/cube/sql/cube.sql:SELECT cube(array[10,20,30])->-6;
/srvr/z5089358/postgresql-10.4/contrib/cube/sql/cube.sql:SELECT cube(array[10,20,30], array[40,50,60])~>1;
/srvr/z5089358/postgresql-10.4/contrib/cube/sql/cube.sql:SELECT cube(array[40,50,60], array[10,20,30])~>1;
/srvr/z5089358/postgresql-10.4/contrib/cube/sql/cube.sql:SELECT cube(array[10,20,30], array[40,50,60])~>2;
/srvr/z5089358/postgresql-10.4/contrib/cube/sql/cube.sql:SELECT cube(array[40,50,60], array[10,20,30])~>2;
/srvr/z5089358/postgresql-10.4/contrib/cube/sql/cube.sql:SELECT cube(array[10,20,30], array[40,50,60])~>3;
/srvr/z5089358/postgresql-10.4/contrib/cube/sql/cube.sql:SELECT cube(array[40,50,60], array[10,20,30])~>3;
/srvr/z5089358/postgresql-10.4/contrib/cube/sql/cube.sql:SELECT cube(array[40,50,60], array[10,20,30])~>0;
/srvr/z5089358/postgresql-10.4/contrib/cube/sql/cube.sql:SELECT cube(array[40,50,60], array[10,20,30])~>4;
/srvr/z5089358/postgresql-10.4/contrib/cube/sql/cube.sql:SELECT cube(array[40,50,60], array[10,20,30])~>(-1);
/srvr/z5089358/postgresql-10.4/contrib/cube/cubeparse.c:/* The size of an array large to enough to hold all stacks, each with
/srvr/z5089358/postgresql-10.4/contrib/cube/cube--1.1--1.2.sql:  proargtypes = pg_catalog.array_to_string(newtypes::pg_catalog.oid[], ' ')::pg_catalog.oidvector,
/srvr/z5089358/postgresql-10.4/contrib/cube/cube--1.1--1.2.sql:  pronargs = pg_catalog.array_length(newtypes, 1)
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube.out:ERROR:  UR and LL arrays must be of same length
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube.out:SELECT cube(array[10,20,30], array[40,50,60])->1;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube.out:SELECT cube(array[40,50,60], array[10,20,30])->1;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube.out:SELECT cube(array[10,20,30], array[40,50,60])->6;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube.out:SELECT cube(array[10,20,30], array[40,50,60])->0;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube.out:SELECT cube(array[10,20,30], array[40,50,60])->7;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube.out:SELECT cube(array[10,20,30], array[40,50,60])->-1;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube.out:SELECT cube(array[10,20,30], array[40,50,60])->-6;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube.out:SELECT cube(array[10,20,30])->3;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube.out:SELECT cube(array[10,20,30])->6;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube.out:SELECT cube(array[10,20,30])->-6;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube.out:SELECT cube(array[10,20,30], array[40,50,60])~>1;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube.out:SELECT cube(array[40,50,60], array[10,20,30])~>1;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube.out:SELECT cube(array[10,20,30], array[40,50,60])~>2;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube.out:SELECT cube(array[40,50,60], array[10,20,30])~>2;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube.out:SELECT cube(array[10,20,30], array[40,50,60])~>3;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube.out:SELECT cube(array[40,50,60], array[10,20,30])~>3;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube.out:SELECT cube(array[40,50,60], array[10,20,30])~>0;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube.out:SELECT cube(array[40,50,60], array[10,20,30])~>4;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube.out:SELECT cube(array[40,50,60], array[10,20,30])~>(-1);
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube_2.out:ERROR:  UR and LL arrays must be of same length
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube_2.out:SELECT cube(array[10,20,30], array[40,50,60])->1;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube_2.out:SELECT cube(array[40,50,60], array[10,20,30])->1;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube_2.out:SELECT cube(array[10,20,30], array[40,50,60])->6;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube_2.out:SELECT cube(array[10,20,30], array[40,50,60])->0;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube_2.out:SELECT cube(array[10,20,30], array[40,50,60])->7;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube_2.out:SELECT cube(array[10,20,30], array[40,50,60])->-1;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube_2.out:SELECT cube(array[10,20,30], array[40,50,60])->-6;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube_2.out:SELECT cube(array[10,20,30])->3;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube_2.out:SELECT cube(array[10,20,30])->6;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube_2.out:SELECT cube(array[10,20,30])->-6;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube_2.out:SELECT cube(array[10,20,30], array[40,50,60])~>1;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube_2.out:SELECT cube(array[40,50,60], array[10,20,30])~>1;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube_2.out:SELECT cube(array[10,20,30], array[40,50,60])~>2;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube_2.out:SELECT cube(array[40,50,60], array[10,20,30])~>2;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube_2.out:SELECT cube(array[10,20,30], array[40,50,60])~>3;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube_2.out:SELECT cube(array[40,50,60], array[10,20,30])~>3;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube_2.out:SELECT cube(array[40,50,60], array[10,20,30])~>0;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube_2.out:SELECT cube(array[40,50,60], array[10,20,30])~>4;
/srvr/z5089358/postgresql-10.4/contrib/cube/expected/cube_2.out:SELECT cube(array[40,50,60], array[10,20,30])~>(-1);
/srvr/z5089358/postgresql-10.4/contrib/cube/cube.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/contrib/cube/cube.c: * Taken from the intarray contrib header
/srvr/z5089358/postgresql-10.4/contrib/cube/cube.c:	if (array_contains_nulls(ur) || array_contains_nulls(ll))
/srvr/z5089358/postgresql-10.4/contrib/cube/cube.c:				 errmsg("cannot work with arrays containing NULLs")));
/srvr/z5089358/postgresql-10.4/contrib/cube/cube.c:				 errmsg("UR and LL arrays must be of same length")));
/srvr/z5089358/postgresql-10.4/contrib/cube/cube.c:	if (array_contains_nulls(ur))
/srvr/z5089358/postgresql-10.4/contrib/cube/cube.c:				 errmsg("cannot work with arrays containing NULLs")));
/srvr/z5089358/postgresql-10.4/contrib/cube/cube.c:	if (array_contains_nulls(idx))
/srvr/z5089358/postgresql-10.4/contrib/cube/cube.c:				 errmsg("cannot work with arrays containing NULLs")));
/srvr/z5089358/postgresql-10.4/contrib/xml2/xpath.c:			 * Clear the values array, so that not-well-formed documents
/srvr/z5089358/postgresql-10.4/contrib/pageinspect/ginfuncs.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/contrib/pageinspect/ginfuncs.c:	/* Convert the flags bitmask to an array of human-readable names */
/srvr/z5089358/postgresql-10.4/contrib/pageinspect/ginfuncs.c:	values[2] = PointerGetDatum(construct_array(flags, nflags,
/srvr/z5089358/postgresql-10.4/contrib/pageinspect/ginfuncs.c:		/* build an array of decoded item pointers */
/srvr/z5089358/postgresql-10.4/contrib/pageinspect/ginfuncs.c:		values[2] = PointerGetDatum(construct_array(tids_datum,
/srvr/z5089358/postgresql-10.4/contrib/pageinspect/heapfuncs.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/contrib/pageinspect/heapfuncs.c: * Converts a bits8-array of 'len' bits to a human-readable
/srvr/z5089358/postgresql-10.4/contrib/pageinspect/heapfuncs.c: * Converts a c-string representation of bits into a bits8-array. This is
/srvr/z5089358/postgresql-10.4/contrib/pageinspect/heapfuncs.c: * Split raw tuple data taken directly from a page into an array of bytea
/srvr/z5089358/postgresql-10.4/contrib/pageinspect/heapfuncs.c: * elements. This routine does a lookup on NULL values and creates array
/srvr/z5089358/postgresql-10.4/contrib/pageinspect/heapfuncs.c:	 * Convert t_bits string back to the bits8 array as represented in the
/srvr/z5089358/postgresql-10.4/contrib/pageinspect/hashfuncs.c:	values[j++] = PointerGetDatum(construct_array(spares,
/srvr/z5089358/postgresql-10.4/contrib/pageinspect/hashfuncs.c:	values[j++] = PointerGetDatum(construct_array(mapp,
/srvr/z5089358/postgresql-10.4/contrib/pageinspect/brinfuncs.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/contrib/pageinspect/brinfuncs.c: * Return the TID array stored in a BRIN revmap page
/srvr/z5089358/postgresql-10.4/contrib/pg_buffercache/pg_buffercache_pages.c:			/* unused for v1.0 callers, but the array is always long enough */
/srvr/z5089358/postgresql-10.4/contrib/pg_buffercache/pg_buffercache_pages.c:			/* unused for v1.0 callers, but the array is always long enough */
/srvr/z5089358/postgresql-10.4/contrib/pgstattuple/pgstatapprox.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/contrib/pgstattuple/pgstattuple.c:	 * Prepare a values array for constructing the tuple. This should be an
/srvr/z5089358/postgresql-10.4/contrib/pgstattuple/pgstattuple.c:	 * array of C strings which will be processed later by the appropriate
/srvr/z5089358/postgresql-10.4/contrib/dblink/sql/dblink.sql:-- dblink_get_connections returns an array with elements in a machine-dependent
/srvr/z5089358/postgresql-10.4/contrib/dblink/sql/dblink.sql:create function unnest(anyarray) returns setof anyelement
/srvr/z5089358/postgresql-10.4/contrib/dblink/sql/dblink.sql:select $1[i] from generate_series(array_lower($1,1), array_upper($1,1)) as i
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:static char **get_text_array_contents(ArrayType *array, int *numitems);
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:		 * Set up sufficiently-wide string pointers array; this won't change
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c: * Returns an array of all connection names.
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:		/* get the array of attnums */
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c: * <src_pkattvals_arry> - text array of key values which will be used
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c: * <tgt_pkattvals_arry> - text array of key values which will be used
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:	 * Source array is made up of key values that will be used to locate the
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:	src_pkattvals = get_text_array_contents(src_pkattvals_arry, &src_nitems);
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:	 * There should be one source array key value for each key attnum
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:				 errmsg("source key array length must match number of key " \
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:	 * Target array is made up of key values that will be used to build the
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:	tgt_pkattvals = get_text_array_contents(tgt_pkattvals_arry, &tgt_nitems);
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:	 * There should be one target array key value for each key attnum
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:				 errmsg("target key array length must match number of key " \
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c: * <tgt_pkattvals_arry> - text array of key values which will be used
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:	 * Target array is made up of key values that will be used to build the
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:	tgt_pkattvals = get_text_array_contents(tgt_pkattvals_arry, &tgt_nitems);
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:	 * There should be one target array key value for each key attnum
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:				 errmsg("target key array length must match number of key " \
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c: * <src_pkattvals_arry> - text array of key values which will be used
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c: * <tgt_pkattvals_arry> - text array of key values which will be used
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:	 * Source array is made up of key values that will be used to locate the
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:	src_pkattvals = get_text_array_contents(src_pkattvals_arry, &src_nitems);
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:	 * There should be one source array key value for each key attnum
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:				 errmsg("source key array length must match number of key " \
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:	 * Target array is made up of key values that will be used to build the
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:	tgt_pkattvals = get_text_array_contents(tgt_pkattvals_arry, &tgt_nitems);
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:	 * There should be one target array key value for each key attnum
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:				 errmsg("target key array length must match number of key " \
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:get_text_array_contents(ArrayType *array, int *numitems)
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:	int			ndim = ARR_NDIM(array);
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:	int		   *dims = ARR_DIMS(array);
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:	Assert(ARR_ELEMTYPE(array) == TEXTOID);
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:	get_typlenbyvalalign(ARR_ELEMTYPE(array),
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:	ptr = ARR_DATA_PTR(array);
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:	bitmap = ARR_NULLBITMAP(array);
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c: * The internal representation is a palloc'd int array of 0-based physical
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:	/* Don't take more array elements than there are */
/srvr/z5089358/postgresql-10.4/contrib/dblink/dblink.c:	/* Allocate output array */
/srvr/z5089358/postgresql-10.4/contrib/dblink/expected/dblink.out:-- dblink_get_connections returns an array with elements in a machine-dependent
/srvr/z5089358/postgresql-10.4/contrib/dblink/expected/dblink.out:create function unnest(anyarray) returns setof anyelement
/srvr/z5089358/postgresql-10.4/contrib/dblink/expected/dblink.out:select $1[i] from generate_series(array_lower($1,1), array_upper($1,1)) as i
/srvr/z5089358/postgresql-10.4/contrib/tablefunc/tablefunc.c:				 * Be careful to assign the value to the array index based on
/srvr/z5089358/postgresql-10.4/contrib/dict_xsyn/dict_xsyn.c:	/* Parse string of synonyms and return array of words */
/srvr/z5089358/postgresql-10.4/contrib/unaccent/unaccent.c: * of the trie is an array of 256 TrieChar structs; the N-th element of the
/srvr/z5089358/postgresql-10.4/contrib/unaccent/unaccent.c: * array corresponds to next byte value N.  That element can contain both a
/srvr/z5089358/postgresql-10.4/contrib/citext/sql/citext.sql:SELECT regexp_split_to_array('hello world'::citext, E'\\s+') = ARRAY[ 'hello', 'world' ] AS t;
/srvr/z5089358/postgresql-10.4/contrib/citext/sql/citext.sql:SELECT regexp_split_to_array('helloTworld'::citext, 't') = ARRAY[ 'hello', 'world' ] AS t;
/srvr/z5089358/postgresql-10.4/contrib/citext/sql/citext.sql:SELECT regexp_split_to_array('helloTworld', 't'::citext) = ARRAY[ 'hello', 'world' ] AS t;
/srvr/z5089358/postgresql-10.4/contrib/citext/sql/citext.sql:SELECT regexp_split_to_array('helloTworld'::citext, 't'::citext) = ARRAY[ 'hello', 'world' ] AS t;
/srvr/z5089358/postgresql-10.4/contrib/citext/sql/citext.sql:SELECT regexp_split_to_array('helloTworld'::citext, 't', 's') = ARRAY[ 'hello', 'world' ] AS t;
/srvr/z5089358/postgresql-10.4/contrib/citext/sql/citext.sql:SELECT regexp_split_to_array('helloTworld', 't'::citext, 's') = ARRAY[ 'hello', 'world' ] AS t;
/srvr/z5089358/postgresql-10.4/contrib/citext/sql/citext.sql:SELECT regexp_split_to_array('helloTworld'::citext, 't'::citext, 's') = ARRAY[ 'hello', 'world' ] AS t;
/srvr/z5089358/postgresql-10.4/contrib/citext/sql/citext.sql:SELECT regexp_split_to_array('helloTworld'::citext, 't'::citext, 'c') = ARRAY[ 'helloTworld' ] AS t;
/srvr/z5089358/postgresql-10.4/contrib/citext/citext--1.1--1.2.sql:ALTER FUNCTION regexp_split_to_array(citext, citext) PARALLEL SAFE;
/srvr/z5089358/postgresql-10.4/contrib/citext/citext--1.1--1.2.sql:ALTER FUNCTION regexp_split_to_array(citext, citext, text) PARALLEL SAFE;
/srvr/z5089358/postgresql-10.4/contrib/citext/citext--1.4.sql:CREATE FUNCTION regexp_split_to_array( citext, citext ) RETURNS TEXT[] AS $$
/srvr/z5089358/postgresql-10.4/contrib/citext/citext--1.4.sql:    SELECT pg_catalog.regexp_split_to_array( $1::pg_catalog.text, $2::pg_catalog.text, 'i' );
/srvr/z5089358/postgresql-10.4/contrib/citext/citext--1.4.sql:CREATE FUNCTION regexp_split_to_array( citext, citext, text ) RETURNS TEXT[] AS $$
/srvr/z5089358/postgresql-10.4/contrib/citext/citext--1.4.sql:    SELECT pg_catalog.regexp_split_to_array( $1::pg_catalog.text, $2::pg_catalog.text, CASE WHEN pg_catalog.strpos($3, 'c') = 0 THEN  $3 || 'i' ELSE $3 END );
/srvr/z5089358/postgresql-10.4/contrib/citext/citext--1.4.sql:    SELECT (pg_catalog.regexp_split_to_array( $1::pg_catalog.text, pg_catalog.regexp_replace($2::pg_catalog.text, '([^a-zA-Z_0-9])', E'\\\\\\1', 'g'), 'i'))[$3];
/srvr/z5089358/postgresql-10.4/contrib/citext/expected/citext.out:SELECT regexp_split_to_array('hello world'::citext, E'\\s+') = ARRAY[ 'hello', 'world' ] AS t;
/srvr/z5089358/postgresql-10.4/contrib/citext/expected/citext.out:SELECT regexp_split_to_array('helloTworld'::citext, 't') = ARRAY[ 'hello', 'world' ] AS t;
/srvr/z5089358/postgresql-10.4/contrib/citext/expected/citext.out:SELECT regexp_split_to_array('helloTworld', 't'::citext) = ARRAY[ 'hello', 'world' ] AS t;
/srvr/z5089358/postgresql-10.4/contrib/citext/expected/citext.out:SELECT regexp_split_to_array('helloTworld'::citext, 't'::citext) = ARRAY[ 'hello', 'world' ] AS t;
/srvr/z5089358/postgresql-10.4/contrib/citext/expected/citext.out:SELECT regexp_split_to_array('helloTworld'::citext, 't', 's') = ARRAY[ 'hello', 'world' ] AS t;
/srvr/z5089358/postgresql-10.4/contrib/citext/expected/citext.out:SELECT regexp_split_to_array('helloTworld', 't'::citext, 's') = ARRAY[ 'hello', 'world' ] AS t;
/srvr/z5089358/postgresql-10.4/contrib/citext/expected/citext.out:SELECT regexp_split_to_array('helloTworld'::citext, 't'::citext, 's') = ARRAY[ 'hello', 'world' ] AS t;
/srvr/z5089358/postgresql-10.4/contrib/citext/expected/citext.out:SELECT regexp_split_to_array('helloTworld'::citext, 't'::citext, 'c') = ARRAY[ 'helloTworld' ] AS t;
/srvr/z5089358/postgresql-10.4/contrib/citext/expected/citext_1.out:SELECT regexp_split_to_array('hello world'::citext, E'\\s+') = ARRAY[ 'hello', 'world' ] AS t;
/srvr/z5089358/postgresql-10.4/contrib/citext/expected/citext_1.out:SELECT regexp_split_to_array('helloTworld'::citext, 't') = ARRAY[ 'hello', 'world' ] AS t;
/srvr/z5089358/postgresql-10.4/contrib/citext/expected/citext_1.out:SELECT regexp_split_to_array('helloTworld', 't'::citext) = ARRAY[ 'hello', 'world' ] AS t;
/srvr/z5089358/postgresql-10.4/contrib/citext/expected/citext_1.out:SELECT regexp_split_to_array('helloTworld'::citext, 't'::citext) = ARRAY[ 'hello', 'world' ] AS t;
/srvr/z5089358/postgresql-10.4/contrib/citext/expected/citext_1.out:SELECT regexp_split_to_array('helloTworld'::citext, 't', 's') = ARRAY[ 'hello', 'world' ] AS t;
/srvr/z5089358/postgresql-10.4/contrib/citext/expected/citext_1.out:SELECT regexp_split_to_array('helloTworld', 't'::citext, 's') = ARRAY[ 'hello', 'world' ] AS t;
/srvr/z5089358/postgresql-10.4/contrib/citext/expected/citext_1.out:SELECT regexp_split_to_array('helloTworld'::citext, 't'::citext, 's') = ARRAY[ 'hello', 'world' ] AS t;
/srvr/z5089358/postgresql-10.4/contrib/citext/expected/citext_1.out:SELECT regexp_split_to_array('helloTworld'::citext, 't'::citext, 'c') = ARRAY[ 'helloTworld' ] AS t;
/srvr/z5089358/postgresql-10.4/contrib/citext/citext--unpackaged--1.0.sql:ALTER EXTENSION citext ADD function regexp_split_to_array(citext,citext);
/srvr/z5089358/postgresql-10.4/contrib/citext/citext--unpackaged--1.0.sql:ALTER EXTENSION citext ADD function regexp_split_to_array(citext,citext,text);
/srvr/z5089358/postgresql-10.4/contrib/citext/citext--unpackaged--1.0.sql:-- as well as those for arrays/domains based directly or indirectly on citext.
/srvr/z5089358/postgresql-10.4/contrib/bloom/blinsert.c:	 * array.  If successful, we don't need to modify the meta page.
/srvr/z5089358/postgresql-10.4/contrib/bloom/blinsert.c:	 * Try other pages in notFullPage array.  We will have to change nStart in
/srvr/z5089358/postgresql-10.4/contrib/bloom/blinsert.c:	 * This loop iterates for each page we try from the notFullPage array, and
/srvr/z5089358/postgresql-10.4/contrib/bloom/blinsert.c:			break;				/* no more entries in notFullPage array */
/srvr/z5089358/postgresql-10.4/contrib/bloom/blinsert.c:	 * Didn't find place to insert in notFullPage array.  Allocate new page.
/srvr/z5089358/postgresql-10.4/contrib/bloom/blinsert.c:	/* Reset notFullPage array to contain just this new page */
/srvr/z5089358/postgresql-10.4/contrib/bloom/blutils.c:	amroutine->amsearcharray = false;
/srvr/z5089358/postgresql-10.4/contrib/bloom/bloom.h: * We store Bloom signatures as arrays of uint16 words.
/srvr/z5089358/postgresql-10.4/contrib/bloom/bloom.h: * FreeBlockNumberArray - array of block numbers sized so that metadata fill
/srvr/z5089358/postgresql-10.4/src/test/modules/test_shm_mq/worker.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/test/modules/test_pg_dump/t/001_base.pl:# dump_cmd is the pg_dump command to run, which is an array of
/srvr/z5089358/postgresql-10.4/src/test/modules/test_rls_hooks/test_rls_hooks.c:	policy->roles = construct_array(&role, 1, OIDOID, sizeof(Oid), true, 'i');
/srvr/z5089358/postgresql-10.4/src/test/modules/test_rls_hooks/test_rls_hooks.c:	policy->roles = construct_array(&role, 1, OIDOID, sizeof(Oid), true, 'i');
/srvr/z5089358/postgresql-10.4/src/test/modules/test_ddl_deparse/test_ddl_deparse.c: * Return a text array representation of the subcommands of an ALTER TABLE
/srvr/z5089358/postgresql-10.4/src/test/perl/PostgresNode.pm:As a convenience, if B<psql> is called in array context it returns an
/srvr/z5089358/postgresql-10.4/src/test/perl/PostgresNode.pm:array containing ($retval, $stdout, $stderr).
/srvr/z5089358/postgresql-10.4/src/test/perl/PostgresNode.pm:unless B<psql> is called in array context, in which case it's captured and
/srvr/z5089358/postgresql-10.4/src/test/perl/PostgresNode.pm:If given, it must be an array reference containing additional parameters to B<psql>.
/srvr/z5089358/postgresql-10.4/src/test/perl/PostgresNode.pm:	# If the caller wants an array and hasn't passed stdout/stderr
/srvr/z5089358/postgresql-10.4/src/test/perl/PostgresNode.pm:	if (wantarray)
/srvr/z5089358/postgresql-10.4/src/test/perl/PostgresNode.pm:	if (wantarray)
/srvr/z5089358/postgresql-10.4/src/test/perl/PostgresNode.pm:	die 'calls in array context for multi-row results not supported yet'
/srvr/z5089358/postgresql-10.4/src/test/perl/PostgresNode.pm:	  if (wantarray);
/srvr/z5089358/postgresql-10.4/src/test/perl/PostgresNode.pm:If called in array context, returns a tuple of (retval, stdout, stderr, timeout).
/srvr/z5089358/postgresql-10.4/src/test/perl/PostgresNode.pm:			  unless wantarray;
/srvr/z5089358/postgresql-10.4/src/test/perl/PostgresNode.pm:	if (wantarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/regress.c:	int32	   *an_array = (int32 *) PG_GETARG_POINTER(0);
/srvr/z5089358/postgresql-10.4/src/test/regress/regress.c:		pg_ltoa(an_array[i], walk);
/srvr/z5089358/postgresql-10.4/src/test/regress/regress.c:	 * function into a container type (record, array, etc) it should be OK.
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/strings.sql:-- optional capture group did not match, null entry in array
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/strings.sql:SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', $re$\s+$re$);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/strings.sql:SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', $re$\s*$re$);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/strings.sql:SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', '');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/strings.sql:SELECT regexp_split_to_array('thE QUick bROWn FOx jUMPs ovEr The lazy dOG', 'e', 'i');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/strings.sql:SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', 'nomatch');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/strings.sql:SELECT regexp_split_to_array('123456','1');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/strings.sql:SELECT regexp_split_to_array('123456','6');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/strings.sql:SELECT regexp_split_to_array('123456','.');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/strings.sql:SELECT regexp_split_to_array('thE QUick bROWn FOx jUMPs ovEr The lazy dOG', 'e', 'iz');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/strings.sql:SELECT regexp_split_to_array('thE QUick bROWn FOx jUMPs ovEr The lazy dOG', 'e', 'g');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rowsecurity.sql:SELECT (string_to_array(polqual, ':'))[7] AS inputcollid FROM pg_policy WHERE polrelid = 'coll_t'::regclass;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/insert_conflict.sql:-- Does the same, but JSON format shows "Conflict Arbiter Index" as JSON array:
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/collate.icu.utf8.sql:SELECT array_agg(b ORDER BY b) FROM collate_test1;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/collate.icu.utf8.sql:SELECT array_agg(b ORDER BY b) FROM collate_test2;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/collate.icu.utf8.sql:SELECT array_agg(b ORDER BY b) FROM collate_test3;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/collate.icu.utf8.sql:SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test1)) ORDER BY 1;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/collate.icu.utf8.sql:SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test2)) ORDER BY 1;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/collate.icu.utf8.sql:SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test3)) ORDER BY 1;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/text.sql:select concat(variadic array[1,2,3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/text.sql:select concat_ws(',', variadic array[1,2,3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/text.sql:select format('%s, %s', variadic array['Hello','World']);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/text.sql:select format('%s, %s', variadic array[1, 2]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/text.sql:select format('%s, %s', variadic array[true, false]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/text.sql:select format('%s, %s', variadic array[true, false]::text[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/text.sql:select format('%2$s, %1$s', variadic array['first', 'second']);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/text.sql:select format('%2$s, %1$s', variadic array[1, 2]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/text.sql:-- variadic argument can be array type NULL, but should not be referenced
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/text.sql:select format(string_agg('%s',','), variadic array_agg(i))
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/aggregates.sql:select array(select sum(x+y) s
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/aggregates.sql:select array(select sum(x+y) s
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/aggregates.sql:select array_agg(a order by b)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/aggregates.sql:select array_agg(a order by a)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/aggregates.sql:select array_agg(a order by a desc)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/aggregates.sql:select array_agg(b order by a desc)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/aggregates.sql:select array_agg(distinct a)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/aggregates.sql:select array_agg(distinct a order by a)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/aggregates.sql:select array_agg(distinct a order by a desc)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/aggregates.sql:select array_agg(distinct a order by a desc nulls last)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/aggregates.sql:select percentile_disc(array[0,0.1,0.25,0.5,0.75,0.9,1]) within group (order by thousand)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/aggregates.sql:select percentile_cont(array[0,0.25,0.5,0.75,1]) within group (order by thousand)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/aggregates.sql:select percentile_disc(array[[null,1,0.5],[0.75,0.25,null]]) within group (order by thousand)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/aggregates.sql:select percentile_cont(array[0,1,0.25,0.75,0.5,1,0.3,0.32,0.35,0.38,0.4]) within group (order by x)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/aggregates.sql:select percentile_disc(array[0.25,0.5,0.75]) within group (order by x)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/aggregates.sql:select array(select percentile_disc(a) within group (order by x)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/aggregates.sql:select least_agg(variadic array[q1,q2]) from int8_tbl;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/with.sql:	array_upper(t1.path,1) = 1 AND
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/with.sql:	array_upper(t2.path,1) > 1)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/with.sql:	array_upper(t1.path,1) = 1 AND
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/with.sql:	array_upper(t2.path,1) > 1)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/with.sql:	select *, array[row(g.f, g.t)], false from graph g
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/with.sql:	select *, array[row(g.f, g.t)], false from graph g
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/with.sql:C as ( select A.id, array(select B.id from B where B.id = A.id) from A )
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rowtypes.sql:-- Check ability to create arrays of anonymous rowtypes
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rowtypes.sql:select array[ row(1,2), row(3,4), row(5,6) ];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rowtypes.sql:-- Check ability to compare an anonymous row to elements of an array
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rowtypes.sql:select row(1,1.1) = any (array[ row(7,7.7), row(1,1.1), row(0,0.0) ]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rowtypes.sql:select row(1,1.1) = any (array[ row(7,7.7), row(1,1.0), row(0,0.0) ]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:-- array_to_json
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:SELECT array_to_json(array(select 1 as a));
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:SELECT array_to_json(array_agg(q),false) from (select x as b, x * 2 as c from generate_series(1,3) x) q;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:SELECT array_to_json(array_agg(q),true) from (select x as b, x * 2 as c from generate_series(1,3) x) q;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:SELECT array_to_json(array_agg(q),false)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:SELECT array_to_json(array_agg(x),false) from generate_series(5,10) x;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:SELECT array_to_json('{{1,5},{99,100}}'::int[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:SELECT row_to_json(row((select array_agg(x) as d from generate_series(5,10) x)),false);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:-- anyarray column
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:('array','["zero", "one","two",null,"four","five", [1,2,3],{"f1":9}]'),
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:SELECT test_json ->> 6 FROM test_json WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:SELECT test_json ->> 7 FROM test_json WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:    (select json_object_keys(json_object(array_agg(g)))
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:     from (select unnest(array['f'||n,n::text])as g
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:where json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:where json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:-- array length
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:SELECT json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:SELECT json_array_length('[]');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:SELECT json_array_length('{"f1":1,"f2":[5,6]}');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:SELECT json_array_length('4');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::json#>array['f4','f6'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::json#>array['f2'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::json#>array['f2','0'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::json#>array['f2','1'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::json#>>array['f4','f6'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::json#>>array['f2'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::json#>>array['f2','0'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::json#>>array['f2','1'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"a": {"b":{"c": "foo"}}}'::json #> array['a'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"a": {"b":{"c": "foo"}}}'::json #> array['a', null];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"a": {"b":{"c": "foo"}}}'::json #> array['a', ''];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"a": {"b":{"c": "foo"}}}'::json #> array['a','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"a": {"b":{"c": "foo"}}}'::json #> array['a','b','c'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"a": {"b":{"c": "foo"}}}'::json #> array['a','b','c','d'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"a": {"b":{"c": "foo"}}}'::json #> array['a','z','c'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json #> array['a','1','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json #> array['a','z','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '[{"b": "c"}, {"b": "cc"}]'::json #> array['1','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '[{"b": "c"}, {"b": "cc"}]'::json #> array['z','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '[{"b": "c"}, {"b": null}]'::json #> array['1','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '"foo"'::json #> array['z'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '42'::json #> array['f2'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '42'::json #> array['0'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a', null];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a', ''];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a','b','c'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a','b','c','d'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a','z','c'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json #>> array['a','1','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json #>> array['a','z','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '[{"b": "c"}, {"b": "cc"}]'::json #>> array['1','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '[{"b": "c"}, {"b": "cc"}]'::json #>> array['z','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '[{"b": "c"}, {"b": null}]'::json #>> array['1','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '"foo"'::json #>> array['z'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '42'::json #>> array['f2'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select '42'::json #>> array['0'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:-- array_elements
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select json_array_elements('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select * from json_array_elements('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]') q;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select json_array_elements_text('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:select * from json_array_elements_text('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]') q;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:CREATE DOMAIN js_int_array_1d  AS int[]   CHECK(array_length(VALUE, 1) = 3);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:CREATE DOMAIN js_int_array_2d  AS int[][] CHECK(array_length(VALUE, 2) = 3);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:	ia1d	js_int_array_1d,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:	ia2d	js_int_array_2d,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:DROP DOMAIN js_int_array_1d;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:DROP DOMAIN js_int_array_2d;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:-- json_build_array, json_build_object, json_object_agg
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:SELECT json_build_array('a',1,'b',1.2,'c',true,'d',null,'e',json '{"x": 3, "y": [1,2,3]}');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:SELECT json_build_array('a', NULL); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:SELECT json_build_array(VARIADIC NULL::text[]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:SELECT json_build_array(VARIADIC '{}'::text[]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:SELECT json_build_array(VARIADIC '{a,b,c}'::text[]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:SELECT json_build_array(VARIADIC ARRAY['a', NULL]::text[]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:SELECT json_build_array(VARIADIC '{1,2,3,4}'::text[]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:SELECT json_build_array(VARIADIC '{1,2,3,4}'::int[]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:SELECT json_build_array(VARIADIC '{{1,4},{2,5},{3,6}}'::int[][]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:       'd', json_build_object('e',array[9,8,7]::int[],
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:SELECT json_build_object('{a,b,c}'::text[], '{d,e,f}'::text[]); -- error, key cannot be array
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:-- empty objects/arrays
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/json.sql:SELECT json_build_array();
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/tstypes.sql:SELECT tsvector_to_array('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/tstypes.sql:SELECT tsvector_to_array('base hidden rebel spaceship strike'::tsvector);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/tstypes.sql:SELECT array_to_tsvector(ARRAY['base','hidden','rebel','spaceship','strike']);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/tstypes.sql:SELECT array_to_tsvector(ARRAY['base','hidden','rebel','spaceship', NULL]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/tstypes.sql:-- array_to_tsvector must sort and de-dup
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/tstypes.sql:SELECT array_to_tsvector(ARRAY['foo','bar','baz','bar']);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/gin.sql:insert into gin_test_tbl select array[1, 2, g] from generate_series(1, 20000) g;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/gin.sql:insert into gin_test_tbl select array[1, 3, g] from generate_series(1, 1000) g;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/gin.sql:insert into gin_test_tbl select array[3, 1, g] from generate_series(1, 1000) g;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/gin.sql:delete from gin_test_tbl where i @> array[2];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/gin.sql:insert into gin_test_tbl select array[1, 2, g] from generate_series(1, 1000) g;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/gin.sql:insert into gin_test_tbl select array[1, 3, g] from generate_series(1, 1000) g;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/gin.sql:delete from gin_test_tbl where i @> array[2];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/privileges.sql:-- verify privilege checks on array-element coercions
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/brin.sql:		FOR plan_line IN EXECUTE format($y$EXPLAIN SELECT array_agg(ctid) FROM brintest WHERE %s $y$, cond) LOOP
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/brin.sql:		EXECUTE format($y$SELECT array_agg(ctid) FROM brintest WHERE %s $y$, cond)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/brin.sql:		FOR plan_line IN EXECUTE format($y$EXPLAIN SELECT array_agg(ctid) FROM brintest WHERE %s $y$, cond) LOOP
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/brin.sql:		EXECUTE format($y$SELECT array_agg(ctid) FROM brintest WHERE %s $y$, cond)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/brin.sql:		count := array_length(idx_ctids, 1);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/brin.sql:		IF NOT (count = array_length(ss_ctids, 1) AND
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_view.sql:select 'foo'::text = any(array['abc','def','foo']::text[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_view.sql:select 'foo'::text = any((select array['abc','def','foo']::text[]));  -- fail
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_view.sql:select 'foo'::text = any((select array['abc','def','foo']::text[])::text[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_view.sql:select 'foo'::text = any(array['abc','def','foo']::text[]) c1,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_view.sql:       'foo'::text = any((select array['abc','def','foo']::text[])::text[]) c2;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/alter_table.sql:-- check renaming to a table's array type's autogenerated name
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/alter_table.sql:-- (the array type's name should get out of the way)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/alter_table.sql:CREATE TABLE tmp_array (id int);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/alter_table.sql:CREATE TABLE tmp_array2 (id int);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/alter_table.sql:SELECT typname FROM pg_type WHERE oid = 'tmp_array[]'::regtype;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/alter_table.sql:SELECT typname FROM pg_type WHERE oid = 'tmp_array2[]'::regtype;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/alter_table.sql:ALTER TABLE tmp_array2 RENAME TO _tmp_array;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/alter_table.sql:SELECT typname FROM pg_type WHERE oid = 'tmp_array[]'::regtype;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/alter_table.sql:SELECT typname FROM pg_type WHERE oid = '_tmp_array[]'::regtype;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/alter_table.sql:DROP TABLE _tmp_array;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/alter_table.sql:DROP TABLE tmp_array;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/alter_table.sql:-- renaming to table's own array type's name is an interesting corner case
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/alter_table.sql:CREATE TABLE tmp_array (id int);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/alter_table.sql:SELECT typname FROM pg_type WHERE oid = 'tmp_array[]'::regtype;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/alter_table.sql:ALTER TABLE tmp_array RENAME TO _tmp_array;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/alter_table.sql:SELECT typname FROM pg_type WHERE oid = '_tmp_array[]'::regtype;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/alter_table.sql:DROP TABLE _tmp_array;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/alter_table.sql:create domain array_of_recur1 as recur1[];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/alter_table.sql:alter table recur1 add column f2 array_of_recur1; -- fails
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/opr_sanity.sql:  if $2 = 'pg_catalog.anyarray'::pg_catalog.regtype then
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/opr_sanity.sql:  if $2 = 'pg_catalog.anyarray'::pg_catalog.regtype then
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/opr_sanity.sql:       array_lower(p1.proargtypes, 1) != 0 OR
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/opr_sanity.sql:       array_upper(p1.proargtypes, 1) != p1.pronargs-1 OR
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/opr_sanity.sql:    ('anyelement'::regtype, 'anyarray'::regtype, 'anynonarray'::regtype,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/opr_sanity.sql:     'anyarray'::regtype = ANY (p1.proargtypes) OR
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/opr_sanity.sql:     'anynonarray'::regtype = ANY (p1.proargtypes) OR
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/opr_sanity.sql:-- Check for length inconsistencies between the various argument-info arrays.
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/opr_sanity.sql:    array_length(proallargtypes,1) < array_length(proargtypes,1);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/opr_sanity.sql:    array_length(proargmodes,1) < array_length(proargtypes,1);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/opr_sanity.sql:    array_length(proargnames,1) < array_length(proargtypes,1);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/opr_sanity.sql:    array_length(proallargtypes,1) <> array_length(proargmodes,1);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/opr_sanity.sql:    array_length(proallargtypes,1) <> array_length(proargnames,1);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/opr_sanity.sql:    array_length(proargmodes,1) <> array_length(proargnames,1);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/opr_sanity.sql:        FROM generate_series(1, array_length(proallargtypes, 1)) g(i)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/opr_sanity.sql:    array_dims(p1.proargtypes) != array_dims(p2.proargtypes)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/opr_sanity.sql:WHERE array_lower(indkey, 1) != 0 OR array_upper(indkey, 1) != indnatts-1 OR
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/opr_sanity.sql:    array_lower(indclass, 1) != 0 OR array_upper(indclass, 1) != indnatts-1 OR
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/opr_sanity.sql:    array_lower(indcollation, 1) != 0 OR array_upper(indcollation, 1) != indnatts-1 OR
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/opr_sanity.sql:    array_lower(indoption, 1) != 0 OR array_upper(indoption, 1) != indnatts-1;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/char.sql:-- Now test longer arrays of char
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:CREATE FUNCTION stfp(anyarray) RETURNS anyarray AS
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:CREATE FUNCTION tfp(anyarray,anyelement) RETURNS anyarray AS
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:CREATE FUNCTION tf1p(anyarray,int) RETURNS anyarray AS
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:CREATE FUNCTION ffp(anyarray) RETURNS anyarray AS
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:-- should ERROR: stfnp(anyarray) not matched by stfnp(int[])
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:CREATE AGGREGATE myaggp02a(*) (SFUNC = stfnp, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:CREATE AGGREGATE myaggp04a(*) (SFUNC = stfp, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:CREATE AGGREGATE myaggp04b(*) (SFUNC = stfp, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:-- should ERROR: tf1p(int[],anyelement) not matched by tf1p(anyarray,int)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:-- should ERROR: tfp(int[],anyelement) not matched by tfp(anyarray,anyelement)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:-- should ERROR: tfnp(anyarray, int) not matched by tfnp(int[],int)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:CREATE AGGREGATE myaggp13a(BASETYPE = int, SFUNC = tfnp, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:-- should ERROR: tf2p(anyarray, int) not matched by tf2p(int[],anyelement)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:CREATE AGGREGATE myaggp14a(BASETYPE = int, SFUNC = tf2p, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:-- should ERROR: tfnp(anyarray, anyelement) not matched by tfnp(int[],int)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:  STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:-- should ERROR: tf2p(anyarray, anyelement) not matched by tf2p(int[],anyelement)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:  STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:CREATE AGGREGATE myaggp17a(BASETYPE = int, SFUNC = tf1p, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:CREATE AGGREGATE myaggp17b(BASETYPE = int, SFUNC = tf1p, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:-- should ERROR: tfp(anyarray, int) not matched by tfp(anyarray, anyelement)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:CREATE AGGREGATE myaggp18a(BASETYPE = int, SFUNC = tfp, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:CREATE AGGREGATE myaggp18b(BASETYPE = int, SFUNC = tfp, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:-- should ERROR: tf1p(anyarray, anyelement) not matched by tf1p(anyarray, int)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:  STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:  STYPE = anyarray, INITCOND = '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:  STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:  STYPE = anyarray, INITCOND = '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:-- should ERROR: stfnp(anyarray) not matched by stfnp(int[])
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:CREATE AGGREGATE myaggn02a(*) (SFUNC = stfnp, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:CREATE AGGREGATE myaggn02b(*) (SFUNC = stfnp, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:-- should ERROR: ffnp(anyarray) not matched by ffnp(int[])
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:CREATE AGGREGATE myaggn04a(*) (SFUNC = stfp, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:-- should ERROR: tf1p(int[],anyelement) not matched by tf1p(anyarray,int)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:-- should ERROR: tfp(int[],anyelement) not matched by tfp(anyarray,anyelement)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:-- should ERROR: tfnp(anyarray, int) not matched by tfnp(int[],int)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:CREATE AGGREGATE myaggn13a(BASETYPE = int, SFUNC = tfnp, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:CREATE AGGREGATE myaggn13b(BASETYPE = int, SFUNC = tfnp, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:-- should ERROR: tf2p(anyarray, int) not matched by tf2p(int[],anyelement)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:CREATE AGGREGATE myaggn14a(BASETYPE = int, SFUNC = tf2p, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:CREATE AGGREGATE myaggn14b(BASETYPE = int, SFUNC = tf2p, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:-- should ERROR: tfnp(anyarray, anyelement) not matched by tfnp(int[],int)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:  STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:  STYPE = anyarray, INITCOND = '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:-- should ERROR: tf2p(anyarray, anyelement) not matched by tf2p(int[],anyelement)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:  STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:  STYPE = anyarray, INITCOND = '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:-- should ERROR: ffnp(anyarray) not matched by ffnp(int[])
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:CREATE AGGREGATE myaggn17a(BASETYPE = int, SFUNC = tf1p, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:-- should ERROR: tfp(anyarray, int) not matched by tfp(anyarray, anyelement)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:CREATE AGGREGATE myaggn18a(BASETYPE = int, SFUNC = tfp, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:-- should ERROR: tf1p(anyarray, anyelement) not matched by tf1p(anyarray, int)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:  STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:-- should ERROR: ffnp(anyarray) not matched by ffnp(int[])
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:  STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:insert into t values(1,array[1],'a');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:insert into t values(1,array[11],'b');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:insert into t values(1,array[111],'c');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:insert into t values(2,array[2],'a');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:insert into t values(2,array[22],'b');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:insert into t values(2,array[222],'c');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:insert into t values(3,array[3],'a');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:insert into t values(3,array[3],'b');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:CREATE AGGREGATE array_cat_accum (anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:    sfunc = array_cat,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:    stype = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:SELECT array_cat_accum(i)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:SELECT array_cat_accum(i)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:create function add_group(grp anyarray, ad anyelement, size integer)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:  returns anyarray
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:    return array[ad];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:  if array_upper(grp, 1) < size then
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:  STYPE = anyarray
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:create function first_el(anyarray) returns anyelement as
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:  SFUNC = array_append,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:  SFUNC = array_append,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:  STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:select distinct array_ndims(histogram_bounds) from pg_stats
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:create function myleast(variadic anyarray) returns anyelement as $$
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:select myleast(variadic array[1,2,3,4,-1]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:select myleast(variadic array[1.1, -5.5]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:select myleast(variadic array[]::int[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:create function concat(text, variadic anyarray) returns text as $$
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:  select array_to_string($2, $1);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:select concat('|', variadic array[1,2,33]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:select concat('|', variadic array[]::int[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:drop function concat(text, anyarray);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:create function formarray(anyelement, variadic anyarray) returns anyarray as $$
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:  select array_prepend($1, $2);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:select formarray(1,2,3,4,5);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:select formarray(1.1, variadic array[1.2,55.5]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:select formarray(1.1, array[1.2,55.5]); -- fail without variadic
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:select formarray(1, 'x'::text); -- fail, type mismatch
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:select formarray(1, variadic array['x'::text]); -- fail, type mismatch
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:drop function formarray(anyelement, variadic anyarray);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:select pg_typeof(array[1.2,55.5]); -- numeric[]
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:$$ select array_upper($1, 1) $$ language sql;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:create or replace function dfunc(a variadic int[] default array[]::int[]) returns int as
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:$$ select array_upper($1, 1) $$ language sql;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/polymorphism.sql:$$ select array_upper($1, 1) $$ language sql;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:CREATE INDEX intarrayidx ON array_index_op_test USING gin (i);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE i @> '{17}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE i && '{17}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE i @> '{32,17}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE i && '{32,17}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE i <@ '{38,34,32,89}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE i = '{47,77}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE i = '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE i @> '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE i && '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE i <@ '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_op_test WHERE i = '{NULL}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_op_test WHERE i @> '{NULL}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_op_test WHERE i && '{NULL}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_op_test WHERE i <@ '{NULL}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:CREATE INDEX textarrayidx ON array_index_op_test USING gin (t);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAAAA646}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAAAA646}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE t <@ '{AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE t = '{AAAAAAAAAA646,A87088}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE t = '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE t @> '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE t && '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE t <@ '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:DROP INDEX intarrayidx, textarrayidx;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:CREATE INDEX botharrayidx ON array_index_op_test USING gin (i, t);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAA80240}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE t && '{AAAAAAA80240}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE i @> '{32}' AND t && '{AAAAAAA80240}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE i && '{32}' AND t @> '{AAAAAAA80240}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_index_op_test WHERE t = '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_op_test WHERE i = '{NULL}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT * FROM array_op_test WHERE i <@ '{NULL}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:CREATE TABLE array_gin_test (a int[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:INSERT INTO array_gin_test SELECT ARRAY[1, g%5, g] FROM generate_series(1, 10000) g;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:CREATE INDEX array_gin_test_idx ON array_gin_test USING gin (a);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:SELECT COUNT(*) FROM array_gin_test WHERE a @> '{2}';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:DROP TABLE array_gin_test;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_index.sql:CREATE INDEX gin_relopts_test ON array_index_op_test USING gin (i)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/join.sql:(values (1, array[10,20]), (2, array[20,30])) as v1(v1x,v1ys)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/join.sql:(values (1, array[10,20]), (2, array[20,30])) as v1(v1x,v1ys)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:create function duplic(in i anyelement, out j anyelement, out k anyarray) as $$
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:  k := array[j,j];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:  for i in array_lower($1,1)..array_upper($1,1) loop
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:select vari(variadic array[5,6,7]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:declare aux numeric = $1[array_lower($1,1)];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:  for i in array_lower($1,1)+1..array_upper($1,1) loop
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:  -- just for fun, let's use array elements as targets
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:  arr := array[array['foo','bar'], array['baz', 'quux']];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:-- Test FOREACH over arrays
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:create function foreach_test(anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:  foreach x in array $1
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:create or replace function foreach_test(anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:  foreach x slice 1 in array $1
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:create or replace function foreach_test(anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:  foreach x slice 1 in array $1
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:create or replace function foreach_test(anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:  foreach x slice 2 in array $1
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:-- iteration over array of records
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:create or replace function foreach_test(anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:  foreach r in array $1
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:create or replace function foreach_test(anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:  foreach x, y in array $1
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:-- slicing over array of composite types
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:create or replace function foreach_test(anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:  foreach x slice 1 in array $1
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:drop function foreach_test(anyarray);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:-- Assorted tests for array subscript assignment
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:create function arrayassign1() returns text[] language plpgsql as $$
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:select arrayassign1();
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:select arrayassign1(); -- try again to exercise internal caching
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:create domain orderedarray as int[2]
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:select '{1,2}'::orderedarray;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:select '{2,1}'::orderedarray;  -- fail
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:create function testoa(x1 int, x2 int, x3 int) returns orderedarray
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:declare res orderedarray;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:  res := array[x1, x2];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:drop function arrayassign1();
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:-- Test handling of expanded arrays
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:create function returns_rw_array(int) returns int[]
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:  begin r := array[$1, $1]; return r; end;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:create function consumes_rw_array(int[]) returns int
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:  (select returns_rw_array(1) as a offset 0) ss,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:  lateral consumes_rw_array(a) i;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:  (select returns_rw_array(1) as a offset 0) ss,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:  lateral consumes_rw_array(a) i;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:select consumes_rw_array(a), a from returns_rw_array(1) a;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:select consumes_rw_array(a), a from returns_rw_array(1) a;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:select consumes_rw_array(a), a from
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:  (values (returns_rw_array(1)), (returns_rw_array(2))) v(a);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:select consumes_rw_array(a), a from
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:  (values (returns_rw_array(1)), (returns_rw_array(2))) v(a);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:-- Test handling of expanded array passed to a domain constraint (bug #14472)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:  v_test := array[1];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/plpgsql.sql:declare v_test plpgsql_arr_domain := array[1];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/collate.linux.utf8.sql:SELECT array_agg(b ORDER BY b) FROM collate_test1;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/collate.linux.utf8.sql:SELECT array_agg(b ORDER BY b) FROM collate_test2;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/collate.linux.utf8.sql:SELECT array_agg(b ORDER BY b) FROM collate_test3;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/collate.linux.utf8.sql:SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test1)) ORDER BY 1;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/collate.linux.utf8.sql:SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test2)) ORDER BY 1;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/collate.linux.utf8.sql:SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test3)) ORDER BY 1;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:-- Test domains over array types
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:select array_dims(testint4arr), array_dims(testchar4arr) from domarrtest;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:select array_dims('{1,2,3}'::dia);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:-- Test domains over arrays of composite
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:insert into dcomptable values (array[row(1,2)]::dcomptypea);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:insert into dcomptable values (array[row(3,4), row(5,6)]::comptype[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:insert into dcomptable values (array[row(7,8)::comptype, row(9,10)::comptype]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:insert into dcomptable values (array[row(1,2)]::dcomptypea);  -- fail on uniqueness
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:select array[row(2,1)]::dcomptypea;  -- fail
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:insert into dcomptable values (array[row(1,2)]::comptype[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:insert into dcomptable values (array[row(2,1)]::comptype[]);  -- fail
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:-- Likewise for domains within arrays of composite
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:-- Likewise for domains within domains over array of composite
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:create or replace function array_elem_check(numeric) returns numeric as $$
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:select array_elem_check(121.00);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:select array_elem_check(1.23456);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:create or replace function array_elem_check(numeric) returns numeric as $$
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:select array_elem_check(121.00);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:select array_elem_check(1.23456);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:create or replace function array_elem_check(numeric) returns numeric as $$
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:select array_elem_check(121.00);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:select array_elem_check(1.23456);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:drop function array_elem_check(numeric);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:-- Check enforcement of array-level domain constraints
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:select array[1,2]::orderedpair;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:select array[2,1]::orderedpair;  -- fail
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:insert into op values (array[1,2]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:insert into op values (array[2,1]);  -- fail
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:create or replace function array_elem_check(int) returns int as $$
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:select array_elem_check(3);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:select array_elem_check(-1);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/domain.sql:drop function array_elem_check(int);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/psql.sql:prepare q as select array_to_string(array_agg(repeat('x',2*n)),E'\n') as "ab
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/psql.sql:c", array_to_string(array_agg(repeat('y',20-2*n)),E'\n') as "a
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/xml.sql:SELECT xmlelement(name foo, array[1, 2, 3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/xml.sql:                array_to_string(proargnames,',') as proargnames,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/xml.sql:                case when proargtypes <> '' then array_to_string(proargtypes::oid[],',') end as proargtypes
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/xml.sql:                array_to_string(proargnames,',') as proargnames,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/xml.sql:                case when proargtypes <> '' then array_to_string(proargtypes::oid[],',') end as proargtypes
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_table.sql:CREATE TABLE array_op_test (
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_table.sql:CREATE TABLE array_index_op_test (
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_table.sql:-- list partitioning on array type column
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/subselect.sql:    ( select f1, array(select q1 from int8_tbl) as arr
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/subselect.sql:  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/subselect.sql:  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/subselect.sql:  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/subselect.sql:  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/subselect.sql:  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/subselect.sql:  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:select a,ord from unnest(array['a','b']) with ordinality as z(a,ord);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:select * from unnest(array['a','b']) with ordinality as z(a,ord);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:select a,ord from unnest(array[1.0::float8]) with ordinality as z(a,ord);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:select * from unnest(array[1.0::float8]) with ordinality as z(a,ord);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:select * from unnest(array[10,20],array['foo','bar'],array[1.0]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:select * from unnest(array[10,20],array['foo','bar'],array[1.0]) with ordinality as z(a,b,c,ord);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:select * from rows from(unnest(array[10,20],array['foo','bar'],array[1.0])) with ordinality as z(a,b,c,ord);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:select * from rows from(unnest(array[10,20],array['foo','bar']), generate_series(101,102)) with ordinality as z(a,b,c,ord);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:create temporary view vw_ord as select * from unnest(array[10,20],array['foo','bar'],array[1.0]) as z(a,b,c);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:create temporary view vw_ord as select * from rows from(unnest(array[10,20],array['foo','bar'],array[1.0])) as z(a,b,c);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:create temporary view vw_ord as select * from rows from(unnest(array[10,20],array['foo','bar']), generate_series(1,2)) as z(a,b,c);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN unnest(array[10,20,30]) f(i) ON (r+i)<100;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN unnest(array[10,20,30]) WITH ORDINALITY AS f(i,o) ON (r+i)<100;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:SELECT * FROM (VALUES (1),(2),(3)) v(r), unnest(array[r*10,r*20,r*30]) f(i);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:SELECT * FROM (VALUES (1),(2),(3)) v(r), unnest(array[r*10,r*20,r*30]) WITH ORDINALITY AS f(i,o);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:CREATE FUNCTION dup (f1 anyelement, f2 out anyelement, f3 out anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:AS 'select $1, array[$1,$1]' LANGUAGE sql;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:CREATE OR REPLACE FUNCTION dup (inout f2 anyelement, out f3 anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:AS 'select $1, array[$1,$1]' LANGUAGE sql;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:CREATE OR REPLACE FUNCTION dup (inout f2 anyelement, out f3 anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:AS 'select $1, array[$1,$1]' LANGUAGE sql;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:CREATE FUNCTION bad (f1 int, out f2 anyelement, out f3 anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:AS 'select $1, array[$1,$1]' LANGUAGE sql;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:create function array_to_set(anyarray) returns setof record as $$
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:select array_to_set(array['one', 'two']);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:select * from array_to_set(array['one', 'two']) as t(f1 int,f2 text);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:select * from array_to_set(array['one', 'two']); -- fail
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:select *, row_to_json(u) from unnest(array[(1,'foo')::foo2, null::foo2]) u;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:select *, row_to_json(u) from unnest(array[null::foo2, null::foo2]) u;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:select *, row_to_json(u) from unnest(array[null::foo2, (1,'foo')::foo2, null::foo2]) u;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangefuncs.sql:select *, row_to_json(u) from unnest(array[]::foo2[]) u;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/case.sql:     x := array[$1,$2];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/case.sql:  'begin return array_eq($1, $2); end' language plpgsql;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/case.sql:  WHEN array[2,4]::arrdomain THEN 'wrong'
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/case.sql:  WHEN array[2,5]::arrdomain THEN 'still wrong'
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/case.sql:  WHEN array[1,2]::arrdomain THEN 'right'
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/regex.sql:-- Test some cases that crashed in 9.2beta1 due to pmatch[] array overrun
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/updatable_views.sql:-- multiple array-column updates
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/updatable_views.sql:-- WITH CHECK OPTION with scalar array ops
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/groupingsets.sql:       array_agg(v order by v),
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/groupingsets.sql:select grouping(a), a, array_agg(b),
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/groupingsets.sql:select array(select row(v.a,s1.*) from (select two,four, count(*) from onek group by cube(two,four) order by two,four) s1) from (values (1),(2)) v(a);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/groupingsets.sql:select array_agg(v order by v) from gstest4 group by grouping sets ((id,unsortable_col),(id));
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/groupingsets.sql:  select a, b, grouping(a,b), array_agg(v order by v)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/groupingsets.sql:select array(select row(v.a,s1.*) from (select two,four, count(*) from onek group by cube(two,four) order by two,four) s1) from (values (1),(2)) v(a);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/groupingsets.sql:select array(select row(v.a,s1.*) from (select two,four, count(*) from onek group by grouping sets(two,four) order by two,four) s1) from (values (1),(2)) v(a);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/collate.sql:SELECT array_agg(b ORDER BY b) FROM collate_test1;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/collate.sql:SELECT array_agg(b ORDER BY b) FROM collate_test2;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/collate.sql:SELECT array_agg(x COLLATE "C" ORDER BY y COLLATE "POSIX") FROM collate_test10;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/collate.sql:SELECT array_agg(a ORDER BY x COLLATE "C", y COLLATE "POSIX") FROM collate_test10;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/collate.sql:SELECT array_agg(a ORDER BY x||y) FROM collate_test10;  -- fail
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/collate.sql:SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test1)) ORDER BY 1;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/collate.sql:SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test2)) ORDER BY 1;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/insert.sql:-- check indirection (field/array assignment), cf bug #14265
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/insert.sql:insert into inserttest (f3.if1, f3.if2) values (1,array['foo']);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_type.sql:CREATE TYPE not_existing_type (INPUT = array_in,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_type.sql:    OUTPUT = array_out,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_aggregate.sql:as 'select array_append($1,ROW($2,$3,$4)::aggtype)'
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_aggregate.sql:as 'select array_append($1,ROW($2,$3,$4)::aggtype)'
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_aggregate.sql:create function least_accum(anyelement, variadic anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/create_aggregate.sql:create aggregate least_agg(variadic items anyarray) (
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangetypes.sql:create function anyarray_anyrange_func(a anyarray, r anyrange)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangetypes.sql:select anyarray_anyrange_func(ARRAY[1,2], int4range(10,20));
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangetypes.sql:select anyarray_anyrange_func(ARRAY[1,2], numrange(10,20));
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangetypes.sql:drop function anyarray_anyrange_func(anyarray, anyrange);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangetypes.sql:create function rangetypes_sql(q anyrange, b anyarray, out c anyelement)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangetypes.sql:create table i8r_array (f1 int, f2 int8range[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangetypes.sql:insert into i8r_array values (42, array[int8range(1,10), int8range(2,20)]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangetypes.sql:select * from i8r_array;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangetypes.sql:drop table i8r_array;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangetypes.sql:-- Ranges of arrays
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangetypes.sql:create type arrayrange as range (subtype=int4[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangetypes.sql:select arrayrange(ARRAY[1,2], ARRAY[2,1]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangetypes.sql:select arrayrange(ARRAY[2,1], ARRAY[1,2]);  -- fail
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangetypes.sql:select array[1,1] <@ arrayrange(array[1,2], array[2,1]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/rangetypes.sql:select array[1,3] <@ arrayrange(array[1,2], array[2,1]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT array_to_json(ARRAY [jsonb '{"a":1}', jsonb '{"b":[2,3]}']);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:-- anyarray column
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:('array','["zero", "one","two",null,"four","five", [1,2,3],{"f1":9}]'),
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT test_json -> 'x' FROM test_jsonb WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT test_json ->> 'field2' FROM test_jsonb WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT test_json -> 2 FROM test_jsonb WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT test_json -> 9 FROM test_jsonb WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT test_json ->> 6 FROM test_jsonb WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT test_json ->> 7 FROM test_jsonb WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT test_json ->> 2 FROM test_jsonb WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT (test_json->3) IS NULL AS expect_false FROM test_jsonb WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT (test_json->>3) IS NULL AS expect_true FROM test_jsonb WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:-- Raw scalar may contain another raw scalar, array may contain a raw scalar
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:-- But a raw scalar cannot contain an array
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:-- In general, one thing should always contain itself. Test array containment:
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:-- array containment string matching confusion bug
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:-- array length
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT jsonb_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT jsonb_array_length('[]');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT jsonb_array_length('{"f1":1,"f2":[5,6]}');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT jsonb_array_length('4');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:-- array exists - array elements should behave as keys
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT count(*) from testjsonb  WHERE j->'array' ? 'bar';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:-- type sensitive array exists - should return no rows (since "exists" only
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:-- matches strings that are either object keys or array elements)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT count(*) from testjsonb  WHERE j->'array' ? '5'::text;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:-- However, a raw scalar is *contained* within the array
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT count(*) from testjsonb  WHERE j->'array' @> '5'::jsonb;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT jsonb_typeof('[]') AS array;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT jsonb_typeof('["a", 1]') AS array;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:-- jsonb_build_array, jsonb_build_object, jsonb_object_agg
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT jsonb_build_array('a',1,'b',1.2,'c',true,'d',null,'e',json '{"x": 3, "y": [1,2,3]}');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT jsonb_build_array('a', NULL); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT jsonb_build_array(VARIADIC NULL::text[]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT jsonb_build_array(VARIADIC '{}'::text[]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT jsonb_build_array(VARIADIC '{a,b,c}'::text[]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT jsonb_build_array(VARIADIC ARRAY['a', NULL]::text[]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT jsonb_build_array(VARIADIC '{1,2,3,4}'::text[]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT jsonb_build_array(VARIADIC '{1,2,3,4}'::int[]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT jsonb_build_array(VARIADIC '{{1,4},{2,5},{3,6}}'::int[][]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:       'd', jsonb_build_object('e',array[9,8,7]::int[],
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT jsonb_build_object('{a,b,c}'::text[], '{d,e,f}'::text[]); -- error, key cannot be array
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:-- empty objects/arrays
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT jsonb_build_array();
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f4','f6'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2','0'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2','1'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f4','f6'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2','0'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2','1'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a', null];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a', ''];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b','c'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b','c','d'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','z','c'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #> array['a','1','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #> array['a','z','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '[{"b": "c"}, {"b": "cc"}]'::jsonb #> array['1','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '[{"b": "c"}, {"b": "cc"}]'::jsonb #> array['z','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '[{"b": "c"}, {"b": null}]'::jsonb #> array['1','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '"foo"'::jsonb #> array['z'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '42'::jsonb #> array['f2'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '42'::jsonb #> array['0'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a', null];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a', ''];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b','c'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b','c','d'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','z','c'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #>> array['a','1','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #>> array['a','z','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '[{"b": "c"}, {"b": "cc"}]'::jsonb #>> array['1','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '[{"b": "c"}, {"b": "cc"}]'::jsonb #>> array['z','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '[{"b": "c"}, {"b": null}]'::jsonb #>> array['1','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '"foo"'::jsonb #>> array['z'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '42'::jsonb #>> array['f2'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '42'::jsonb #>> array['0'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:-- array_elements
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT jsonb_array_elements('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false]');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT * FROM jsonb_array_elements('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false]') q;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT jsonb_array_elements_text('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT * FROM jsonb_array_elements_text('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]') q;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:CREATE DOMAIN jsb_int_array_1d  AS int[]   CHECK(array_length(VALUE, 1) = 3);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:CREATE DOMAIN jsb_int_array_2d  AS int[][] CHECK(array_length(VALUE, 2) = 3);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:	ia1d	jsb_int_array_1d,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:	ia2d	jsb_int_array_2d,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:DROP DOMAIN jsb_int_array_1d;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:DROP DOMAIN jsb_int_array_2d;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT count(*) FROM testjsonb WHERE j @> '{"array":["foo"]}';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT count(*) FROM testjsonb WHERE j @> '{"array":["bar"]}';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:-- array exists - array elements should behave as keys (for GIN index scans too)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:CREATE INDEX jidx_array ON testjsonb USING gin((j->'array'));
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT count(*) from testjsonb  WHERE j->'array' ? 'bar';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:-- type sensitive array exists - should return no rows (since "exists" only
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:-- matches strings that are either object keys or array elements)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT count(*) from testjsonb  WHERE j->'array' ? '5'::text;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:-- However, a raw scalar is *contained* within the array
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:SELECT count(*) from testjsonb  WHERE j->'array' @> '5'::jsonb;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:DROP INDEX jidx_array;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:-- nested object field / array index lookup
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:select '{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb #- '{b,-1e}'; -- invalid array subscript
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:-- prepend to array
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:-- append to array
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/jsonb.sql:--add to empty array
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/varchar.sql:-- Now test longer arrays of char
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/amutils.sql:       unnest(array['asc', 'desc', 'nulls_first', 'nulls_last',
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/amutils.sql:                    'search_array', 'search_nulls',
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/amutils.sql:       unnest(array['asc', 'desc', 'nulls_first', 'nulls_last',
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/amutils.sql:                    'search_array', 'search_nulls',
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/amutils.sql:       pg_index_column_has_property('botharrayidx'::regclass, 1, prop) as gin,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/amutils.sql:  from unnest(array['asc', 'desc', 'nulls_first', 'nulls_last',
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/amutils.sql:                    'search_array', 'search_nulls',
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/amutils.sql:       pg_index_has_property('botharrayidx'::regclass, prop) as gin,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/amutils.sql:  from unnest(array['clusterable', 'index_scan', 'bitmap_scan',
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/amutils.sql:       unnest(array['can_order', 'can_unique', 'can_multi_col',
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/type_sanity.sql:-- Look for types that should have an array type according to their typtype,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/type_sanity.sql:-- make array types corresponding to the system catalogs' rowtypes.
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/type_sanity.sql:           p2.typelem = p1.oid and p1.typarray = p2.oid);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/type_sanity.sql:-- Make sure typarray points to a varlena array type of our own base
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/type_sanity.sql:SELECT p1.oid, p1.typname as basetype, p2.typname as arraytype,
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/type_sanity.sql:FROM   pg_type p1 LEFT JOIN pg_type p2 ON (p1.typarray = p2.oid)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/type_sanity.sql:WHERE  p1.typarray <> 0 AND
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/type_sanity.sql:-- Varlena array types will point to array_in
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/type_sanity.sql:    (p2.oid = 'array_in'::regproc)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/type_sanity.sql:      (p2.oid = 'array_out'::regproc AND
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/type_sanity.sql:-- Varlena array types will point to array_recv
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/type_sanity.sql:    (p2.oid = 'array_recv'::regproc)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/type_sanity.sql:      (p2.oid = 'array_send'::regproc AND
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/type_sanity.sql:WHERE p1.typarray = p2.oid AND NOT (p1.typdelim = p2.typdelim);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/type_sanity.sql:-- Look for array types whose typalign isn't sufficient
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/type_sanity.sql:WHERE p1.typarray = p2.oid AND
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/type_sanity.sql:-- array_typanalyze should be used for all and only array types
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/type_sanity.sql:    (t.typanalyze = 'array_typanalyze'::regproc) !=
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/type_sanity.sql:-- We must allow anyarray matches, cf opr_sanity's binary_coercible()
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/type_sanity.sql:     (o.opcintype = 'pg_catalog.anyarray'::regtype AND
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:-- only the 'e' array is 0-based, the others are 1-based.
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT array_ndims(a) AS a,array_ndims(b) AS b,array_ndims(c) AS c
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT array_dims(a) AS a,array_dims(b) AS b,array_dims(c) AS c
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:  WHERE array_dims(b) = '[1:1][1:2][1:2]';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:  WHERE array_dims(c) is not null;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:  WHERE array_dims(c) is not null;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:  WHERE array_dims(c) is not null;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:  WHERE array_dims(c) is not null;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:  WHERE array_lower(a,1) = 1;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:-- check with fixed-length-array type, such as point
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:-- test array extension
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:insert into arrtest1 values(array[1,2,null,4], array['one','two',null,'four']);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:update arrtest1 set i[0:2] = array[10,11,12], t[0:2] = array['ten','eleven','twelve'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:update arrtest1 set i[8:10] = array[18,null,20], t[8:10] = array['p18',null,'p20'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:update arrtest1 set i[11:12] = array[null,22], t[11:12] = array[null,'p22'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:update arrtest1 set i[15:16] = array[null,26], t[15:16] = array[null,'p26'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:update arrtest1 set i[-5:-3] = array[-15,-14,-13], t[-5:-3] = array['m15','m14','m13'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:update arrtest1 set i[-7:-6] = array[-17,null], t[-7:-6] = array['m17',null];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:update arrtest1 set i[-12:-10] = array[-22,null,-20], t[-12:-10] = array['m22',null,'m20'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:insert into arrtest1 values(array[1,2,null,4], array['one','two',null,'four']);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:update arrtest1 set i[0:5] = array[0,1,2,null,4,5], t[0:5] = array['z','p1','p2',null,'p4','p5'];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:-- array expressions and operators
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT array_append(array[42], 6) AS "{42,6}";
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT array_prepend(6, array[42]) AS "{6,42}";
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT array_cat(ARRAY[1,2], ARRAY[3,4]) AS "{1,2,3,4}";
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT array_cat(ARRAY[1,2], ARRAY[[3,4],[5,6]]) AS "{{1,2},{3,4},{5,6}}";
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT array_cat(ARRAY[[3,4],[5,6]], ARRAY[1,2]) AS "{{3,4},{5,6},{1,2}}";
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT array_position(ARRAY[1,2,3,4,5], 4);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT array_position(ARRAY[5,3,4,2,1], 4);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT array_position(ARRAY[[1,2],[3,4]], 3);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'mon');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'sat');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], NULL);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT array_position(ARRAY['sun','mon','tue','wed','thu',NULL,'fri','sat'], NULL);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT array_position(ARRAY['sun','mon','tue','wed','thu',NULL,'fri','sat'], 'sat');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT array_positions(NULL, 10);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT array_positions(NULL, NULL::int);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT array_positions(ARRAY[1,2,3,4,5,6,1,2,3,4,5,6], 4);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT array_positions(ARRAY[[1,2],[3,4]], 4);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT array_positions(ARRAY[1,2,3,4,5,6,1,2,3,4,5,6], NULL);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT array_positions(ARRAY[1,2,3,NULL,5,6,1,2,3,NULL,5,6], NULL);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT array_length(array_positions(ARRAY(SELECT 'AAAAAAAAAAAAAAAAAAAAAAAAA'::text || i % 10
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:  o := array_position(a, 2);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:    o := array_position(a, 2, o + 1);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT array_position('[2:4]={1,2,3}'::int[], 1);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT array_positions('[2:4]={1,2,3}'::int[], 1);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:    array_position(ids, (1, 1)),
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:    array_positions(ids, (1, 1))
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE i @> '{32}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE i && '{32}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE i @> '{17}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE i && '{17}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE i @> '{32,17}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE i && '{32,17}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE i <@ '{38,34,32,89}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE i = '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE i @> '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE i && '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE i <@ '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE i = '{NULL}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE i @> '{NULL}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE i && '{NULL}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE i <@ '{NULL}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE t && '{AAAAAAAA72908}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE t @> '{AAAAAAAAAA646}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE t && '{AAAAAAAAAA646}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE t @> '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE t && '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE t <@ '{AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE t = '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE t @> '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE t && '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:SELECT * FROM array_op_test WHERE t <@ '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:-- array casts
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:-- scalar op any/all (array)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select 33.4 = any (array[1,2,3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select 33.4 > all (array[1,2,3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:-- test indexes on arrays
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:-- test ON CONFLICT DO UPDATE with arrays
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select 'foo' like any (array['%a', '%o']); -- t
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select 'foo' like any (array['%a', '%b']); -- f
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select 'foo' like all (array['f%', '%o']); -- t
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select 'foo' like all (array['f%', '%b']); -- f
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select 'foo' not like any (array['%a', '%b']); -- t
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select 'foo' not like all (array['%a', '%o']); -- f
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select 'foo' ilike any (array['%A', '%O']); -- t
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select 'foo' ilike all (array['F%', '%O']); -- t
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:-- General array parser tests
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array[];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array[]::text[];
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:-- tests for array aggregates
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:-- A few simple tests for arrays of composite types
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:  values (row(1,'foo'), array[row(2,'bar')::comptype, row(3,'baz')::comptype]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:-- check that implicitly named array type _comptype isn't a problem
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:create or replace function unnest1(anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:create or replace function unnest2(anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select * from unnest1(array[1,2,3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select * from unnest2(array[[1,2,3],[4,5,6]]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:drop function unnest1(anyarray);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:drop function unnest2(anyarray);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_fill(null::integer, array[3,3],array[2,2]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_fill(null::integer, array[3,3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_fill(null::text, array[3,3],array[2,2]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_fill(null::text, array[3,3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_fill(7, array[3,3],array[2,2]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_fill(7, array[3,3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_fill('juhu'::text, array[3,3],array[2,2]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_fill('juhu'::text, array[3,3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select a, a = '{}' as is_eq, array_dims(a)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:  from (select array_fill(42, array[0]) as a) ss;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select a, a = '{}' as is_eq, array_dims(a)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:  from (select array_fill(42, '{}') as a) ss;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select a, a = '{}' as is_eq, array_dims(a)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:  from (select array_fill(42, '{}', '{}') as a) ss;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_fill(1, null, array[2,2]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_fill(1, array[2,2], null);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_fill(1, array[2,2], '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_fill(1, array[3,3], array[1,1,1]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_fill(1, array[1,2,null]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_fill(1, array[[1,2],[3,4]]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select string_to_array('1|2|3', '|');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select string_to_array('1|2|3|', '|');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select string_to_array('1||2|3||', '||');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select string_to_array('1|2|3', '');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select string_to_array('', '|');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select string_to_array('1|2|3', NULL);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select string_to_array(NULL, '|') IS NULL;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select string_to_array('abc', '');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select string_to_array('abc', '', 'abc');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select string_to_array('abc', ',');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select string_to_array('abc', ',', 'abc');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select string_to_array('1,2,3,4,,6', ',');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select string_to_array('1,2,3,4,,6', ',', '');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select string_to_array('1,2,3,4,*,6', ',', '*');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_to_string(NULL::int4[], ',') IS NULL;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_to_string('{}'::int4[], ',');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_to_string(array[1,2,3,4,NULL,6], ',');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_to_string(array[1,2,3,4,NULL,6], ',', '*');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_to_string(array[1,2,3,4,NULL,6], NULL);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_to_string(array[1,2,3,4,NULL,6], ',', NULL);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_to_string(string_to_array('1|2|3', '|'), '|');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_length(array[1,2,3], 1);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_length(array[[1,2,3], [4,5,6]], 0);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_length(array[[1,2,3], [4,5,6]], 1);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_length(array[[1,2,3], [4,5,6]], 2);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_length(array[[1,2,3], [4,5,6]], 3);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select cardinality(array[1,2,3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:-- array_agg(anynonarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_agg(unique1) from (select unique1 from tenk1 where unique1 < 15 order by unique1) ss;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_agg(ten) from (select ten from tenk1 where unique1 < 15 order by unique1) ss;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_agg(nullif(ten, 4)) from (select ten from tenk1 where unique1 < 15 order by unique1) ss;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_agg(unique1) from tenk1 where unique1 < -15;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:-- array_agg(anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_agg(ar)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_agg(distinct ar order by ar desc)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:  from (select array[i / 2] from generate_series(1,10) a(i)) b(ar);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_agg(ar)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:  from (select array_agg(array[i, i+1, i-1])
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_agg(array[i+1.2, i+1.3, i+1.4]) from generate_series(1,3) g(i);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_agg(array['Hello', i::text]) from generate_series(9,11) g(i);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_agg(array[i, nullif(i, 3), i+1]) from generate_series(1,4) g(i);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_agg('{}'::int[]) from generate_series(1,2);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_agg(null::int[]) from generate_series(1,2);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_agg(ar)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select unnest(array[1,2,3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select * from unnest(array[1,2,3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select unnest(array[1,2,3,4.5]::float8[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select unnest(array[1,2,3,4.5]::numeric[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select unnest(array[1,2,3,null,4,null,null,5,6]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select unnest(array[1,2,3,null,4,null,null,5,6]::text[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select abs(unnest(array[1,2,null,-3]));
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_remove(array[1,2,2,3], 2);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_remove(array[1,2,2,3], 5);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_remove(array[1,NULL,NULL,3], NULL);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_remove(array['A','CC','D','C','RR'], 'RR');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_remove('{{1,2,2},{1,4,3}}', 2); -- not allowed
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_remove(array['X','X','X'], 'X') = '{}';
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_replace(array[1,2,5,4],5,3);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_replace(array[1,2,5,4],5,NULL);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_replace(array[1,2,NULL,4,NULL],NULL,5);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_replace(array['A','B','DD','B'],'B','CC');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_replace(array[1,NULL,3],NULL,NULL);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array_replace(array['AB',NULL,'CDE'],NULL,'12');
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:-- array(select array-value ...)
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array(select array[i,i/2] from generate_series(1,5) i);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:select array(select array['Hello', i::text] from generate_series(9,11) i);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:-- Insert/update on a column that is array of composite
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:-- Check that arrays of composites are safely detoasted when needed
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:insert into dest select array[row(f1,f1)::textandtext] from src;
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:-- Tests for polymorphic-array form of width_bucket()
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/arrays.sql:                    array['yesterday', 'today', 'tomorrow']::timestamptz[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/oidjoins.sql:SELECT	ctid, typarray
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/oidjoins.sql:WHERE	typarray != 0 AND
/srvr/z5089358/postgresql-10.4/src/test/regress/sql/oidjoins.sql:	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.typarray);
Binary file /srvr/z5089358/postgresql-10.4/src/test/regress/pg_regress matches
/srvr/z5089358/postgresql-10.4/src/test/regress/output/copy.source:COPY array_op_test FROM '@abs_srcdir@/data/array.data';
/srvr/z5089358/postgresql-10.4/src/test/regress/output/copy.source:COPY array_index_op_test FROM '@abs_srcdir@/data/array.data';
/srvr/z5089358/postgresql-10.4/src/test/regress/output/copy.source:ANALYZE array_op_test;
/srvr/z5089358/postgresql-10.4/src/test/regress/output/copy.source:ANALYZE array_index_op_test;
/srvr/z5089358/postgresql-10.4/src/test/regress/input/copy.source:COPY array_op_test FROM '@abs_srcdir@/data/array.data';
/srvr/z5089358/postgresql-10.4/src/test/regress/input/copy.source:COPY array_index_op_test FROM '@abs_srcdir@/data/array.data';
/srvr/z5089358/postgresql-10.4/src/test/regress/input/copy.source:ANALYZE array_op_test;
/srvr/z5089358/postgresql-10.4/src/test/regress/input/copy.source:ANALYZE array_index_op_test;
/srvr/z5089358/postgresql-10.4/src/test/regress/pg_regress.c: * Note: it's OK to scribble on the pids array, but not on the names array
/srvr/z5089358/postgresql-10.4/src/test/regress/pg_regress.c:		/* compact the active_pids array */
/srvr/z5089358/postgresql-10.4/src/test/regress/data/jsonb.data:{"array":[5]}
/srvr/z5089358/postgresql-10.4/src/test/regress/data/jsonb.data:{"array":["foo", "bar", "baz"]}
/srvr/z5089358/postgresql-10.4/src/test/regress/data/jsonb.data:{"array":["bar", "baz", "foo"]}
/srvr/z5089358/postgresql-10.4/src/test/regress/data/jsonb.data:{"array":["bar", "baz"]}
/srvr/z5089358/postgresql-10.4/src/test/regress/data/jsonb.data:{"array":["baz", "foo"]}
/srvr/z5089358/postgresql-10.4/src/test/regress/serial_schedule:test: arrays
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/gin.out:insert into gin_test_tbl select array[1, 2, g] from generate_series(1, 20000) g;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/gin.out:insert into gin_test_tbl select array[1, 3, g] from generate_series(1, 1000) g;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/gin.out:insert into gin_test_tbl select array[3, 1, g] from generate_series(1, 1000) g;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/gin.out:delete from gin_test_tbl where i @> array[2];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/gin.out:insert into gin_test_tbl select array[1, 2, g] from generate_series(1, 1000) g;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/gin.out:insert into gin_test_tbl select array[1, 3, g] from generate_series(1, 1000) g;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/gin.out:delete from gin_test_tbl where i @> array[2];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:select a,ord from unnest(array['a','b']) with ordinality as z(a,ord);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:select * from unnest(array['a','b']) with ordinality as z(a,ord);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:select a,ord from unnest(array[1.0::float8]) with ordinality as z(a,ord);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:select * from unnest(array[1.0::float8]) with ordinality as z(a,ord);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:select * from unnest(array[10,20],array['foo','bar'],array[1.0]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:select * from unnest(array[10,20],array['foo','bar'],array[1.0]) with ordinality as z(a,b,c,ord);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:select * from rows from(unnest(array[10,20],array['foo','bar'],array[1.0])) with ordinality as z(a,b,c,ord);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:select * from rows from(unnest(array[10,20],array['foo','bar']), generate_series(101,102)) with ordinality as z(a,b,c,ord);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:create temporary view vw_ord as select * from unnest(array[10,20],array['foo','bar'],array[1.0]) as z(a,b,c);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:create temporary view vw_ord as select * from rows from(unnest(array[10,20],array['foo','bar'],array[1.0])) as z(a,b,c);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:create temporary view vw_ord as select * from rows from(unnest(array[10,20],array['foo','bar']), generate_series(1,2)) as z(a,b,c);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN unnest(array[10,20,30]) f(i) ON (r+i)<100;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:SELECT * FROM (VALUES (1),(2),(3)) v(r) LEFT JOIN unnest(array[10,20,30]) WITH ORDINALITY AS f(i,o) ON (r+i)<100;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:SELECT * FROM (VALUES (1),(2),(3)) v(r), unnest(array[r*10,r*20,r*30]) f(i);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:SELECT * FROM (VALUES (1),(2),(3)) v(r), unnest(array[r*10,r*20,r*30]) WITH ORDINALITY AS f(i,o);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:CREATE FUNCTION dup (f1 anyelement, f2 out anyelement, f3 out anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:AS 'select $1, array[$1,$1]' LANGUAGE sql;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:CREATE OR REPLACE FUNCTION dup (inout f2 anyelement, out f3 anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:AS 'select $1, array[$1,$1]' LANGUAGE sql;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:CREATE OR REPLACE FUNCTION dup (inout f2 anyelement, out f3 anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:AS 'select $1, array[$1,$1]' LANGUAGE sql;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:CREATE FUNCTION bad (f1 int, out f2 anyelement, out f3 anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:AS 'select $1, array[$1,$1]' LANGUAGE sql;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:create function array_to_set(anyarray) returns setof record as $$
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:select array_to_set(array['one', 'two']);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out: array_to_set 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:select * from array_to_set(array['one', 'two']) as t(f1 int,f2 text);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:select * from array_to_set(array['one', 'two']); -- fail
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:LINE 1: select * from array_to_set(array['one', 'two']);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:select *, row_to_json(u) from unnest(array[(1,'foo')::foo2, null::foo2]) u;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:select *, row_to_json(u) from unnest(array[null::foo2, null::foo2]) u;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:select *, row_to_json(u) from unnest(array[null::foo2, (1,'foo')::foo2, null::foo2]) u;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangefuncs.out:select *, row_to_json(u) from unnest(array[]::foo2[]) u;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/groupingsets.out:       array_agg(v order by v),
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/groupingsets.out: a | b | grouping |            array_agg            |          string_agg           | percentile_disc | rank 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/groupingsets.out:select grouping(a), a, array_agg(b),
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/groupingsets.out: grouping | a |  array_agg  | rank | rank 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/groupingsets.out:select array(select row(v.a,s1.*) from (select two,four, count(*) from onek group by cube(two,four) order by two,four) s1) from (values (1),(2)) v(a);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/groupingsets.out:                                                                        array                                                                         
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/groupingsets.out:select array_agg(v order by v) from gstest4 group by grouping sets ((id,unsortable_col),(id));
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/groupingsets.out:  select a, b, grouping(a,b), array_agg(v order by v)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/groupingsets.out:select array(select row(v.a,s1.*) from (select two,four, count(*) from onek group by cube(two,four) order by two,four) s1) from (values (1),(2)) v(a);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/groupingsets.out:                                                                        array                                                                         
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/groupingsets.out:select array(select row(v.a,s1.*) from (select two,four, count(*) from onek group by grouping sets(two,four) order by two,four) s1) from (values (1),(2)) v(a);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/groupingsets.out:                                      array                                      
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/xml_1.out:SELECT xmlelement(name foo, array[1, 2, 3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/xml_1.out:                array_to_string(proargnames,',') as proargnames,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/xml_1.out:                case when proargtypes <> '' then array_to_string(proargtypes::oid[],',') end as proargtypes
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/xml_1.out:                array_to_string(proargnames,',') as proargnames,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/xml_1.out:                case when proargtypes <> '' then array_to_string(proargtypes::oid[],',') end as proargtypes
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/char_2.out:-- Now test longer arrays of char
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/case.out:     x := array[$1,$2];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/case.out:  'begin return array_eq($1, $2); end' language plpgsql;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/case.out:  WHEN array[2,4]::arrdomain THEN 'wrong'
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/case.out:  WHEN array[2,5]::arrdomain THEN 'still wrong'
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/case.out:  WHEN array[1,2]::arrdomain THEN 'right'
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_type.out:CREATE TYPE not_existing_type (INPUT = array_in,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_type.out:    OUTPUT = array_out,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_type.out:ERROR:  function array_out(not_existing_type) does not exist
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.out:SELECT array_agg(b ORDER BY b) FROM collate_test1;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.out:     array_agg     
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.out:SELECT array_agg(b ORDER BY b) FROM collate_test2;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.out:     array_agg     
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.out:SELECT array_agg(x COLLATE "C" ORDER BY y COLLATE "POSIX") FROM collate_test10;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.out: array_agg 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.out:SELECT array_agg(a ORDER BY x COLLATE "C", y COLLATE "POSIX") FROM collate_test10;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.out: array_agg 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.out:SELECT array_agg(a ORDER BY x||y) FROM collate_test10;  -- fail
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.out:LINE 1: SELECT array_agg(a ORDER BY x||y) FROM collate_test10;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.out:SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test1)) ORDER BY 1;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.out:SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test2)) ORDER BY 1;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rowsecurity.out:SELECT (string_to_array(polqual, ':'))[7] AS inputcollid FROM pg_policy WHERE polrelid = 'coll_t'::regclass;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:-- array_to_json
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:SELECT array_to_json(array(select 1 as a));
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out: array_to_json 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:SELECT array_to_json(array_agg(q),false) from (select x as b, x * 2 as c from generate_series(1,3) x) q;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:                array_to_json                
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:SELECT array_to_json(array_agg(q),true) from (select x as b, x * 2 as c from generate_series(1,3) x) q;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:  array_to_json  
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:SELECT array_to_json(array_agg(q),false)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:                                                                                                                                 array_to_json                                                                                                                                 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:SELECT array_to_json(array_agg(x),false) from generate_series(5,10) x;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out: array_to_json  
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:SELECT array_to_json('{{1,5},{99,100}}'::int[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:  array_to_json   
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:SELECT row_to_json(row((select array_agg(x) as d from generate_series(5,10) x)),false);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:-- anyarray column
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:('array','["zero", "one","two",null,"four","five", [1,2,3],{"f1":9}]'),
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:SELECT test_json ->> 6 FROM test_json WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:SELECT test_json ->> 7 FROM test_json WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  cannot call json_object_keys on an array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:    (select json_object_keys(json_object(array_agg(g)))
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:     from (select unnest(array['f'||n,n::text])as g
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:where json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:where json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:-- array length
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:SELECT json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out: json_array_length 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:SELECT json_array_length('[]');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out: json_array_length 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:SELECT json_array_length('{"f1":1,"f2":[5,6]}');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  cannot get array length of a non-array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:SELECT json_array_length('4');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  cannot get array length of a scalar
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::json#>array['f4','f6'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::json#>array['f2'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::json#>array['f2','0'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::json#>array['f2','1'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::json#>>array['f4','f6'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::json#>>array['f2'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::json#>>array['f2','0'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::json#>>array['f2','1'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"a": {"b":{"c": "foo"}}}'::json #> array['a'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"a": {"b":{"c": "foo"}}}'::json #> array['a', null];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"a": {"b":{"c": "foo"}}}'::json #> array['a', ''];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"a": {"b":{"c": "foo"}}}'::json #> array['a','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"a": {"b":{"c": "foo"}}}'::json #> array['a','b','c'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"a": {"b":{"c": "foo"}}}'::json #> array['a','b','c','d'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"a": {"b":{"c": "foo"}}}'::json #> array['a','z','c'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json #> array['a','1','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json #> array['a','z','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '[{"b": "c"}, {"b": "cc"}]'::json #> array['1','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '[{"b": "c"}, {"b": "cc"}]'::json #> array['z','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '[{"b": "c"}, {"b": null}]'::json #> array['1','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '"foo"'::json #> array['z'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '42'::json #> array['f2'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '42'::json #> array['0'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a', null];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a', ''];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a','b','c'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a','b','c','d'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"a": {"b":{"c": "foo"}}}'::json #>> array['a','z','c'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json #>> array['a','1','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '{"a": [{"b": "c"}, {"b": "cc"}]}'::json #>> array['a','z','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '[{"b": "c"}, {"b": "cc"}]'::json #>> array['1','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '[{"b": "c"}, {"b": "cc"}]'::json #>> array['z','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '[{"b": "c"}, {"b": null}]'::json #>> array['1','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '"foo"'::json #>> array['z'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '42'::json #>> array['f2'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select '42'::json #>> array['0'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:-- array_elements
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select json_array_elements('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:  json_array_elements  
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select * from json_array_elements('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]') q;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select json_array_elements_text('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out: json_array_elements_text 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:select * from json_array_elements_text('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]') q;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:CREATE DOMAIN js_int_array_1d  AS int[]   CHECK(array_length(VALUE, 1) = 3);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:CREATE DOMAIN js_int_array_2d  AS int[][] CHECK(array_length(VALUE, 2) = 3);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:	ia1d	js_int_array_1d,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:	ia2d	js_int_array_2d,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:HINT:  See the array element [1] of key "ia".
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  malformed json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:DETAIL:  Multidimensional arrays must have sub-arrays with matching dimensions.
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  value for domain js_int_array_1d violates check constraint "js_int_array_1d_check"
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  malformed json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:DETAIL:  Multidimensional arrays must have sub-arrays with matching dimensions.
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:HINT:  See the array element [1] of key "ia2".
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  value for domain js_int_array_2d violates check constraint "js_int_array_2d_check"
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  malformed json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:DETAIL:  Multidimensional arrays must have sub-arrays with matching dimensions.
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:HINT:  See the array element [1] of key "ta".
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:HINT:  See the array element [1] of key "ca".
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  cannot call populate_composite on an array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:DROP DOMAIN js_int_array_1d;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:DROP DOMAIN js_int_array_2d;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out: [1, 2, 3]            | array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out: []                   | array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:-- json_build_array, json_build_object, json_object_agg
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:SELECT json_build_array('a',1,'b',1.2,'c',true,'d',null,'e',json '{"x": 3, "y": [1,2,3]}');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:                           json_build_array                            
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:SELECT json_build_array('a', NULL); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out: json_build_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:SELECT json_build_array(VARIADIC NULL::text[]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out: json_build_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:SELECT json_build_array(VARIADIC '{}'::text[]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out: json_build_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:SELECT json_build_array(VARIADIC '{a,b,c}'::text[]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out: json_build_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:SELECT json_build_array(VARIADIC ARRAY['a', NULL]::text[]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out: json_build_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:SELECT json_build_array(VARIADIC '{1,2,3,4}'::text[]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:   json_build_array   
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:SELECT json_build_array(VARIADIC '{1,2,3,4}'::int[]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out: json_build_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:SELECT json_build_array(VARIADIC '{{1,4},{2,5},{3,6}}'::int[][]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:  json_build_array  
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:       'd', json_build_object('e',array[9,8,7]::int[],
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:SELECT json_build_object('{a,b,c}'::text[], '{d,e,f}'::text[]); -- error, key cannot be array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  key value must be scalar, not array, composite, or json
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:-- empty objects/arrays
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:SELECT json_build_array();
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out: json_build_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  key value must be scalar, not array, composite, or json
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  key value must be scalar, not array, composite, or json
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  key value must be scalar, not array, composite, or json
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  array must have even number of elements
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  array must have two columns
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  array must have two columns
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  wrong number of array subscripts
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  wrong number of array subscripts
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  mismatched array dimensions
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  mismatched array dimensions
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:HINT:  See the array element [1] of key "ia".
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:ERROR:  malformed json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/json.out:DETAIL:  Multidimensional arrays must have sub-arrays with matching dimensions.
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT array_to_json(ARRAY [jsonb '{"a":1}', jsonb '{"b":[2,3]}']);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:      array_to_json       
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:-- anyarray column
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:('array','["zero", "one","two",null,"four","five", [1,2,3],{"f1":9}]'),
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT test_json -> 'x' FROM test_jsonb WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT test_json ->> 'field2' FROM test_jsonb WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT test_json -> 2 FROM test_jsonb WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT test_json -> 9 FROM test_jsonb WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT test_json ->> 6 FROM test_jsonb WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT test_json ->> 7 FROM test_jsonb WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT test_json ->> 2 FROM test_jsonb WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT jsonb_object_keys(test_json) FROM test_jsonb WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  cannot call jsonb_object_keys on an array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT (test_json->3) IS NULL AS expect_false FROM test_jsonb WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT (test_json->>3) IS NULL AS expect_true FROM test_jsonb WHERE json_type = 'array';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:-- Raw scalar may contain another raw scalar, array may contain a raw scalar
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:-- But a raw scalar cannot contain an array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:-- In general, one thing should always contain itself. Test array containment:
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:-- array containment string matching confusion bug
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:-- array length
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT jsonb_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out: jsonb_array_length 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT jsonb_array_length('[]');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out: jsonb_array_length 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT jsonb_array_length('{"f1":1,"f2":[5,6]}');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  cannot get array length of a non-array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT jsonb_array_length('4');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  cannot get array length of a scalar
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:-- array exists - array elements should behave as keys
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT count(*) from testjsonb  WHERE j->'array' ? 'bar';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:-- type sensitive array exists - should return no rows (since "exists" only
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:-- matches strings that are either object keys or array elements)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT count(*) from testjsonb  WHERE j->'array' ? '5'::text;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:-- However, a raw scalar is *contained* within the array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT count(*) from testjsonb  WHERE j->'array' @> '5'::jsonb;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT jsonb_typeof('[]') AS array;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out: array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out: array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT jsonb_typeof('["a", 1]') AS array;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out: array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out: array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:-- jsonb_build_array, jsonb_build_object, jsonb_object_agg
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT jsonb_build_array('a',1,'b',1.2,'c',true,'d',null,'e',json '{"x": 3, "y": [1,2,3]}');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:                            jsonb_build_array                            
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT jsonb_build_array('a', NULL); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out: jsonb_build_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT jsonb_build_array(VARIADIC NULL::text[]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out: jsonb_build_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT jsonb_build_array(VARIADIC '{}'::text[]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out: jsonb_build_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT jsonb_build_array(VARIADIC '{a,b,c}'::text[]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out: jsonb_build_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT jsonb_build_array(VARIADIC ARRAY['a', NULL]::text[]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out: jsonb_build_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT jsonb_build_array(VARIADIC '{1,2,3,4}'::text[]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:  jsonb_build_array   
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT jsonb_build_array(VARIADIC '{1,2,3,4}'::int[]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out: jsonb_build_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT jsonb_build_array(VARIADIC '{{1,4},{2,5},{3,6}}'::int[][]); -- ok
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out: jsonb_build_array  
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:       'd', jsonb_build_object('e',array[9,8,7]::int[],
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT jsonb_build_object('{a,b,c}'::text[], '{d,e,f}'::text[]); -- error, key cannot be array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  key value must be scalar, not array, composite, or json
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:-- empty objects/arrays
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT jsonb_build_array();
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out: jsonb_build_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  key value must be scalar, not array, composite, or json
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  key value must be scalar, not array, composite, or json
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  key value must be scalar, not array, composite, or json
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  array must have even number of elements
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  array must have two columns
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  array must have two columns
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  wrong number of array subscripts
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  wrong number of array subscripts
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  mismatched array dimensions
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  mismatched array dimensions
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f4','f6'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2','0'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>array['f2','1'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f4','f6'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT '{"f2":{"f3":1},"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2','0'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT '{"f2":["f3",1],"f4":{"f5":99,"f6":"stringy"}}'::jsonb#>>array['f2','1'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a', null];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a', ''];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b','c'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','b','c','d'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '{"a": {"b":{"c": "foo"}}}'::jsonb #> array['a','z','c'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #> array['a','1','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #> array['a','z','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '[{"b": "c"}, {"b": "cc"}]'::jsonb #> array['1','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '[{"b": "c"}, {"b": "cc"}]'::jsonb #> array['z','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '[{"b": "c"}, {"b": null}]'::jsonb #> array['1','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '"foo"'::jsonb #> array['z'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '42'::jsonb #> array['f2'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '42'::jsonb #> array['0'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a', null];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a', ''];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b','c'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','b','c','d'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '{"a": {"b":{"c": "foo"}}}'::jsonb #>> array['a','z','c'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #>> array['a','1','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '{"a": [{"b": "c"}, {"b": "cc"}]}'::jsonb #>> array['a','z','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '[{"b": "c"}, {"b": "cc"}]'::jsonb #>> array['1','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '[{"b": "c"}, {"b": "cc"}]'::jsonb #>> array['z','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '[{"b": "c"}, {"b": null}]'::jsonb #>> array['1','b'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '"foo"'::jsonb #>> array['z'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '42'::jsonb #>> array['f2'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '42'::jsonb #>> array['0'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:-- array_elements
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT jsonb_array_elements('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false]');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:    jsonb_array_elements    
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT * FROM jsonb_array_elements('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false]') q;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT jsonb_array_elements_text('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out: jsonb_array_elements_text  
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT * FROM jsonb_array_elements_text('[1,true,[1,[2,3]],null,{"f1":1,"f2":[7,8,9]},false,"stringy"]') q;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:CREATE DOMAIN jsb_int_array_1d  AS int[]   CHECK(array_length(VALUE, 1) = 3);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:CREATE DOMAIN jsb_int_array_2d  AS int[][] CHECK(array_length(VALUE, 2) = 3);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:	ia1d	jsb_int_array_1d,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:	ia2d	jsb_int_array_2d,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:HINT:  See the array element [1] of key "ia".
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  malformed json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:DETAIL:  Multidimensional arrays must have sub-arrays with matching dimensions.
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  value for domain jsb_int_array_1d violates check constraint "jsb_int_array_1d_check"
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  malformed json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:DETAIL:  Multidimensional arrays must have sub-arrays with matching dimensions.
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:HINT:  See the array element [1] of key "ia2".
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  value for domain jsb_int_array_2d violates check constraint "jsb_int_array_2d_check"
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  malformed json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:DETAIL:  Multidimensional arrays must have sub-arrays with matching dimensions.
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:HINT:  See the array element [1] of key "ta".
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:HINT:  See the array element [1] of key "ca".
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  cannot call populate_composite on an array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  expected json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:HINT:  See the array element [1] of key "ia".
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:ERROR:  malformed json array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:DETAIL:  Multidimensional arrays must have sub-arrays with matching dimensions.
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:DROP DOMAIN jsb_int_array_1d;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:DROP DOMAIN jsb_int_array_2d;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT count(*) FROM testjsonb WHERE j @> '{"array":["foo"]}';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT count(*) FROM testjsonb WHERE j @> '{"array":["bar"]}';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:-- array exists - array elements should behave as keys (for GIN index scans too)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:CREATE INDEX jidx_array ON testjsonb USING gin((j->'array'));
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT count(*) from testjsonb  WHERE j->'array' ? 'bar';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:-- type sensitive array exists - should return no rows (since "exists" only
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:-- matches strings that are either object keys or array elements)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT count(*) from testjsonb  WHERE j->'array' ? '5'::text;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:-- However, a raw scalar is *contained* within the array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:SELECT count(*) from testjsonb  WHERE j->'array' @> '5'::jsonb;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out: array     |     5
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:DROP INDEX jidx_array;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:-- nested object field / array index lookup
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:select '{"n":null, "a":1, "b":[1,2], "c":{"1":2}, "d":{"1":[2,3]}}'::jsonb #- '{b,-1e}'; -- invalid array subscript
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:-- prepend to array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:-- append to array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/jsonb.out:--add to empty array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/char.out:-- Now test longer arrays of char
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out:select array(select sum(x+y) s
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out:select array(select sum(x+y) s
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out:  array  
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out:select array_agg(a order by b)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out: array_agg 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out:select array_agg(a order by a)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out: array_agg 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out:select array_agg(a order by a desc)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out: array_agg 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out:select array_agg(b order by a desc)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out: array_agg 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out:select array_agg(distinct a)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out:  array_agg   
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out:select array_agg(distinct a order by a)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out:  array_agg   
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out:select array_agg(distinct a order by a desc)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out:  array_agg   
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out:select array_agg(distinct a order by a desc nulls last)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out:  array_agg   
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out:select percentile_disc(array[0,0.1,0.25,0.5,0.75,0.9,1]) within group (order by thousand)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out:select percentile_cont(array[0,0.25,0.5,0.75,1]) within group (order by thousand)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out:select percentile_disc(array[[null,1,0.5],[0.75,0.25,null]]) within group (order by thousand)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out:select percentile_cont(array[0,1,0.25,0.75,0.5,1,0.3,0.32,0.35,0.38,0.4]) within group (order by x)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out:select percentile_disc(array[0.25,0.5,0.75]) within group (order by x)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out:select array(select percentile_disc(a) within group (order by x)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out:LINE 1: select array(select percentile_disc(a) within group (order b...
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/aggregates.out:select least_agg(variadic array[q1,q2]) from int8_tbl;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_view.out:select 'foo'::text = any(array['abc','def','foo']::text[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_view.out:select 'foo'::text = any((select array['abc','def','foo']::text[]));  -- fail
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_view.out:LINE 1: select 'foo'::text = any((select array['abc','def','foo']::t...
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_view.out:select 'foo'::text = any((select array['abc','def','foo']::text[])::text[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_view.out:select 'foo'::text = any(array['abc','def','foo']::text[]) c1,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_view.out:       'foo'::text = any((select array['abc','def','foo']::text[])::text[]) c2;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_view.out:     'foo'::text = ANY ((( SELECT ARRAY['abc'::text, 'def'::text, 'foo'::text] AS "array"))::text[]) AS c2;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/inherit.out:            array             
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rules.out:            WHEN (pol.polroles = '{0}'::oid[]) THEN (string_to_array('public'::text, ''::text))::name[]
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rules.out:            ELSE NULL::anyarray
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rules.out:            ELSE NULL::anyarray
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rules.out:            ELSE NULL::anyarray
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/xml.out:SELECT xmlelement(name foo, array[1, 2, 3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/xml.out:                array_to_string(proargnames,',') as proargnames,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/xml.out:                case when proargtypes <> '' then array_to_string(proargtypes::oid[],',') end as proargtypes
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/xml.out:                array_to_string(proargnames,',') as proargnames,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/xml.out:                case when proargtypes <> '' then array_to_string(proargtypes::oid[],',') end as proargtypes
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.linux.utf8.out:SELECT array_agg(b ORDER BY b) FROM collate_test1;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.linux.utf8.out:     array_agg     
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.linux.utf8.out:SELECT array_agg(b ORDER BY b) FROM collate_test2;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.linux.utf8.out:     array_agg     
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.linux.utf8.out:SELECT array_agg(b ORDER BY b) FROM collate_test3;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.linux.utf8.out:     array_agg     
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.linux.utf8.out:SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test1)) ORDER BY 1;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.linux.utf8.out:SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test2)) ORDER BY 1;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.linux.utf8.out:SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test3)) ORDER BY 1;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/text.out:select concat(variadic array[1,2,3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/text.out:select concat_ws(',', variadic array[1,2,3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/text.out:ERROR:  VARIADIC argument must be an array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/text.out:select format('%s, %s', variadic array['Hello','World']);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/text.out:select format('%s, %s', variadic array[1, 2]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/text.out:select format('%s, %s', variadic array[true, false]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/text.out:select format('%s, %s', variadic array[true, false]::text[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/text.out:select format('%2$s, %1$s', variadic array['first', 'second']);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/text.out:select format('%2$s, %1$s', variadic array[1, 2]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/text.out:-- variadic argument can be array type NULL, but should not be referenced
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/text.out:select format(string_agg('%s',','), variadic array_agg(i))
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/alter_table.out:-- check renaming to a table's array type's autogenerated name
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/alter_table.out:-- (the array type's name should get out of the way)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/alter_table.out:CREATE TABLE tmp_array (id int);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/alter_table.out:CREATE TABLE tmp_array2 (id int);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/alter_table.out:SELECT typname FROM pg_type WHERE oid = 'tmp_array[]'::regtype;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/alter_table.out: _tmp_array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/alter_table.out:SELECT typname FROM pg_type WHERE oid = 'tmp_array2[]'::regtype;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/alter_table.out: _tmp_array2
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/alter_table.out:ALTER TABLE tmp_array2 RENAME TO _tmp_array;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/alter_table.out:SELECT typname FROM pg_type WHERE oid = 'tmp_array[]'::regtype;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/alter_table.out: __tmp_array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/alter_table.out:SELECT typname FROM pg_type WHERE oid = '_tmp_array[]'::regtype;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/alter_table.out: ___tmp_array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/alter_table.out:DROP TABLE _tmp_array;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/alter_table.out:DROP TABLE tmp_array;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/alter_table.out:-- renaming to table's own array type's name is an interesting corner case
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/alter_table.out:CREATE TABLE tmp_array (id int);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/alter_table.out:SELECT typname FROM pg_type WHERE oid = 'tmp_array[]'::regtype;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/alter_table.out: _tmp_array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/alter_table.out:ALTER TABLE tmp_array RENAME TO _tmp_array;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/alter_table.out:SELECT typname FROM pg_type WHERE oid = '_tmp_array[]'::regtype;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/alter_table.out: __tmp_array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/alter_table.out:DROP TABLE _tmp_array;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/alter_table.out:create domain array_of_recur1 as recur1[];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/alter_table.out:alter table recur1 add column f2 array_of_recur1; -- fails
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/join.out:(values (1, array[10,20]), (2, array[20,30])) as v1(v1x,v1ys)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/join.out:(values (1, array[10,20]), (2, array[20,30])) as v1(v1x,v1ys)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/char_1.out:-- Now test longer arrays of char
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out:  if $2 = 'pg_catalog.anyarray'::pg_catalog.regtype then
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out:  if $2 = 'pg_catalog.anyarray'::pg_catalog.regtype then
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out:       array_lower(p1.proargtypes, 1) != 0 OR
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out:       array_upper(p1.proargtypes, 1) != p1.pronargs-1 OR
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out:    ('anyelement'::regtype, 'anyarray'::regtype, 'anynonarray'::regtype,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out:     'anyarray'::regtype = ANY (p1.proargtypes) OR
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out:     'anynonarray'::regtype = ANY (p1.proargtypes) OR
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out: 2296 | anyarray_in
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out: 2502 | anyarray_recv
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out: 2777 | anynonarray_in
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out:  750 | array_in
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out: 2400 | array_recv
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out:-- Check for length inconsistencies between the various argument-info arrays.
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out:    array_length(proallargtypes,1) < array_length(proargtypes,1);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out:    array_length(proargmodes,1) < array_length(proargtypes,1);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out:    array_length(proargnames,1) < array_length(proargtypes,1);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out:    array_length(proallargtypes,1) <> array_length(proargmodes,1);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out:    array_length(proallargtypes,1) <> array_length(proargnames,1);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out:    array_length(proargmodes,1) <> array_length(proargnames,1);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out:        FROM generate_series(1, array_length(proallargtypes, 1)) g(i)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out:   378 | array_append            | append element onto end of array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out:   379 | array_prepend           | prepend element onto front of array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out:    array_dims(p1.proargtypes) != array_dims(p2.proargtypes)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out:WHERE array_lower(indkey, 1) != 0 OR array_upper(indkey, 1) != indnatts-1 OR
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out:    array_lower(indclass, 1) != 0 OR array_upper(indclass, 1) != indnatts-1 OR
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out:    array_lower(indcollation, 1) != 0 OR array_upper(indcollation, 1) != indnatts-1 OR
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/opr_sanity.out:    array_lower(indoption, 1) != 0 OR array_upper(indoption, 1) != indnatts-1;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/regex.out:-- Test some cases that crashed in 9.2beta1 due to pmatch[] array overrun
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/psql.out:prepare q as select array_to_string(array_agg(repeat('x',2*n)),E'\n') as "ab
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/psql.out:c", array_to_string(array_agg(repeat('y',20-2*n)),E'\n') as "a
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/varchar.out:-- Now test longer arrays of char
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.icu.utf8.out:SELECT array_agg(b ORDER BY b) FROM collate_test1;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.icu.utf8.out:     array_agg     
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.icu.utf8.out:SELECT array_agg(b ORDER BY b) FROM collate_test2;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.icu.utf8.out:     array_agg     
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.icu.utf8.out:SELECT array_agg(b ORDER BY b) FROM collate_test3;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.icu.utf8.out:     array_agg     
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.icu.utf8.out:SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test1)) ORDER BY 1;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.icu.utf8.out:SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test2)) ORDER BY 1;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/collate.icu.utf8.out:SELECT * FROM unnest((SELECT array_agg(b ORDER BY b) FROM collate_test3)) ORDER BY 1;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/subselect.out: array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/subselect.out: array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/subselect.out: array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/subselect.out:    ( select f1, array(select q1 from int8_tbl) as arr
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/subselect.out:  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/subselect.out:  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/subselect.out:  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/subselect.out:  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/subselect.out:  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/subselect.out:  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:-- only the 'e' array is 0-based, the others are 1-based.
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT array_ndims(a) AS a,array_ndims(b) AS b,array_ndims(c) AS c
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT array_dims(a) AS a,array_dims(b) AS b,array_dims(c) AS c
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:  WHERE array_dims(b) = '[1:1][1:2][1:2]';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:  WHERE array_dims(c) is not null;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  number of array dimensions (7) exceeds the maximum allowed (6)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:  WHERE array_dims(c) is not null;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  array subscript in assignment must not be null
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:  WHERE array_dims(c) is not null;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  array subscript in assignment must not be null
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:  WHERE array_dims(c) is not null;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  array subscript in assignment must not be null
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:  WHERE array_lower(a,1) = 1;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  source array too small
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  array slice subscript must provide both boundaries
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:DETAIL:  When assigning to a slice of an empty array value, slice boundaries must be fully specified.
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:-- check with fixed-length-array type, such as point
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  slices of fixed-length arrays not implemented
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  slices of fixed-length arrays not implemented
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  slices of fixed-length arrays not implemented
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  slices of fixed-length arrays not implemented
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  array subscript out of range
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:-- test array extension
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:insert into arrtest1 values(array[1,2,null,4], array['one','two',null,'four']);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:update arrtest1 set i[0:2] = array[10,11,12], t[0:2] = array['ten','eleven','twelve'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:update arrtest1 set i[8:10] = array[18,null,20], t[8:10] = array['p18',null,'p20'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:update arrtest1 set i[11:12] = array[null,22], t[11:12] = array[null,'p22'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:update arrtest1 set i[15:16] = array[null,26], t[15:16] = array[null,'p26'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:update arrtest1 set i[-5:-3] = array[-15,-14,-13], t[-5:-3] = array['m15','m14','m13'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:update arrtest1 set i[-7:-6] = array[-17,null], t[-7:-6] = array['m17',null];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:update arrtest1 set i[-12:-10] = array[-22,null,-20], t[-12:-10] = array['m22',null,'m20'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:insert into arrtest1 values(array[1,2,null,4], array['one','two',null,'four']);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:update arrtest1 set i[0:5] = array[0,1,2,null,4,5], t[0:5] = array['z','p1','p2',null,'p4','p5'];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:-- array expressions and operators
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:           array           
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:       array       
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:   array    
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT array_append(array[42], 6) AS "{42,6}";
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT array_prepend(6, array[42]) AS "{6,42}";
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT array_cat(ARRAY[1,2], ARRAY[3,4]) AS "{1,2,3,4}";
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT array_cat(ARRAY[1,2], ARRAY[[3,4],[5,6]]) AS "{{1,2},{3,4},{5,6}}";
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT array_cat(ARRAY[[3,4],[5,6]], ARRAY[1,2]) AS "{{3,4},{5,6},{1,2}}";
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT array_position(ARRAY[1,2,3,4,5], 4);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_position 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT array_position(ARRAY[5,3,4,2,1], 4);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_position 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT array_position(ARRAY[[1,2],[3,4]], 3);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  searching for elements in multidimensional arrays is not supported
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'mon');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_position 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'sat');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_position 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], NULL);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_position 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT array_position(ARRAY['sun','mon','tue','wed','thu',NULL,'fri','sat'], NULL);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_position 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT array_position(ARRAY['sun','mon','tue','wed','thu',NULL,'fri','sat'], 'sat');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_position 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT array_positions(NULL, 10);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_positions 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT array_positions(NULL, NULL::int);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_positions 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT array_positions(ARRAY[1,2,3,4,5,6,1,2,3,4,5,6], 4);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_positions 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT array_positions(ARRAY[[1,2],[3,4]], 4);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  searching for elements in multidimensional arrays is not supported
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT array_positions(ARRAY[1,2,3,4,5,6,1,2,3,4,5,6], NULL);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_positions 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT array_positions(ARRAY[1,2,3,NULL,5,6,1,2,3,NULL,5,6], NULL);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_positions 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT array_length(array_positions(ARRAY(SELECT 'AAAAAAAAAAAAAAAAAAAAAAAAA'::text || i % 10
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_length 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:  o := array_position(a, 2);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:    o := array_position(a, 2, o + 1);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT array_position('[2:4]={1,2,3}'::int[], 1);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_position 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT array_positions('[2:4]={1,2,3}'::int[], 1);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_positions 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:    array_position(ids, (1, 1)),
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:    array_positions(ids, (1, 1))
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_position | array_positions 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE i @> '{32}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE i && '{32}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE i @> '{17}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE i && '{17}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE i @> '{32,17}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE i && '{32,17}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE i <@ '{38,34,32,89}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE i = '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE i @> '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE i && '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE i <@ '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE i = '{NULL}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE i @> '{NULL}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE i && '{NULL}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE i <@ '{NULL}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE t && '{AAAAAAAA72908}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE t @> '{AAAAAAAAAA646}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE t && '{AAAAAAAAAA646}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE t @> '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE t && '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE t <@ '{AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE t = '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE t @> '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE t && '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:SELECT * FROM array_op_test WHERE t <@ '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:-- array casts
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:-- scalar op any/all (array)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select 33.4 = any (array[1,2,3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select 33.4 > all (array[1,2,3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  op ANY/ALL (array) requires operator to yield boolean
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  op ANY/ALL (array) requires array on right side
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:-- test indexes on arrays
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:-- test ON CONFLICT DO UPDATE with arrays
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select 'foo' like any (array['%a', '%o']); -- t
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select 'foo' like any (array['%a', '%b']); -- f
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select 'foo' like all (array['f%', '%o']); -- t
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select 'foo' like all (array['f%', '%b']); -- f
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select 'foo' not like any (array['%a', '%b']); -- t
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select 'foo' not like all (array['%a', '%o']); -- f
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select 'foo' ilike any (array['%A', '%O']); -- t
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select 'foo' ilike all (array['F%', '%O']); -- t
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:-- General array parser tests
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  malformed array literal: "{{1,{2}},{2,3}}"
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  malformed array literal: "{{},{}}"
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  malformed array literal: "{{1,2},\{2,3}}"
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  malformed array literal: "{{"1 2" x},{3}}"
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:DETAIL:  Unexpected array element.
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  malformed array literal: "{}}"
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  malformed array literal: "{ }}"
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array[];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  cannot determine type of empty array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:LINE 1: select array[];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array[]::text[];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:-- tests for array aggregates
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:-- A few simple tests for arrays of composite types
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:  values (row(1,'foo'), array[row(2,'bar')::comptype, row(3,'baz')::comptype]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:-- check that implicitly named array type _comptype isn't a problem
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:create or replace function unnest1(anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:create or replace function unnest2(anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select * from unnest1(array[1,2,3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select * from unnest2(array[[1,2,3],[4,5,6]]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:drop function unnest1(anyarray);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:drop function unnest2(anyarray);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_fill(null::integer, array[3,3],array[2,2]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:                           array_fill                            
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_fill(null::integer, array[3,3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:                      array_fill                      
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_fill(null::text, array[3,3],array[2,2]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:                           array_fill                            
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_fill(null::text, array[3,3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:                      array_fill                      
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_fill(7, array[3,3],array[2,2]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:              array_fill              
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_fill(7, array[3,3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:        array_fill         
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_fill('juhu'::text, array[3,3],array[2,2]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:                           array_fill                            
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_fill('juhu'::text, array[3,3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:                      array_fill                      
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select a, a = '{}' as is_eq, array_dims(a)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:  from (select array_fill(42, array[0]) as a) ss;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: a  | is_eq | array_dims 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select a, a = '{}' as is_eq, array_dims(a)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:  from (select array_fill(42, '{}') as a) ss;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: a  | is_eq | array_dims 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select a, a = '{}' as is_eq, array_dims(a)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:  from (select array_fill(42, '{}', '{}') as a) ss;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: a  | is_eq | array_dims 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_fill(1, null, array[2,2]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  dimension array or low bound array cannot be null
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_fill(1, array[2,2], null);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  dimension array or low bound array cannot be null
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_fill(1, array[2,2], '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  wrong number of array subscripts
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:DETAIL:  Low bound array has different size than dimensions array.
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_fill(1, array[3,3], array[1,1,1]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  wrong number of array subscripts
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:DETAIL:  Low bound array has different size than dimensions array.
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_fill(1, array[1,2,null]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_fill(1, array[[1,2],[3,4]]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  wrong number of array subscripts
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:DETAIL:  Dimension array must be one dimensional.
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select string_to_array('1|2|3', '|');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: string_to_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select string_to_array('1|2|3|', '|');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: string_to_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select string_to_array('1||2|3||', '||');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: string_to_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select string_to_array('1|2|3', '');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: string_to_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select string_to_array('', '|');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: string_to_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select string_to_array('1|2|3', NULL);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: string_to_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select string_to_array(NULL, '|') IS NULL;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select string_to_array('abc', '');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: string_to_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select string_to_array('abc', '', 'abc');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: string_to_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select string_to_array('abc', ',');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: string_to_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select string_to_array('abc', ',', 'abc');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: string_to_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select string_to_array('1,2,3,4,,6', ',');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: string_to_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select string_to_array('1,2,3,4,,6', ',', '');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: string_to_array  
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select string_to_array('1,2,3,4,*,6', ',', '*');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: string_to_array  
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_to_string(NULL::int4[], ',') IS NULL;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_to_string('{}'::int4[], ',');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_to_string 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_to_string(array[1,2,3,4,NULL,6], ',');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_to_string 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_to_string(array[1,2,3,4,NULL,6], ',', '*');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_to_string 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_to_string(array[1,2,3,4,NULL,6], NULL);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_to_string 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_to_string(array[1,2,3,4,NULL,6], ',', NULL);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_to_string 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_to_string(string_to_array('1|2|3', '|'), '|');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_to_string 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_length(array[1,2,3], 1);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_length 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_length(array[[1,2,3], [4,5,6]], 0);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_length 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_length(array[[1,2,3], [4,5,6]], 1);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_length 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_length(array[[1,2,3], [4,5,6]], 2);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_length 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_length(array[[1,2,3], [4,5,6]], 3);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_length 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select cardinality(array[1,2,3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:-- array_agg(anynonarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_agg(unique1) from (select unique1 from tenk1 where unique1 < 15 order by unique1) ss;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:              array_agg               
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_agg(ten) from (select ten from tenk1 where unique1 < 15 order by unique1) ss;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:            array_agg            
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_agg(nullif(ten, 4)) from (select ten from tenk1 where unique1 < 15 order by unique1) ss;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:               array_agg               
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_agg(unique1) from tenk1 where unique1 < -15;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_agg 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:-- array_agg(anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_agg(ar)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:   array_agg   
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_agg(distinct ar order by ar desc)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:  from (select array[i / 2] from generate_series(1,10) a(i)) b(ar);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:         array_agg         
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_agg(ar)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:  from (select array_agg(array[i, i+1, i-1])
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:      array_agg      
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_agg(array[i+1.2, i+1.3, i+1.4]) from generate_series(1,3) g(i);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:                  array_agg                  
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_agg(array['Hello', i::text]) from generate_series(9,11) g(i);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:             array_agg             
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_agg(array[i, nullif(i, 3), i+1]) from generate_series(1,4) g(i);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:              array_agg               
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_agg('{}'::int[]) from generate_series(1,2);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  cannot accumulate empty arrays
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_agg(null::int[]) from generate_series(1,2);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  cannot accumulate null arrays
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_agg(ar)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  cannot accumulate arrays of different dimensionality
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select unnest(array[1,2,3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select * from unnest(array[1,2,3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select unnest(array[1,2,3,4.5]::float8[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select unnest(array[1,2,3,4.5]::numeric[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select unnest(array[1,2,3,null,4,null,null,5,6]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select unnest(array[1,2,3,null,4,null,null,5,6]::text[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select abs(unnest(array[1,2,null,-3]));
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_remove(array[1,2,2,3], 2);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_remove 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_remove(array[1,2,2,3], 5);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_remove 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_remove(array[1,NULL,NULL,3], NULL);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_remove 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_remove(array['A','CC','D','C','RR'], 'RR');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_remove 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_remove('{{1,2,2},{1,4,3}}', 2); -- not allowed
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  removing elements from multidimensional arrays is not supported
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_remove(array['X','X','X'], 'X') = '{}';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_replace(array[1,2,5,4],5,3);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_replace 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_replace(array[1,2,5,4],5,NULL);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_replace 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_replace(array[1,2,NULL,4,NULL],NULL,5);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_replace 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_replace(array['A','B','DD','B'],'B','CC');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_replace 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_replace(array[1,NULL,3],NULL,NULL);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_replace 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array_replace(array['AB',NULL,'CDE'],NULL,'12');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out: array_replace 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:-- array(select array-value ...)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array(select array[i,i/2] from generate_series(1,5) i);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:              array              
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:select array(select array['Hello', i::text] from generate_series(9,11) i);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:               array               
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:-- Insert/update on a column that is array of composite
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:-- Check that arrays of composites are safely detoasted when needed
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:insert into dest select array[row(f1,f1)::textandtext] from src;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:-- Tests for polymorphic-array form of width_bucket()
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:                    array['yesterday', 'today', 'tomorrow']::timestamptz[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  thresholds array must not contain NULLs
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/arrays.out:ERROR:  thresholds must be one-dimensional array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/strings.out:-- optional capture group did not match, null entry in array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/strings.out:SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', $re$\s+$re$);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/strings.out:             regexp_split_to_array             
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/strings.out:SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', $re$\s*$re$);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/strings.out:                          regexp_split_to_array                          
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/strings.out:SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', '');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/strings.out:                                          regexp_split_to_array                                          
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/strings.out:SELECT regexp_split_to_array('thE QUick bROWn FOx jUMPs ovEr The lazy dOG', 'e', 'i');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/strings.out:                regexp_split_to_array                
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/strings.out:SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', 'nomatch');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/strings.out:              regexp_split_to_array              
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/strings.out:SELECT regexp_split_to_array('123456','1');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/strings.out: regexp_split_to_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/strings.out:SELECT regexp_split_to_array('123456','6');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/strings.out: regexp_split_to_array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/strings.out:SELECT regexp_split_to_array('123456','.');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/strings.out: regexp_split_to_array  
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/strings.out:SELECT regexp_split_to_array('thE QUick bROWn FOx jUMPs ovEr The lazy dOG', 'e', 'iz');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/strings.out:SELECT regexp_split_to_array('thE QUick bROWn FOx jUMPs ovEr The lazy dOG', 'e', 'g');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/strings.out:ERROR:  regexp_split_to_array does not support the global option
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/xml_2.out:SELECT xmlelement(name foo, array[1, 2, 3]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/xml_2.out:                array_to_string(proargnames,',') as proargnames,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/xml_2.out:                case when proargtypes <> '' then array_to_string(proargtypes::oid[],',') end as proargtypes
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/xml_2.out:                array_to_string(proargnames,',') as proargnames,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/xml_2.out:                case when proargtypes <> '' then array_to_string(proargtypes::oid[],',') end as proargtypes
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/varchar_2.out:-- Now test longer arrays of char
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:-- Test domains over array types
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:select array_dims(testint4arr), array_dims(testchar4arr) from domarrtest;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out: array_dims | array_dims 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:select array_dims('{1,2,3}'::dia);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out: array_dims 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:-- Test domains over arrays of composite
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:insert into dcomptable values (array[row(1,2)]::dcomptypea);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:insert into dcomptable values (array[row(3,4), row(5,6)]::comptype[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:insert into dcomptable values (array[row(7,8)::comptype, row(9,10)::comptype]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:insert into dcomptable values (array[row(1,2)]::dcomptypea);  -- fail on uniqueness
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:select array[row(2,1)]::dcomptypea;  -- fail
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:insert into dcomptable values (array[row(1,2)]::comptype[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:insert into dcomptable values (array[row(2,1)]::comptype[]);  -- fail
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:-- Likewise for domains within arrays of composite
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:-- Likewise for domains within domains over array of composite
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:create or replace function array_elem_check(numeric) returns numeric as $$
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:select array_elem_check(121.00);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:CONTEXT:  PL/pgSQL function array_elem_check(numeric) line 5 at assignment
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:select array_elem_check(1.23456);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out: array_elem_check 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:create or replace function array_elem_check(numeric) returns numeric as $$
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:select array_elem_check(121.00);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:CONTEXT:  PL/pgSQL function array_elem_check(numeric) line 5 at assignment
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:select array_elem_check(1.23456);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out: array_elem_check 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:create or replace function array_elem_check(numeric) returns numeric as $$
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:select array_elem_check(121.00);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:CONTEXT:  PL/pgSQL function array_elem_check(numeric) line 5 at assignment
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:select array_elem_check(1.23456);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out: array_elem_check 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:drop function array_elem_check(numeric);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:-- Check enforcement of array-level domain constraints
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:select array[1,2]::orderedpair;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out: array 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:select array[2,1]::orderedpair;  -- fail
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:insert into op values (array[1,2]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:insert into op values (array[2,1]);  -- fail
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:create or replace function array_elem_check(int) returns int as $$
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:select array_elem_check(3);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out: array_elem_check 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:select array_elem_check(-1);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:CONTEXT:  PL/pgSQL function array_elem_check(integer) line 5 at assignment
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/domain.out:drop function array_elem_check(int);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/sanity_check.out:array_index_op_test|t
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/sanity_check.out:array_op_test|f
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/tstypes.out:ERROR:  lexeme array may not contain nulls
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/tstypes.out:SELECT tsvector_to_array('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/tstypes.out:          tsvector_to_array           
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/tstypes.out:SELECT tsvector_to_array('base hidden rebel spaceship strike'::tsvector);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/tstypes.out:          tsvector_to_array           
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/tstypes.out:SELECT array_to_tsvector(ARRAY['base','hidden','rebel','spaceship','strike']);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/tstypes.out:              array_to_tsvector               
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/tstypes.out:SELECT array_to_tsvector(ARRAY['base','hidden','rebel','spaceship', NULL]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/tstypes.out:ERROR:  lexeme array may not contain nulls
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/tstypes.out:-- array_to_tsvector must sort and de-dup
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/tstypes.out:SELECT array_to_tsvector(ARRAY['foo','bar','baz','bar']);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/tstypes.out: array_to_tsvector 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/tstypes.out:ERROR:  lexeme array may not contain nulls
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/tstypes.out:ERROR:  weight array may not contain nulls
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rowtypes.out:-- Check ability to create arrays of anonymous rowtypes
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rowtypes.out:select array[ row(1,2), row(3,4), row(5,6) ];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rowtypes.out:           array           
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rowtypes.out:-- Check ability to compare an anonymous row to elements of an array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rowtypes.out:select row(1,1.1) = any (array[ row(7,7.7), row(1,1.1), row(0,0.0) ]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rowtypes.out:select row(1,1.1) = any (array[ row(7,7.7), row(1,1.0), row(0,0.0) ]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/brin.out:		FOR plan_line IN EXECUTE format($y$EXPLAIN SELECT array_agg(ctid) FROM brintest WHERE %s $y$, cond) LOOP
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/brin.out:		EXECUTE format($y$SELECT array_agg(ctid) FROM brintest WHERE %s $y$, cond)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/brin.out:		FOR plan_line IN EXECUTE format($y$EXPLAIN SELECT array_agg(ctid) FROM brintest WHERE %s $y$, cond) LOOP
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/brin.out:		EXECUTE format($y$SELECT array_agg(ctid) FROM brintest WHERE %s $y$, cond)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/brin.out:		count := array_length(idx_ctids, 1);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/brin.out:		IF NOT (count = array_length(ss_ctids, 1) AND
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangetypes.out:create function anyarray_anyrange_func(a anyarray, r anyrange)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangetypes.out:select anyarray_anyrange_func(ARRAY[1,2], int4range(10,20));
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangetypes.out: anyarray_anyrange_func 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangetypes.out:select anyarray_anyrange_func(ARRAY[1,2], numrange(10,20));
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangetypes.out:ERROR:  function anyarray_anyrange_func(integer[], numrange) does not exist
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangetypes.out:LINE 1: select anyarray_anyrange_func(ARRAY[1,2], numrange(10,20));
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangetypes.out:drop function anyarray_anyrange_func(anyarray, anyrange);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangetypes.out:create function rangetypes_sql(q anyrange, b anyarray, out c anyelement)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangetypes.out:            array             
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangetypes.out:create table i8r_array (f1 int, f2 int8range[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangetypes.out:insert into i8r_array values (42, array[int8range(1,10), int8range(2,20)]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangetypes.out:select * from i8r_array;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangetypes.out:drop table i8r_array;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangetypes.out:-- Ranges of arrays
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangetypes.out:create type arrayrange as range (subtype=int4[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangetypes.out:select arrayrange(ARRAY[1,2], ARRAY[2,1]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangetypes.out:    arrayrange     
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangetypes.out:select arrayrange(ARRAY[2,1], ARRAY[1,2]);  -- fail
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangetypes.out:select array[1,1] <@ arrayrange(array[1,2], array[2,1]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/rangetypes.out:select array[1,3] <@ arrayrange(array[1,2], array[2,1]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/amutils.out:       unnest(array['asc', 'desc', 'nulls_first', 'nulls_last',
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/amutils.out:                    'search_array', 'search_nulls',
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/amutils.out: search_array       |    |       | t
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/amutils.out:       unnest(array['asc', 'desc', 'nulls_first', 'nulls_last',
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/amutils.out:                    'search_array', 'search_nulls',
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/amutils.out: search_array       |    |       | f
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/amutils.out:       pg_index_column_has_property('botharrayidx'::regclass, 1, prop) as gin,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/amutils.out:  from unnest(array['asc', 'desc', 'nulls_first', 'nulls_last',
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/amutils.out:                    'search_array', 'search_nulls',
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/amutils.out: search_array       | t     | f    | f    | f      | f   | f
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/amutils.out:       pg_index_has_property('botharrayidx'::regclass, prop) as gin,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/amutils.out:  from unnest(array['clusterable', 'index_scan', 'bitmap_scan',
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/amutils.out:       unnest(array['can_order', 'can_unique', 'can_multi_col',
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/oidjoins.out:SELECT	ctid, typarray
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/oidjoins.out:WHERE	typarray != 0 AND
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/oidjoins.out:	NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.typarray);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/oidjoins.out: ctid | typarray 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:CREATE FUNCTION stfp(anyarray) RETURNS anyarray AS
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:CREATE FUNCTION tfp(anyarray,anyelement) RETURNS anyarray AS
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:CREATE FUNCTION tf1p(anyarray,int) RETURNS anyarray AS
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:CREATE FUNCTION ffp(anyarray) RETURNS anyarray AS
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:-- should ERROR: stfnp(anyarray) not matched by stfnp(int[])
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:CREATE AGGREGATE myaggp02a(*) (SFUNC = stfnp, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:CREATE AGGREGATE myaggp04a(*) (SFUNC = stfp, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:CREATE AGGREGATE myaggp04b(*) (SFUNC = stfp, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:-- should ERROR: tf1p(int[],anyelement) not matched by tf1p(anyarray,int)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:-- should ERROR: tfp(int[],anyelement) not matched by tfp(anyarray,anyelement)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:-- should ERROR: tfnp(anyarray, int) not matched by tfnp(int[],int)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:CREATE AGGREGATE myaggp13a(BASETYPE = int, SFUNC = tfnp, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:-- should ERROR: tf2p(anyarray, int) not matched by tf2p(int[],anyelement)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:CREATE AGGREGATE myaggp14a(BASETYPE = int, SFUNC = tf2p, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:-- should ERROR: tfnp(anyarray, anyelement) not matched by tfnp(int[],int)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:  STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:ERROR:  function tfnp(anyarray, anyelement) does not exist
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:-- should ERROR: tf2p(anyarray, anyelement) not matched by tf2p(int[],anyelement)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:  STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:ERROR:  function tf2p(anyarray, anyelement) does not exist
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:CREATE AGGREGATE myaggp17a(BASETYPE = int, SFUNC = tf1p, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:CREATE AGGREGATE myaggp17b(BASETYPE = int, SFUNC = tf1p, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:-- should ERROR: tfp(anyarray, int) not matched by tfp(anyarray, anyelement)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:CREATE AGGREGATE myaggp18a(BASETYPE = int, SFUNC = tfp, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:CREATE AGGREGATE myaggp18b(BASETYPE = int, SFUNC = tfp, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:-- should ERROR: tf1p(anyarray, anyelement) not matched by tf1p(anyarray, int)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:  STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:ERROR:  function tf1p(anyarray, anyelement) does not exist
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:  STYPE = anyarray, INITCOND = '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:ERROR:  function tf1p(anyarray, anyelement) does not exist
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:  STYPE = anyarray, FINALFUNC = ffp, INITCOND = '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:  STYPE = anyarray, INITCOND = '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:-- should ERROR: stfnp(anyarray) not matched by stfnp(int[])
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:CREATE AGGREGATE myaggn02a(*) (SFUNC = stfnp, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:CREATE AGGREGATE myaggn02b(*) (SFUNC = stfnp, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:-- should ERROR: ffnp(anyarray) not matched by ffnp(int[])
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:CREATE AGGREGATE myaggn04a(*) (SFUNC = stfp, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:-- should ERROR: tf1p(int[],anyelement) not matched by tf1p(anyarray,int)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:-- should ERROR: tfp(int[],anyelement) not matched by tfp(anyarray,anyelement)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:-- should ERROR: tfnp(anyarray, int) not matched by tfnp(int[],int)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:CREATE AGGREGATE myaggn13a(BASETYPE = int, SFUNC = tfnp, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:CREATE AGGREGATE myaggn13b(BASETYPE = int, SFUNC = tfnp, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:-- should ERROR: tf2p(anyarray, int) not matched by tf2p(int[],anyelement)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:CREATE AGGREGATE myaggn14a(BASETYPE = int, SFUNC = tf2p, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:CREATE AGGREGATE myaggn14b(BASETYPE = int, SFUNC = tf2p, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:-- should ERROR: tfnp(anyarray, anyelement) not matched by tfnp(int[],int)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:  STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:ERROR:  function tfnp(anyarray, anyelement) does not exist
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:  STYPE = anyarray, INITCOND = '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:ERROR:  function tfnp(anyarray, anyelement) does not exist
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:-- should ERROR: tf2p(anyarray, anyelement) not matched by tf2p(int[],anyelement)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:  STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:ERROR:  function tf2p(anyarray, anyelement) does not exist
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:  STYPE = anyarray, INITCOND = '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:ERROR:  function tf2p(anyarray, anyelement) does not exist
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:-- should ERROR: ffnp(anyarray) not matched by ffnp(int[])
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:CREATE AGGREGATE myaggn17a(BASETYPE = int, SFUNC = tf1p, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:-- should ERROR: tfp(anyarray, int) not matched by tfp(anyarray, anyelement)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:CREATE AGGREGATE myaggn18a(BASETYPE = int, SFUNC = tfp, STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:-- should ERROR: tf1p(anyarray, anyelement) not matched by tf1p(anyarray, int)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:  STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:ERROR:  function tf1p(anyarray, anyelement) does not exist
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:-- should ERROR: ffnp(anyarray) not matched by ffnp(int[])
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:  STYPE = anyarray, FINALFUNC = ffnp, INITCOND = '{}');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:ERROR:  function ffnp(anyarray) does not exist
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:insert into t values(1,array[1],'a');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:insert into t values(1,array[11],'b');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:insert into t values(1,array[111],'c');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:insert into t values(2,array[2],'a');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:insert into t values(2,array[22],'b');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:insert into t values(2,array[222],'c');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:insert into t values(3,array[3],'a');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:insert into t values(3,array[3],'b');
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:CREATE AGGREGATE array_cat_accum (anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:    sfunc = array_cat,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:    stype = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:SELECT array_cat_accum(i)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out: array_cat_accum 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:SELECT array_cat_accum(i)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:          array_cat_accum          
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:create function add_group(grp anyarray, ad anyelement, size integer)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:  returns anyarray
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:    return array[ad];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:  if array_upper(grp, 1) < size then
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:  STYPE = anyarray
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:create function first_el(anyarray) returns anyelement as
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:  SFUNC = array_append,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:  SFUNC = array_append,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:  STYPE = anyarray,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:select distinct array_ndims(histogram_bounds) from pg_stats
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out: array_ndims 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:ERROR:  cannot compare arrays of different element types
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:create function myleast(variadic anyarray) returns anyelement as $$
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:select myleast(variadic array[1,2,3,4,-1]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:select myleast(variadic array[1.1, -5.5]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:select myleast(variadic array[]::int[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:create function concat(text, variadic anyarray) returns text as $$
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:  select array_to_string($2, $1);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:select concat('|', variadic array[1,2,33]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:select concat('|', variadic array[]::int[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:drop function concat(text, anyarray);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:create function formarray(anyelement, variadic anyarray) returns anyarray as $$
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:  select array_prepend($1, $2);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:select formarray(1,2,3,4,5);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:  formarray  
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:select formarray(1.1, variadic array[1.2,55.5]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:   formarray    
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:select formarray(1.1, array[1.2,55.5]); -- fail without variadic
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:ERROR:  function formarray(numeric, numeric[]) does not exist
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:LINE 1: select formarray(1.1, array[1.2,55.5]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:select formarray(1, 'x'::text); -- fail, type mismatch
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:ERROR:  function formarray(integer, text) does not exist
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:LINE 1: select formarray(1, 'x'::text);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:select formarray(1, variadic array['x'::text]); -- fail, type mismatch
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:ERROR:  function formarray(integer, text[]) does not exist
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:LINE 1: select formarray(1, variadic array['x'::text]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:drop function formarray(anyelement, variadic anyarray);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:select pg_typeof(array[1.2,55.5]); -- numeric[]
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:$$ select array_upper($1, 1) $$ language sql;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:create or replace function dfunc(a variadic int[] default array[]::int[]) returns int as
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:$$ select array_upper($1, 1) $$ language sql;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/polymorphism.out:$$ select array_upper($1, 1) $$ language sql;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:CREATE INDEX intarrayidx ON array_index_op_test USING gin (i);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:   ->  Bitmap Heap Scan on array_index_op_test
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:         ->  Bitmap Index Scan on intarrayidx
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE i @> '{17}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE i && '{17}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE i @> '{32,17}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE i && '{32,17}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE i <@ '{38,34,32,89}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE i = '{47,77}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE i = '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE i @> '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE i && '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE i <@ '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_op_test WHERE i = '{NULL}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_op_test WHERE i @> '{NULL}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_op_test WHERE i && '{NULL}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_op_test WHERE i <@ '{NULL}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:CREATE INDEX textarrayidx ON array_index_op_test USING gin (t);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:   ->  Bitmap Heap Scan on array_index_op_test
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:         ->  Bitmap Index Scan on textarrayidx
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAAAA646}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAAAA646}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE t <@ '{AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE t = '{AAAAAAAAAA646,A87088}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE t = '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE t @> '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE t && '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE t <@ '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:DROP INDEX intarrayidx, textarrayidx;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:CREATE INDEX botharrayidx ON array_index_op_test USING gin (i, t);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAA80240}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE t && '{AAAAAAA80240}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE i @> '{32}' AND t && '{AAAAAAA80240}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE i && '{32}' AND t @> '{AAAAAAA80240}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_index_op_test WHERE t = '{}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_op_test WHERE i = '{NULL}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT * FROM array_op_test WHERE i <@ '{NULL}' ORDER BY seqno;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:CREATE TABLE array_gin_test (a int[]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:INSERT INTO array_gin_test SELECT ARRAY[1, g%5, g] FROM generate_series(1, 10000) g;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:CREATE INDEX array_gin_test_idx ON array_gin_test USING gin (a);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:SELECT COUNT(*) FROM array_gin_test WHERE a @> '{2}';
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:DROP TABLE array_gin_test;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:CREATE INDEX gin_relopts_test ON array_index_op_test USING gin (i)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_index.out:gin, for table "public.array_index_op_test"
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/varchar_1.out:-- Now test longer arrays of char
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/type_sanity.out:-- Look for types that should have an array type according to their typtype,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/type_sanity.out:-- make array types corresponding to the system catalogs' rowtypes.
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/type_sanity.out:           p2.typelem = p1.oid and p1.typarray = p2.oid);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/type_sanity.out:-- Make sure typarray points to a varlena array type of our own base
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/type_sanity.out:SELECT p1.oid, p1.typname as basetype, p2.typname as arraytype,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/type_sanity.out:FROM   pg_type p1 LEFT JOIN pg_type p2 ON (p1.typarray = p2.oid)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/type_sanity.out:WHERE  p1.typarray <> 0 AND
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/type_sanity.out: oid | basetype | arraytype | typelem | typlen 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/type_sanity.out:-- Varlena array types will point to array_in
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/type_sanity.out:    (p2.oid = 'array_in'::regproc)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/type_sanity.out:      (p2.oid = 'array_out'::regproc AND
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/type_sanity.out:-- Varlena array types will point to array_recv
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/type_sanity.out:    (p2.oid = 'array_recv'::regproc)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/type_sanity.out:      (p2.oid = 'array_send'::regproc AND
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/type_sanity.out:WHERE p1.typarray = p2.oid AND NOT (p1.typdelim = p2.typdelim);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/type_sanity.out:-- Look for array types whose typalign isn't sufficient
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/type_sanity.out:WHERE p1.typarray = p2.oid AND
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/type_sanity.out:-- array_typanalyze should be used for all and only array types
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/type_sanity.out:    (t.typanalyze = 'array_typanalyze'::regproc) !=
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/type_sanity.out:-- We must allow anyarray matches, cf opr_sanity's binary_coercible()
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/type_sanity.out:     (o.opcintype = 'pg_catalog.anyarray'::regtype AND
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/privileges.out:-- verify privilege checks on array-element coercions
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/privileges.out:ERROR:  cannot set privileges of array types
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/with.out:	array_upper(t1.path,1) = 1 AND
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/with.out:	array_upper(t2.path,1) > 1)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/with.out:	array_upper(t1.path,1) = 1 AND
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/with.out:	array_upper(t2.path,1) > 1)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/with.out:	select *, array[row(g.f, g.t)], false from graph g
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/with.out:	select *, array[row(g.f, g.t)], false from graph g
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/with.out:C as ( select A.id, array(select B.id from B where B.id = A.id) from A )
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/with.out:        id         |                array                
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_aggregate.out:as 'select array_append($1,ROW($2,$3,$4)::aggtype)'
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_aggregate.out:as 'select array_append($1,ROW($2,$3,$4)::aggtype)'
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_aggregate.out:create function least_accum(anyelement, variadic anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_aggregate.out:create aggregate least_agg(variadic items anyarray) (
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/updatable_views.out:-- multiple array-column updates
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/updatable_views.out:-- WITH CHECK OPTION with scalar array ops
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_table.out:CREATE TABLE array_op_test (
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_table.out:CREATE TABLE array_index_op_test (
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_table.out:-- list partitioning on array type column
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/create_table.out:Partition constraint: ((a IS NOT NULL) AND (((a)::anyarray OPERATOR(pg_catalog.=) '{1}'::integer[]) OR ((a)::anyarray OPERATOR(pg_catalog.=) '{2}'::integer[])))
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/insert_conflict.out:-- Does the same, but JSON format shows "Conflict Arbiter Index" as JSON array:
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/insert.out:-- check indirection (field/array assignment), cf bug #14265
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/insert.out:ERROR:  cannot set an array element to DEFAULT
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/insert.out:insert into inserttest (f3.if1, f3.if2) values (1,array['foo']);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:create function duplic(in i anyelement, out j anyelement, out k anyarray) as $$
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:  k := array[j,j];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:  for i in array_lower($1,1)..array_upper($1,1) loop
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:select vari(variadic array[5,6,7]);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:declare aux numeric = $1[array_lower($1,1)];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:  for i in array_lower($1,1)+1..array_upper($1,1) loop
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:  -- just for fun, let's use array elements as targets
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:  arr := array[array['foo','bar'], array['baz', 'quux']];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:-- Test FOREACH over arrays
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:create function foreach_test(anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:  foreach x in array $1
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:create or replace function foreach_test(anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:  foreach x slice 1 in array $1
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:ERROR:  FOREACH ... SLICE loop variable must be of an array type
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:CONTEXT:  PL/pgSQL function foreach_test(anyarray) line 4 at FOREACH over array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:ERROR:  FOREACH ... SLICE loop variable must be of an array type
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:CONTEXT:  PL/pgSQL function foreach_test(anyarray) line 4 at FOREACH over array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:create or replace function foreach_test(anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:  foreach x slice 1 in array $1
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:create or replace function foreach_test(anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:  foreach x slice 2 in array $1
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:CONTEXT:  PL/pgSQL function foreach_test(anyarray) line 4 at FOREACH over array
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:-- iteration over array of records
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:create or replace function foreach_test(anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:  foreach r in array $1
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:create or replace function foreach_test(anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:  foreach x, y in array $1
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:-- slicing over array of composite types
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:create or replace function foreach_test(anyarray)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:  foreach x slice 1 in array $1
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:drop function foreach_test(anyarray);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:-- Assorted tests for array subscript assignment
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:create function arrayassign1() returns text[] language plpgsql as $$
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:select arrayassign1();
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:   arrayassign1    
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:select arrayassign1(); -- try again to exercise internal caching
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:   arrayassign1    
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:create domain orderedarray as int[2]
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:select '{1,2}'::orderedarray;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out: orderedarray 
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:select '{2,1}'::orderedarray;  -- fail
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:ERROR:  value for domain orderedarray violates check constraint "sorted"
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:create function testoa(x1 int, x2 int, x3 int) returns orderedarray
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:declare res orderedarray;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:  res := array[x1, x2];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:ERROR:  value for domain orderedarray violates check constraint "sorted"
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:ERROR:  value for domain orderedarray violates check constraint "sorted"
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:drop function arrayassign1();
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:-- Test handling of expanded arrays
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:create function returns_rw_array(int) returns int[]
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:  begin r := array[$1, $1]; return r; end;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:create function consumes_rw_array(int[]) returns int
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:  (select returns_rw_array(1) as a offset 0) ss,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:  lateral consumes_rw_array(a) i;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:   Output: i.i, (returns_rw_array(1))
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:         Output: returns_rw_array(1)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:   ->  Function Scan on public.consumes_rw_array i
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:         Function Call: consumes_rw_array((returns_rw_array(1)))
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:  (select returns_rw_array(1) as a offset 0) ss,
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:  lateral consumes_rw_array(a) i;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:select consumes_rw_array(a), a from returns_rw_array(1) a;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out: Function Scan on public.returns_rw_array a
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:   Output: consumes_rw_array(a), a
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:   Function Call: returns_rw_array(1)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:select consumes_rw_array(a), a from returns_rw_array(1) a;
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out: consumes_rw_array |   a   
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:select consumes_rw_array(a), a from
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:  (values (returns_rw_array(1)), (returns_rw_array(2))) v(a);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:   Output: consumes_rw_array("*VALUES*".column1), "*VALUES*".column1
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:select consumes_rw_array(a), a from
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:  (values (returns_rw_array(1)), (returns_rw_array(2))) v(a);
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out: consumes_rw_array |   a   
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:-- Test handling of expanded array passed to a domain constraint (bug #14472)
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:  v_test := array[1];
/srvr/z5089358/postgresql-10.4/src/test/regress/expected/plpgsql.out:declare v_test plpgsql_arr_domain := array[1];
/srvr/z5089358/postgresql-10.4/src/test/regress/parallel_schedule:test: select_into select_distinct select_distinct_on select_implicit select_having subselect union case join aggregates transactions random portals arrays btree_index hash_index update namespace prepared_xacts delete
Binary file /srvr/z5089358/postgresql-10.4/src/test/isolation/isolationtester matches
/srvr/z5089358/postgresql-10.4/src/test/isolation/specscanner.c: * integer for use as an array index.  If the signed char is negative,
/srvr/z5089358/postgresql-10.4/src/test/isolation/specscanner.c:static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
/srvr/z5089358/postgresql-10.4/src/test/isolation/specscanner.c:		/* Extend the array by 50%, plus the number we really need. */
/srvr/z5089358/postgresql-10.4/src/test/isolation/specparse.c:/* The size of an array large to enough to hold all stacks, each with
/srvr/z5089358/postgresql-10.4/src/test/isolation/specs/insert-conflict-toast.spec:  CREATE OR REPLACE FUNCTION ctoast_large_val() RETURNS TEXT LANGUAGE SQL AS 'select array_agg(md5(g::text))::text from generate_series(1, 256) g';
Binary file /srvr/z5089358/postgresql-10.4/src/test/isolation/pg_isolation_regress matches
/srvr/z5089358/postgresql-10.4/src/test/isolation/isolationtester.c:				/* Remove that step from the waiting[] array. */
/srvr/z5089358/postgresql-10.4/src/test/isolation/isolationtester.c:		/* If this step is waiting, add it to the array of waiters. */
/srvr/z5089358/postgresql-10.4/src/test/examples/testlibpq3.c:	/* Set up parameter arrays for PQexecParams */
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	CREATE TABLE public.tst_one_array (
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	CREATE TABLE public.tst_arrays (
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	CREATE TYPE public.tst_comp_enum_array_t AS (a FLOAT, b public.tst_enum_t[], c INTEGER);
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	CREATE TABLE public.tst_comp_enum_array (
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	CREATE TABLE public.tst_comp_one_enum_array (
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:		b public.tst_comp_enum_array_t
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:		a public.tst_comp_enum_array_t PRIMARY KEY,
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:		b public.tst_comp_enum_array_t[]
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	CREATE TABLE public.tst_comp_mix_array (
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	CREATE TABLE public.tst_range_array (
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	-- test_tbl_one_array_col
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	INSERT INTO tst_one_array (a, b) VALUES
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	-- test_tbl_arrays
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	INSERT INTO tst_arrays (a, b, c, d) VALUES
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	-- test_tbl_composite_with_enums_array
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	INSERT INTO tst_comp_enum_array (a, b) VALUES
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	-- test_tbl_composite_with_single_enums_array_in_composite
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	INSERT INTO tst_comp_one_enum_array (a, b) VALUES
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	-- test_tbl_composite_with_enums_array_in_composite
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:		(ROW(1.0, '{a, b, c}', 1), ARRAY[ROW(1, '{a, b, c}', 1)::tst_comp_enum_array_t]),
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:		(ROW(2.0, '{b, c, a}', 2), ARRAY[ROW(2, '{b, c, a}', 1)::tst_comp_enum_array_t]),
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:		(ROW(3.0, '{c, a, b}', 1), ARRAY[ROW(3, '{c, a, b}', 1)::tst_comp_enum_array_t]),
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:		(ROW(4.0, '{c, b, d}', 4), ARRAY[ROW(4, '{c, b, d}', 4)::tst_comp_enum_array_t]),
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:		(ROW(5.0, '{c, NULL, b}', NULL), ARRAY[ROW(5, '{c, e, b}', 1)::tst_comp_enum_array_t]);
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	INSERT INTO tst_comp_mix_array (a, b) VALUES
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	-- test_tbl_range_array
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	INSERT INTO tst_range_array (a, b, c) VALUES
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	SELECT a, b FROM tst_one_array ORDER BY a;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	SELECT a, b, c, d FROM tst_arrays ORDER BY a;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	SELECT a, b FROM tst_comp_enum_array ORDER BY a;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	SELECT a, b FROM tst_comp_one_enum_array ORDER BY a;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	SELECT a, b FROM tst_comp_mix_array ORDER BY a;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	SELECT a, b, c FROM tst_range_array ORDER BY a;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	UPDATE tst_one_array SET b = '{4, 5, 6}' WHERE a = 1;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	UPDATE tst_one_array SET b = '{4, 5, 6, 1}' WHERE a > 3;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	UPDATE tst_arrays SET b = '{"1a", "2b", "3c"}', c = '{1.0, 2.0, 3.0}', d = '{"1 day 1 second", "2 days 2 seconds", "3 days 3 second"}' WHERE a = '{1, 2, 3}';
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	UPDATE tst_arrays SET b = '{"c", "d", "e"}', c = '{3.0, 4.0, 5.0}', d = '{"3 day 1 second", "4 days 2 seconds", "5 days 3 second"}' WHERE a[1] > 3;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	UPDATE tst_comp_enum_array SET b = ARRAY[NULL, ROW(3, 'd', 3)::tst_comp_enum_t] WHERE a = ROW(1.0, 'a', 1)::tst_comp_enum_t;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	UPDATE tst_comp_enum_array SET b = ARRAY[ROW(1, 'a', 1)::tst_comp_enum_t, ROW(2, 'b', 2)::tst_comp_enum_t] WHERE (a).a > 3;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	UPDATE tst_comp_one_enum_array SET b = ROW(1.0, '{a, e, c}', NULL) WHERE a = 1;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	UPDATE tst_comp_one_enum_array SET b = ROW(4.0, '{c, b, d}', 4) WHERE a > 3;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	UPDATE tst_comp_enum_what SET b = ARRAY[NULL, ROW(1, '{a, b, c}', 1)::tst_comp_enum_array_t, ROW(NULL, '{a, e, c}', 2)::tst_comp_enum_array_t] WHERE (a).a = 1;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	UPDATE tst_comp_enum_what SET b = ARRAY[ROW(5, '{a, b, c}', 5)::tst_comp_enum_array_t] WHERE (a).a > 3;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	UPDATE tst_comp_mix_array SET b[2] = NULL WHERE ((a).a).a = 1;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	UPDATE tst_range_array SET c = '{"[100, 1000]"}' WHERE a = 1;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	UPDATE tst_range_array SET b = tstzrange('Mon Aug 04 00:00:00 2014 CEST'::timestamptz, 'infinity'), c = '{NULL, "[11,9999999]"}' WHERE a > 3;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	SELECT a, b FROM tst_one_array ORDER BY a;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	SELECT a, b, c, d FROM tst_arrays ORDER BY a;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	SELECT a, b FROM tst_comp_enum_array ORDER BY a;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	SELECT a, b FROM tst_comp_one_enum_array ORDER BY a;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	SELECT a, b FROM tst_comp_mix_array ORDER BY a;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	SELECT a, b, c FROM tst_range_array ORDER BY a;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	DELETE FROM tst_one_array WHERE a = 1;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	DELETE FROM tst_one_array WHERE b = '{2, 3, 1}';
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	DELETE FROM tst_arrays WHERE a = '{1, 2, 3}';
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	DELETE FROM tst_arrays WHERE a[1] = 2;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	DELETE FROM tst_comp_enum_array WHERE a = ROW(1.0, 'a', 1)::tst_comp_enum_t;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	DELETE FROM tst_comp_enum_array WHERE ROW(3, 'c', 3)::tst_comp_enum_t = ANY(b);
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	DELETE FROM tst_comp_one_enum_array WHERE a = 1;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	DELETE FROM tst_comp_one_enum_array WHERE 'a' = ANY((b).b);
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	DELETE FROM tst_comp_mix_array WHERE ((a).a).a = 1;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	DELETE FROM tst_range_array WHERE a = 1;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	DELETE FROM tst_range_array WHERE tstzrange('Mon Aug 04 00:00:00 2014 CEST'::timestamptz, 'Mon Aug 05 00:00:00 2014 CEST'::timestamptz) && b;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	SELECT a, b FROM tst_one_array ORDER BY a;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	SELECT a, b, c, d FROM tst_arrays ORDER BY a;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	SELECT a, b FROM tst_comp_enum_array ORDER BY a;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	SELECT a, b FROM tst_comp_one_enum_array ORDER BY a;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	SELECT a, b FROM tst_comp_mix_array ORDER BY a;
/srvr/z5089358/postgresql-10.4/src/test/subscription/t/002_types.pl:	SELECT a, b, c FROM tst_range_array ORDER BY a;
/srvr/z5089358/postgresql-10.4/src/test/recovery/t/007_sync_rep.pl:# it's stored in the head of WalSnd array which manages
/srvr/z5089358/postgresql-10.4/src/test/recovery/t/007_sync_rep.pl:# in WalSnd array. Now, if standbys have the same priority,
/srvr/z5089358/postgresql-10.4/src/test/recovery/t/007_sync_rep.pl:# earlier in WalSnd array as sync standbys.
/srvr/z5089358/postgresql-10.4/src/test/recovery/t/007_sync_rep.pl:# Check that the state of standby1 stored earlier in WalSnd array than
/srvr/z5089358/postgresql-10.4/src/test/recovery/t/007_sync_rep.pl:	'potential standby found earlier in array is promoted to sync');
/srvr/z5089358/postgresql-10.4/src/test/recovery/t/003_recovery_targets.pl:# Last entry has priority (note that an array respects the order of items
Binary file /srvr/z5089358/postgresql-10.4/src/bin/pg_resetwal/pg_resetwal matches
Binary file /srvr/z5089358/postgresql-10.4/src/bin/pg_archivecleanup/pg_archivecleanup matches
Binary file /srvr/z5089358/postgresql-10.4/src/bin/pg_test_timing/pg_test_timing matches
Binary file /srvr/z5089358/postgresql-10.4/src/bin/scripts/createuser matches
Binary file /srvr/z5089358/postgresql-10.4/src/bin/scripts/reindexdb matches
Binary file /srvr/z5089358/postgresql-10.4/src/bin/scripts/clusterdb matches
Binary file /srvr/z5089358/postgresql-10.4/src/bin/scripts/dropdb matches
Binary file /srvr/z5089358/postgresql-10.4/src/bin/scripts/vacuumdb matches
Binary file /srvr/z5089358/postgresql-10.4/src/bin/scripts/dropuser matches
/srvr/z5089358/postgresql-10.4/src/bin/scripts/vacuumdb.c:	 * array contains the connection.
Binary file /srvr/z5089358/postgresql-10.4/src/bin/scripts/pg_isready matches
Binary file /srvr/z5089358/postgresql-10.4/src/bin/scripts/createdb matches
/srvr/z5089358/postgresql-10.4/src/bin/initdb/initdb.c: * make a copy of the array of lines, with token replaced by replacement
/srvr/z5089358/postgresql-10.4/src/bin/initdb/initdb.c: * write an array of lines to a file
/srvr/z5089358/postgresql-10.4/src/bin/initdb/initdb.c:	 * max_connections value. The arrays show the settings to try.
/srvr/z5089358/postgresql-10.4/src/bin/initdb/initdb.c:		"  SET relacl = (SELECT array_agg(a.acl) FROM "
Binary file /srvr/z5089358/postgresql-10.4/src/bin/initdb/initdb matches
Binary file /srvr/z5089358/postgresql-10.4/src/bin/initdb/initdb.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/bin/pg_waldump/pg_waldump matches
/srvr/z5089358/postgresql-10.4/src/bin/pgbench/exprparse.c:/* The size of an array large to enough to hold all stacks, each with
/srvr/z5089358/postgresql-10.4/src/bin/pgbench/exprparse.c:	/* keep as last array element */
/srvr/z5089358/postgresql-10.4/src/bin/pgbench/exprparse.c: * return the index of the function from the PGBENCH_FUNCTIONS array
Binary file /srvr/z5089358/postgresql-10.4/src/bin/pgbench/pgbench matches
/srvr/z5089358/postgresql-10.4/src/bin/pgbench/exprparse.y:	/* keep as last array element */
/srvr/z5089358/postgresql-10.4/src/bin/pgbench/exprparse.y: * return the index of the function from the PGBENCH_FUNCTIONS array
/srvr/z5089358/postgresql-10.4/src/bin/pgbench/exprscan.c: * integer for use as an array index.  If the signed char is negative,
/srvr/z5089358/postgresql-10.4/src/bin/pgbench/exprscan.c:    YY_BUFFER_STATE * yy_buffer_stack; /**< Stack as an array. */
/srvr/z5089358/postgresql-10.4/src/bin/pgbench/exprscan.c:		/* Extend the array by 50%, plus the number we really need. */
/srvr/z5089358/postgresql-10.4/src/bin/pgbench/pgbench.c:	Variable   *variables;		/* array of variable definitions */
/srvr/z5089358/postgresql-10.4/src/bin/pgbench/pgbench.c:	CState	   *state;			/* array of CState */
/srvr/z5089358/postgresql-10.4/src/bin/pgbench/pgbench.c:	Command   **commands;		/* NULL-terminated array of Commands */
/srvr/z5089358/postgresql-10.4/src/bin/pgbench/pgbench.c:/* qsort comparator for Variable array */
/srvr/z5089358/postgresql-10.4/src/bin/pgbench/pgbench.c:		/* Create variable at the end of the array */
/srvr/z5089358/postgresql-10.4/src/bin/pgbench/pgbench.c:		/* we don't re-sort the array till we have to */
/srvr/z5089358/postgresql-10.4/src/bin/pgbench/pgbench.c:	TState	   *threads;		/* array of thread */
/srvr/z5089358/postgresql-10.4/src/bin/psql/variables.h: * as a cheap version of an associative array.  Each variable has a string
Binary file /srvr/z5089358/postgresql-10.4/src/bin/psql/command.o matches
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						  "    pg_catalog.array_to_string(ARRAY(\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						  "        pg_catalog.generate_series(0, pg_catalog.array_upper(p.proargtypes, 1)) AS s(i)\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						  "    pg_catalog.array_to_string(ARRAY(\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						  "        pg_catalog.generate_series(1, pg_catalog.array_upper(p.proallargtypes, 1)) AS s(i)\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						  "    pg_catalog.array_to_string(ARRAY(\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						  "        pg_catalog.generate_series(0, pg_catalog.array_upper(p.proargtypes, 1)) AS s(i)\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:							 "  pg_catalog.array_to_string(\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:	 * do not include array types (before 8.3 we have to use the assumption
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:		appendPQExpBufferStr(&buf, "  AND NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type el WHERE el.oid = t.typelem AND el.typarray = t.oid)\n");
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						  ",\n  pg_catalog.array_to_string(ARRAY(\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						  "    SELECT attname || E':\\n  ' || pg_catalog.array_to_string(attacl, E'\\n  ')\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						  ",\n  pg_catalog.array_to_string(ARRAY(\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						  "           E'\\n  to: ' || pg_catalog.array_to_string(\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						  ",\n  pg_catalog.array_to_string(ARRAY(\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						  "           E'\\n  to: ' || pg_catalog.array_to_string(\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						   "pg_catalog.array_to_string(c.reloptions || "
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						   "array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						   "pg_catalog.array_to_string(c.reloptions || "
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						   "array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						   "pg_catalog.array_to_string(c.reloptions || "
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						   "array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						   "pg_catalog.array_to_string(c.reloptions || "
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						   "array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						   "pg_catalog.array_to_string(c.reloptions || "
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						   "array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						   "pg_catalog.array_to_string(reloptions, E', ')" : "''"),
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:							 "  '(' || pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || ' ' || pg_catalog.quote_literal(option_value)  FROM "
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:							  "  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:							  "  pg_catalog.array_to_string(ARRAY(\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:					  "pg_catalog.array_to_string(setconfig, E'\\n') AS \"%s\"\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c: * tabtypes is an array of characters, specifying what info is desired:
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:					  "       pg_catalog.array_to_string(ARRAY(\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:					  "pg_catalog.array_to_string(array(select x"
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						  "  '(' || pg_catalog.array_to_string(ARRAY(SELECT "
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						  "  '(' || pg_catalog.array_to_string(ARRAY(SELECT "
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						  "  '(' || pg_catalog.array_to_string(ARRAY(SELECT "
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						  "  '(' || pg_catalog.array_to_string(ARRAY(SELECT "
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						  "pg_catalog.array_to_string(%s, E'\\n') AS \"%s\"",
/srvr/z5089358/postgresql-10.4/src/bin/psql/describe.c:						  "pg_catalog.array_to_string(%s, '\\n') AS \"%s\"",
Binary file /srvr/z5089358/postgresql-10.4/src/bin/psql/psql matches
/srvr/z5089358/postgresql-10.4/src/bin/psql/tab-complete.c:	/* selcondition --- ignore table rowtypes and array types */
/srvr/z5089358/postgresql-10.4/src/bin/psql/tab-complete.c:	/* This array will contain pointers to parsed words. */
/srvr/z5089358/postgresql-10.4/src/bin/psql/tab-complete.c: * the variable names array.
/srvr/z5089358/postgresql-10.4/src/bin/psql/tab-complete.c: * Returns a malloc'd array of character pointers that point into the malloc'd
/srvr/z5089358/postgresql-10.4/src/bin/psql/tab-complete.c: * data array returned to *buffer; caller must free() both of these when done.
/srvr/z5089358/postgresql-10.4/src/bin/psql/tab-complete.c: * return array.
/srvr/z5089358/postgresql-10.4/src/bin/psql/tab-complete.c:	 * Allocate an array of string pointers and a buffer to hold the strings
/srvr/z5089358/postgresql-10.4/src/bin/psql/command.c:		 * Position in the array matters when the dbname is a connection
/srvr/z5089358/postgresql-10.4/src/bin/psql/command.c:		 * array entries only.  Thus, user= in the connection string always
/srvr/z5089358/postgresql-10.4/src/bin/psql/command.c:		/* add array terminator */
/srvr/z5089358/postgresql-10.4/src/bin/psql/command.c:								  "array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, "
/srvr/z5089358/postgresql-10.4/src/bin/psql/command.c:					/* reloptions, if not an empty array "{}" */
/srvr/z5089358/postgresql-10.4/src/bin/psql/command.c:							psql_error("could not parse reloptions array\n");
Binary file /srvr/z5089358/postgresql-10.4/src/bin/psql/describe.o matches
/srvr/z5089358/postgresql-10.4/src/bin/psql/psqlscanslash.c: * integer for use as an array index.  If the signed char is negative,
/srvr/z5089358/postgresql-10.4/src/bin/psql/psqlscanslash.c:    YY_BUFFER_STATE * yy_buffer_stack; /**< Stack as an array. */
/srvr/z5089358/postgresql-10.4/src/bin/psql/psqlscanslash.c:		/* Extend the array by 50%, plus the number we really need. */
/srvr/z5089358/postgresql-10.4/src/bin/psql/crosstabview.c:	pivot_field *array_columns = NULL;
/srvr/z5089358/postgresql-10.4/src/bin/psql/crosstabview.c:	pivot_field *array_rows = NULL;
/srvr/z5089358/postgresql-10.4/src/bin/psql/crosstabview.c:	 * Second part: Generate sorted arrays from the AVL trees.
/srvr/z5089358/postgresql-10.4/src/bin/psql/crosstabview.c:	array_columns = (pivot_field *)
/srvr/z5089358/postgresql-10.4/src/bin/psql/crosstabview.c:	array_rows = (pivot_field *)
/srvr/z5089358/postgresql-10.4/src/bin/psql/crosstabview.c:	avlCollectFields(&piv_columns, piv_columns.root, array_columns, 0);
/srvr/z5089358/postgresql-10.4/src/bin/psql/crosstabview.c:	avlCollectFields(&piv_rows, piv_rows.root, array_rows, 0);
/srvr/z5089358/postgresql-10.4/src/bin/psql/crosstabview.c:		rankSort(num_columns, array_columns);
/srvr/z5089358/postgresql-10.4/src/bin/psql/crosstabview.c:						   num_columns, array_columns, field_for_columns,
/srvr/z5089358/postgresql-10.4/src/bin/psql/crosstabview.c:						   num_rows, array_rows, field_for_rows,
/srvr/z5089358/postgresql-10.4/src/bin/psql/crosstabview.c:	pg_free(array_columns);
/srvr/z5089358/postgresql-10.4/src/bin/psql/crosstabview.c:	pg_free(array_rows);
/srvr/z5089358/postgresql-10.4/src/bin/psql/crosstabview.c:			/* index into the cont.cells array */
/srvr/z5089358/postgresql-10.4/src/bin/psql/crosstabview.c: * Recursively extract node values into the names array, in sorted order with a
/srvr/z5089358/postgresql-10.4/src/bin/psql/crosstabview.c: * Return the next candidate offset to write into the names array.
/srvr/z5089358/postgresql-10.4/src/bin/psql/po/it.po:msgid "could not parse reloptions array\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/po/it.po:msgstr "interpretazione dell'array reloptions fallita\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/po/he.po:msgid "could not parse reloptions array\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/po/ja.po:msgid "could not parse reloptions array\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/po/tr.po:msgid "could not parse reloptions array\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/po/tr.po:msgstr "reloptions dizisi (array) ayrtrlamad\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/po/ko.po:msgid "could not parse reloptions array\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/po/ru.po:msgid "could not parse reloptions array\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/po/pt_BR.po:msgid "could not parse reloptions array\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/po/es.po:msgid "could not parse reloptions array\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/po/es.po:msgstr "no se pudo interpretar el array reloptions\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/po/sv.po:msgid "could not parse reloptions array\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/po/sv.po:msgstr "kunde inte parsa arrayen reloptions\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/po/pl.po:msgid "could not parse reloptions array\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/po/de.po:msgid "could not parse reloptions array\n"
/srvr/z5089358/postgresql-10.4/src/bin/psql/po/fr.po:msgid "could not parse reloptions array\n"
Binary file /srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dumpall matches
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/common.c: * them into findTableByOid() and friends.  For each of these arrays, we build
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/common.c: * a sorted-by-OID index array immediately after the objects are fetched,
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/common.c: * the object arrays themselves would be simpler, but it doesn't work because
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/common.c:/* This is an array of object identities, not actual DumpableObjects */
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/common.c: * Find a DumpableObject by OID, in a pre-sorted array of one type of object
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/common.c: * Build an index array of DumpableObject pointers, sorted by OID
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/common.c: * Build an array of pointers to all known dumpable objects
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/common.c:	/* Sort array in preparation for binary searches */
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/common.c: *	  parse a string of numbers delimited by spaces into a character array
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/common.c:parseOidArray(const char *str, Oid *array, int arraysize)
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/common.c:				if (argNum >= arraysize)
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/common.c:					write_msg(NULL, "could not parse numeric array \"%s\": too many numbers\n", str);
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/common.c:				array[argNum++] = atooid(temp);
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/common.c:				write_msg(NULL, "could not parse numeric array \"%s\": invalid character in number\n", str);
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/common.c:	while (argNum < arraysize)
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/common.c:		array[argNum++] = InvalidOid;
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/common.c: *	  takes in a string and a string array and the number of elements in the
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/common.c: * string array.
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/common.c: *	  returns the index if the string is somewhere in the array, -1 otherwise
Binary file /srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dumpall.o matches
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/t/002_pg_dump.pl:# dump_cmd is the pg_dump command to run, which is an array of
Binary file /srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_restore matches
Binary file /srvr/z5089358/postgresql-10.4/src/bin/pg_dump/common.o matches
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dumpall.c:static void makeAlterConfigCommand(PGconn *conn, const char *arrayitem,
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dumpall.c:						   "(SELECT pg_catalog.array_agg(acl) FROM (SELECT pg_catalog.unnest(coalesce(spcacl,pg_catalog.acldefault('t',spcowner))) AS acl "
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dumpall.c:						   "(SELECT pg_catalog.array_agg(acl) FROM (SELECT pg_catalog.unnest(pg_catalog.acldefault('t',spcowner)) AS acl "
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dumpall.c:						   "array_to_string(spcoptions, ', '),"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dumpall.c:						   "array_to_string(spcoptions, ', '),"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dumpall.c:						   "array_to_string(spcoptions, ', '),"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dumpall.c:						  "(SELECT pg_catalog.array_agg(acl ORDER BY acl::text COLLATE \"C\") FROM ( "
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dumpall.c:						  "(SELECT pg_catalog.array_agg(acl ORDER BY acl::text COLLATE \"C\") FROM ( "
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dumpall.c:makeAlterConfigCommand(PGconn *conn, const char *arrayitem,
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dumpall.c:	mine = pg_strdup(arrayitem);
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dumpall.c:	 * array; we mustn't re-quote them or we'll make a mess.  Variables that
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/parallel.h:	/* these arrays have numWorkers entries, one per worker: */
Binary file /srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump matches
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_backup_archiver.h:	/* arrays created after the TOC list is complete: */
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_backup.h:	bool	   *idWanted;		/* array showing which dump IDs to emit */
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_backup_archiver.c:	 * Prepare index arrays, so we can assume we have them throughout restore.
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_backup_archiver.c:	/* Allocate space for the 'wanted' array, and init it */
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_backup_archiver.c: * Build index arrays for the TOC list
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_backup_archiver.c: * The arrays are indexed by dump ID (so entry zero is unused).  Note that the
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_backup_archiver.c: * array entries run only up to maxDumpId.  We might see dependency dump IDs
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_backup_archiver.c: * beyond that (if the dump was partial); so always check the array bound
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_backup_archiver.c: * before trying to touch an array entry.
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_backup_archiver.c:			 * item's dump ID, so there should be a place for it in the array.
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_backup_archiver.c:	/* build index arrays if we didn't already */
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_backup_archiver.c: * 1. We build the revDeps[] arrays of incoming dependency dumpIds.
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_backup_archiver.c:	 * At this point we start to build the revDeps reverse-dependency arrays,
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_backup_archiver.c:	 * Allocate space for revDeps[] arrays, and reset nRevDeps so we can use
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_backup_archiver.c:	 * Build the revDeps[] arrays of incoming-dependency dumpIds.  This had
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_backup_archiver.c: * itself).  Record their dump IDs in the entry's lockDeps[] array.
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/dumputils.c:					  "(SELECT pg_catalog.array_agg(acl ORDER BY row_n) FROM "
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/dumputils.c:					  "(SELECT pg_catalog.array_agg(acl ORDER BY row_n) FROM "
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/dumputils.c:						  "(SELECT pg_catalog.array_agg(acl ORDER BY row_n) FROM "
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/dumputils.c:						  "(SELECT pg_catalog.array_agg(acl) FROM "
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:						  "\n    (array['%c', '%c', '%c', '%c', '%c', '%c'])\n",
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c: * If it's a table's rowtype or an autogenerated array type, we also apply a
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:	/* skip auto-generated array types */
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:		 * rules will do the same thing as they would for the array's base
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:							  "   pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(rolname) from pg_catalog.pg_roles WHERE oid = ANY(pol.polroles)), ', ') END AS polroles, "
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:							  "   pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(rolname) from pg_catalog.pg_roles WHERE oid = ANY(pol.polroles)), ', ') END AS polroles, "
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:				  "WARNING: could not parse subpublications array\n");
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:	Oid			pg_type_array_oid;
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:					  "SELECT typarray "
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:	pg_type_array_oid = atooid(PQgetvalue(upgrade_res, 0, PQfnumber(upgrade_res, "typarray")));
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:	if (OidIsValid(pg_type_array_oid))
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:							 "\n-- For binary upgrade, must preserve pg_type array oid\n");
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:						  "SELECT pg_catalog.binary_upgrade_set_next_array_pg_type_oid('%u'::pg_catalog.oid);\n\n",
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:						  pg_type_array_oid);
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:		/* Toast tables do not have pg_type array rows */
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:	int			i_isarray;
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:	 * we include even the built-in types because those may be used as array
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:	 * same approach for undefined (shell) types and array types
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:	 * auto-generated array type by checking the element type's typarray.
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:	 * be revisited if the backend ever allows renaming of array types.
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:						  "(SELECT typarray FROM pg_type te WHERE oid = t.typelem) = t.oid AS isarray "
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:						  "(SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray "
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:						  "(SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray "
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:						  "typname[0] = '_' AND typelem != 0 AS isarray "
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:	i_isarray = PQfnumber(res, "isarray");
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:		if (strcmp(PQgetvalue(res, i, i_isarray), "t") == 0)
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:						  "array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, "
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:						  "array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, "
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:						  "array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, "
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:						  "array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, "
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:					  "array_to_string(array("
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:		 * we will use the attnum to index into the attnames array later.
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:							  "array_to_string(a.attoptions, ', ') AS attoptions, "
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:							  "pg_catalog.array_to_string(ARRAY("
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:							  "array_to_string(a.attoptions, ', ') AS attoptions, "
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:							  "pg_catalog.array_to_string(ARRAY("
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:							  "array_to_string(a.attoptions, ', ') AS attoptions, "
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:							  "array_to_string(a.attoptions, ', ') AS attoptions, "
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:						  "array_to_string(ARRAY("
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:						  "array_to_string(ARRAY("
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:						  "array_to_string(ARRAY("
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:						  "array_to_string(ARRAY("
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:						  "array_to_string(ARRAY("
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:			/* table rowtypes and array types are never dumped separately */
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:		 * Note that we're pushing extconfig (an OID array) back into
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:					write_msg(NULL, "WARNING: bogus value in proargmodes array\n");
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:						  "array_to_string(protrftypes, ' ') AS protrftypes, "
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:						  "array_to_string(protrftypes, ' ') AS protrftypes, "
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:			write_msg(NULL, "WARNING: could not parse proallargtypes array\n");
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:			write_msg(NULL, "WARNING: could not parse proargmodes array\n");
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:			write_msg(NULL, "WARNING: could not parse proargnames array\n");
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:			write_msg(NULL, "WARNING: could not parse proconfig array\n");
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:		 * proconfig array; we mustn't re-quote them or we'll make a mess.
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:					  "array_to_string(ARRAY("
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:									  "pg_catalog.array_to_string(ARRAY("
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c: * The array tblInfo->attnames[] only provides names of user attributes;
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:		char	  **extconfigarray = NULL;
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:		char	  **extconditionarray = NULL;
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:		if (parsePGArray(extconfig, &extconfigarray, &nconfigitems) &&
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:			parsePGArray(extcondition, &extconditionarray, &nconditionitems) &&
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:				Oid			configtbloid = atooid(extconfigarray[j]);
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:						if (strlen(extconditionarray[j]) > 0)
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:							configtbl->dataObj->filtercond = pg_strdup(extconditionarray[j]);
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:		if (extconfigarray)
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:			free(extconfigarray);
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:		if (extconditionarray)
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:			free(extconditionarray);
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:		/* Set up work array */
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c: * Check if a reloptions array is nonempty.
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c: * Format a reloptions array and append it to the given buffer.
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.c:		write_msg(NULL, "WARNING: could not parse reloptions array\n");
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/parallel.c:/* Mnemonic macros for indexing the fd array returned by pipe(2) */
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.h:	bool		isArray;		/* true if auto-generated array type */
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.h:	struct _triggerInfo *triggers;	/* array of TriggerInfo structs */
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.h: * We build an array of these with an entry for each object that is an
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.h:extern void parseOidArray(const char *str, Oid *array, int arraysize);
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump_sort.c: * On success (TRUE result), ordering[] is filled with a sorted array of
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump_sort.c: * On failure (FALSE result), ordering[] is filled with an unsorted array of
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump_sort.c:	 * using 1-based array indexes, not 0-based.
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump_sort.c:	 * processed[] is a bool array indexed by dump ID, marking the objects
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump_sort.c:	 * searchFailed[] is another array indexed by dump ID.  searchFailed[j] is
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump_sort.c:	 * which is a common situation.  We could use a simple bool array for
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump_sort.c:	 * value lets us skip clearing the array before we consider the next start
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump_sort.c:	 * workspace[] is an array of DumpableObject pointers, in which we try to
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump_sort.c: *	processed[]: flag array marking already-processed objects
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump_sort.c: *	searchFailed[]: flag array marking already-unsuccessfully-visited objects
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump_sort.c: *	workspace[]: work array in which we are building list of loop members
Binary file /srvr/z5089358/postgresql-10.4/src/bin/pg_dump/dumputils.o matches
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/it.po:msgid "could not parse numeric array \"%s\": too many numbers\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/it.po:msgstr "non  stato possibile interpretare l'array numerico \"%s\": troppi numeri\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/it.po:msgid "could not parse numeric array \"%s\": invalid character in number\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/it.po:msgstr "non  stato possibile interpretare l'array numerico \"%s\": caratteri non validi nel numero\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/it.po:msgid "WARNING: could not parse subpublications array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/it.po:msgid "WARNING: bogus value in proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/it.po:msgstr "ATTENZIONE: valore errato nell'array proargmode\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/it.po:msgid "WARNING: could not parse proallargtypes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/it.po:msgstr "ATTENZIONE: non  stato possibile analizzare l'array proallargtype\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/it.po:msgid "WARNING: could not parse proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/it.po:msgstr "ATTENZIONE: non  stato possibile analizzare l'array proargmode\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/it.po:msgid "WARNING: could not parse proargnames array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/it.po:msgstr "ATTENZIONE: non  stato possibile analizzare l'array proargname\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/it.po:msgid "WARNING: could not parse proconfig array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/it.po:msgstr "ATTENZIONE: non  stato possibile analizzare l'array preconfig\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/it.po:msgid "WARNING: could not parse reloptions array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/it.po:msgstr "ATTENZIONE: errore di lettura dell'array reloptions\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/he.po:msgid "could not parse numeric array \"%s\": too many numbers\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/he.po:msgid "could not parse numeric array \"%s\": invalid character in number\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/he.po:msgid "WARNING: could not parse subpublications array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/he.po:msgid "WARNING: bogus value in proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/he.po:msgid "WARNING: could not parse proallargtypes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/he.po:msgid "WARNING: could not parse proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/he.po:msgid "WARNING: could not parse proargnames array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/he.po:msgid "WARNING: could not parse proconfig array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/he.po:msgid "WARNING: could not parse reloptions array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ja.po:msgid "could not parse numeric array \"%s\": too many numbers\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ja.po:msgid "could not parse numeric array \"%s\": invalid character in number\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ja.po:msgid "WARNING: could not parse subpublications array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ja.po:msgid "WARNING: bogus value in proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ja.po:msgid "WARNING: could not parse proallargtypes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ja.po:msgid "WARNING: could not parse proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ja.po:msgid "WARNING: could not parse proargnames array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ja.po:msgid "WARNING: could not parse proconfig array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ja.po:msgid "WARNING: could not parse reloptions array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/tr.po:msgid "could not parse numeric array \"%s\": too many numbers\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/tr.po:msgid "could not parse numeric array \"%s\": invalid character in number\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/tr.po:msgid "WARNING: could not parse subpublications array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/tr.po:msgid "WARNING: bogus value in proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/tr.po:msgid "WARNING: could not parse proallargtypes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/tr.po:msgid "WARNING: could not parse proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/tr.po:msgid "WARNING: could not parse proargnames array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/tr.po:msgid "WARNING: could not parse proconfig array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/tr.po:msgid "WARNING: could not parse reloptions array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/tr.po:#| msgid "WARNING: could not parse proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ko.po:msgid "could not parse numeric array \"%s\": too many numbers\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ko.po:msgid "could not parse numeric array \"%s\": invalid character in number\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ko.po:msgid "WARNING: could not parse subpublications array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ko.po:msgid "WARNING: bogus value in proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ko.po:msgid "WARNING: could not parse proallargtypes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ko.po:msgid "WARNING: could not parse proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ko.po:msgid "WARNING: could not parse proargnames array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ko.po:msgid "WARNING: could not parse proconfig array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ko.po:msgid "WARNING: could not parse reloptions array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/cs.po:msgid "could not parse numeric array \"%s\": too many numbers\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/cs.po:msgid "could not parse numeric array \"%s\": invalid character in number\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/cs.po:msgid "WARNING: bogus value in proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/cs.po:msgid "WARNING: could not parse proallargtypes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/cs.po:msgid "WARNING: could not parse proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/cs.po:msgid "WARNING: could not parse proargnames array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/cs.po:msgid "WARNING: could not parse proconfig array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ru.po:msgid "could not parse numeric array \"%s\": too many numbers\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ru.po:msgid "could not parse numeric array \"%s\": invalid character in number\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ru.po:msgid "WARNING: could not parse subpublications array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ru.po:msgid "WARNING: bogus value in proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ru.po:msgid "WARNING: could not parse proallargtypes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ru.po:msgid "WARNING: could not parse proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ru.po:msgid "WARNING: could not parse proargnames array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ru.po:msgid "WARNING: could not parse proconfig array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/ru.po:msgid "WARNING: could not parse reloptions array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/pt_BR.po:msgid "could not parse numeric array \"%s\": too many numbers\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/pt_BR.po:msgid "could not parse numeric array \"%s\": invalid character in number\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/pt_BR.po:msgid "WARNING: bogus value in proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/pt_BR.po:msgid "WARNING: could not parse proallargtypes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/pt_BR.po:msgid "WARNING: could not parse proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/pt_BR.po:msgid "WARNING: could not parse proargnames array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/pt_BR.po:msgid "WARNING: could not parse proconfig array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/pt_BR.po:msgid "WARNING: could not parse reloptions array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/es.po:msgid "could not parse numeric array \"%s\": too many numbers\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/es.po:msgid "could not parse numeric array \"%s\": invalid character in number\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/es.po:msgid "WARNING: could not parse subpublications array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/es.po:msgid "WARNING: bogus value in proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/es.po:msgid "WARNING: could not parse proallargtypes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/es.po:msgid "WARNING: could not parse proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/es.po:msgid "WARNING: could not parse proargnames array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/es.po:msgid "WARNING: could not parse proconfig array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/es.po:msgid "WARNING: could not parse reloptions array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/sv.po:msgid "could not parse numeric array \"%s\": too many numbers\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/sv.po:msgstr "kunde inte tolka numerisk array \"%s\": fr mnga nummer\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/sv.po:msgid "could not parse numeric array \"%s\": invalid character in number\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/sv.po:msgstr "kunde inte tolka numerisk array \"%s\": ogiltigt tecken i nummer\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/sv.po:msgid "WARNING: could not parse subpublications array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/sv.po:msgstr "VARNING: kunde inte parsa arrayen fr subpubliceringar\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/sv.po:msgid "WARNING: bogus value in proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/sv.po:msgstr "VARNING: felaktigt vrde i arrayen proargmodes\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/sv.po:msgid "WARNING: could not parse proallargtypes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/sv.po:msgstr "VARNING: kunde inte tolka arrayen proallargtypes\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/sv.po:msgid "WARNING: could not parse proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/sv.po:msgstr "VARNING: kunde inte tolka arrayen proargmodes\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/sv.po:msgid "WARNING: could not parse proargnames array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/sv.po:msgstr "VARNING: kunde inte tolka arrayen proargnames\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/sv.po:msgid "WARNING: could not parse proconfig array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/sv.po:msgstr "VARNING: kunde inte tolka arrayen proconfig\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/sv.po:msgid "WARNING: could not parse reloptions array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/sv.po:msgstr "VARNING: kunde inte parsa arrayen reloptions\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/pl.po:msgid "could not parse numeric array \"%s\": too many numbers\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/pl.po:msgid "could not parse numeric array \"%s\": invalid character in number\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/pl.po:msgid "WARNING: could not parse subpublications array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/pl.po:msgid "WARNING: bogus value in proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/pl.po:msgid "WARNING: could not parse proallargtypes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/pl.po:msgid "WARNING: could not parse proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/pl.po:msgid "WARNING: could not parse proargnames array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/pl.po:msgid "WARNING: could not parse proconfig array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/pl.po:msgid "WARNING: could not parse reloptions array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/de.po:msgid "could not parse numeric array \"%s\": too many numbers\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/de.po:msgid "could not parse numeric array \"%s\": invalid character in number\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/de.po:msgid "WARNING: could not parse subpublications array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/de.po:msgid "WARNING: bogus value in proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/de.po:msgid "WARNING: could not parse proallargtypes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/de.po:msgid "WARNING: could not parse proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/de.po:msgid "WARNING: could not parse proargnames array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/de.po:msgid "WARNING: could not parse proconfig array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/de.po:msgid "WARNING: could not parse reloptions array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/zh_CN.po:msgid "could not parse numeric array \"%s\": too many numbers\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/zh_CN.po:msgid "could not parse numeric array \"%s\": invalid character in number\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/zh_CN.po:msgid "WARNING: bogus value in proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/zh_CN.po:msgid "WARNING: could not parse proallargtypes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/zh_CN.po:msgid "WARNING: could not parse proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/zh_CN.po:msgid "WARNING: could not parse proargnames array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/zh_CN.po:msgid "WARNING: could not parse proconfig array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/zh_CN.po:#| msgid "WARNING: could not parse proconfig array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/zh_CN.po:msgid "WARNING: could not parse reloptions array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/fr.po:msgid "could not parse numeric array \"%s\": too many numbers\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/fr.po:msgid "could not parse numeric array \"%s\": invalid character in number\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/fr.po:msgid "WARNING: could not parse subpublications array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/fr.po:msgid "WARNING: bogus value in proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/fr.po:msgid "WARNING: could not parse proallargtypes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/fr.po:msgid "WARNING: could not parse proargmodes array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/fr.po:msgid "WARNING: could not parse proargnames array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/fr.po:msgid "WARNING: could not parse proconfig array\n"
/srvr/z5089358/postgresql-10.4/src/bin/pg_dump/po/fr.po:msgid "WARNING: could not parse reloptions array\n"
Binary file /srvr/z5089358/postgresql-10.4/src/bin/pg_dump/pg_dump.o matches
/srvr/z5089358/postgresql-10.4/src/bin/pg_upgrade/tablespace.c: * Scans pg_tablespace and returns a malloc'ed array of all tablespace
/srvr/z5089358/postgresql-10.4/src/bin/pg_upgrade/tablespace.c: * paths. Its the caller's responsibility to free the array.
/srvr/z5089358/postgresql-10.4/src/bin/pg_upgrade/pg_upgrade.h:	RelInfoArr	rel_arr;		/* array of all user relinfos */
/srvr/z5089358/postgresql-10.4/src/bin/pg_upgrade/pg_upgrade.h:	DbInfo	   *dbs;			/* array of db infos */
/srvr/z5089358/postgresql-10.4/src/bin/pg_upgrade/pg_upgrade.h:	DbInfoArr	dbarr;			/* dbinfos array */
/srvr/z5089358/postgresql-10.4/src/bin/pg_upgrade/file.c:	 * Malloc the work buffers, rather than making them local arrays, to
Binary file /srvr/z5089358/postgresql-10.4/src/bin/pg_upgrade/pg_upgrade matches
/srvr/z5089358/postgresql-10.4/src/bin/pg_upgrade/parallel.c: *	it can be passed to WaitForMultipleObjects().  We use two arrays
/srvr/z5089358/postgresql-10.4/src/bin/pg_upgrade/parallel.c: *	so the thread_handles array can be passed to WaitForMultipleObjects().
/srvr/z5089358/postgresql-10.4/src/bin/pg_upgrade/parallel.c:		/* empty array element are always at the end */
/srvr/z5089358/postgresql-10.4/src/bin/pg_upgrade/parallel.c:		/* empty array element are always at the end */
/srvr/z5089358/postgresql-10.4/src/bin/pg_upgrade/parallel.c:		 * struct pointers within the array.
/srvr/z5089358/postgresql-10.4/src/bin/pg_upgrade/info.c: * Returns a malloc'ed array of mappings.  The length of the array
/srvr/z5089358/postgresql-10.4/src/bin/pg_upgrade/info.c:	 * Each of the RelInfo arrays should be sorted by OID.  Scan through them
/srvr/z5089358/postgresql-10.4/src/bin/pg_upgrade/info.c:		/* handle running off one array before the other */
/srvr/z5089358/postgresql-10.4/src/bin/pg_upgrade/info.c: * Note: the resulting RelInfo array is assumed to be sorted by OID.
/srvr/z5089358/postgresql-10.4/src/bin/pg_upgrade/relfilenode.c: * create links for mappings stored in "maps" array.
/srvr/z5089358/postgresql-10.4/src/bin/pg_upgrade/function.c:	 * First transfer all the names into one array, then sort, then remove
Binary file /srvr/z5089358/postgresql-10.4/src/bin/pg_ctl/pg_ctl matches
Binary file /srvr/z5089358/postgresql-10.4/src/bin/pg_config/pg_config matches
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/timeline.c: * return a malloc'd array and to work without backend functions.
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.h:	 * are moved to this array. After processing local files, too, all the
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.h:	 * local entries are added to the array by filemap_finalize, and sorted in
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.h:	 * array, and the linked list is empty.
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.h:	file_entry_t **array;
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.h:	int			narray;			/* current length of array */
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/parsexlog.c: * RmgrNames is an array of resource manager names, to make error messages
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/libpq_fetch.c:	for (i = 0; i < map->narray; i++)
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/libpq_fetch.c:		entry = map->array[i];
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/copy_fetch.c:	for (i = 0; i < map->narray; i++)
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/copy_fetch.c:		entry = map->array[i];
Binary file /srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/pg_rewind matches
Binary file /srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.o matches
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:static void filemap_list_to_array(filemap_t *map);
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:	map->array = NULL;
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:	map->narray = 0;
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:	Assert(map->array == NULL);
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:	if (map->array == NULL)
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:		/* on first call, initialize lookup array */
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:		filemap_list_to_array(map);
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:		Assert(map->array != NULL);
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:		qsort(map->array, map->narray, sizeof(file_entry_t *), path_cmp);
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:	exists = (bsearch(&key_ptr, map->array, map->narray, sizeof(file_entry_t *),
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:	Assert(map->array);
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:	e = bsearch(&key_ptr, map->array, map->narray, sizeof(file_entry_t *),
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c: * Convert the linked list of entries in map->first/last to the array,
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c: * map->array.
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:filemap_list_to_array(filemap_t *map)
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:	int			narray;
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:	map->array = (file_entry_t **)
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:		pg_realloc(map->array,
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:				   (map->nlist + map->narray) * sizeof(file_entry_t *));
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:	narray = map->narray;
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:		map->array[narray++] = entry;
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:	Assert(narray == map->nlist + map->narray);
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:	map->narray = narray;
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:	filemap_list_to_array(map);
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:	qsort(map->array, map->narray, sizeof(file_entry_t *),
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:	for (i = 0; i < map->narray; i++)
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:		entry = map->array[i];
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:	for (i = 0; i < map->narray; i++)
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/filemap.c:		entry = map->array[i];
/srvr/z5089358/postgresql-10.4/src/bin/pg_rewind/pg_rewind.c: * index of last common timeline in targetHistory array, and *recptr is set to
Binary file /srvr/z5089358/postgresql-10.4/src/bin/pg_test_fsync/pg_test_fsync matches
Binary file /srvr/z5089358/postgresql-10.4/src/bin/pg_basebackup/pg_recvlogical matches
Binary file /srvr/z5089358/postgresql-10.4/src/bin/pg_basebackup/pg_receivewal matches
Binary file /srvr/z5089358/postgresql-10.4/src/bin/pg_basebackup/pg_basebackup matches
Binary file /srvr/z5089358/postgresql-10.4/src/bin/pg_controldata/pg_controldata matches
/srvr/z5089358/postgresql-10.4/src/fe_utils/mbprint.c: *	lines[i].ptr == NULL indicates the end of the array.
/srvr/z5089358/postgresql-10.4/src/fe_utils/mbprint.c:	(lines + 1)->ptr = NULL;	/* terminate line array */
/srvr/z5089358/postgresql-10.4/src/fe_utils/psqlscan.c: * integer for use as an array index.  If the signed char is negative,
/srvr/z5089358/postgresql-10.4/src/fe_utils/psqlscan.c:    YY_BUFFER_STATE * yy_buffer_stack; /**< Stack as an array. */
/srvr/z5089358/postgresql-10.4/src/fe_utils/psqlscan.c:		/* Extend the array by 50%, plus the number we really need. */
/srvr/z5089358/postgresql-10.4/src/fe_utils/string_utils.c: * Deconstruct the text representation of a 1-dimensional Postgres array
/srvr/z5089358/postgresql-10.4/src/fe_utils/string_utils.c: * On success, returns true and sets *itemarray and *nitems to describe
/srvr/z5089358/postgresql-10.4/src/fe_utils/string_utils.c: * an array of individual strings.  On parse failure, returns false;
/srvr/z5089358/postgresql-10.4/src/fe_utils/string_utils.c: * *itemarray may exist or be NULL.
/srvr/z5089358/postgresql-10.4/src/fe_utils/string_utils.c: * NOTE: free'ing itemarray is sufficient to deallocate the working storage.
/srvr/z5089358/postgresql-10.4/src/fe_utils/string_utils.c:parsePGArray(const char *atext, char ***itemarray, int *nitems)
/srvr/z5089358/postgresql-10.4/src/fe_utils/string_utils.c:	 * We build the result as an array of pointers followed by the actual
/srvr/z5089358/postgresql-10.4/src/fe_utils/string_utils.c:	*itemarray = NULL;
/srvr/z5089358/postgresql-10.4/src/fe_utils/string_utils.c:	*itemarray = items;
/srvr/z5089358/postgresql-10.4/src/fe_utils/string_utils.c: * Format a reloptions array and append it to the given buffer.
/srvr/z5089358/postgresql-10.4/src/fe_utils/string_utils.c: * Returns false if the reloptions array could not be parsed (in which case
/srvr/z5089358/postgresql-10.4/src/fe_utils/string_utils.c:		 * Each array element should have the form name=value.  If the "=" is
/srvr/z5089358/postgresql-10.4/src/fe_utils/print.c:		/* Add entry for ptr == NULL array termination */
/srvr/z5089358/postgresql-10.4/src/fe_utils/print.c:				/* We have a valid array element, so index it */
/srvr/z5089358/postgresql-10.4/src/tools/pginclude/pgcheckdefines:# Build arrays of all the .c and .h files in the tree
/srvr/z5089358/postgresql-10.4/src/tools/msvc/Install.pm:		# Hash-of-arrays listing where to install things.  For each
/srvr/z5089358/postgresql-10.4/src/tools/msvc/Install.pm:		# subdirectory there's a hash key, and the value is an array
/srvr/z5089358/postgresql-10.4/src/tools/msvc/ecpg_regression.proj:  <CreateProperty Value="-c" Condition="'%(Pgc.FileName)'=='array_of_struct'">
/srvr/z5089358/postgresql-10.4/src/tools/findoidjoins/README:Join pg_catalog.pg_type.typarray => pg_catalog.pg_type.oid
/srvr/z5089358/postgresql-10.4/src/tools/findoidjoins/findoidjoins.c:	/* Now, do the same for referencing columns that are arrays */
/srvr/z5089358/postgresql-10.4/src/tools/findoidjoins/findoidjoins.c:	/* Get a list of columns of OID-array type (or any OID-alias type) */
/srvr/z5089358/postgresql-10.4/src/tools/pgindent/typedefs.list:PLpgSQL_arrayelem
/srvr/z5089358/postgresql-10.4/src/tools/pgindent/typedefs.list:array_iter
/srvr/z5089358/postgresql-10.4/src/tools/pgindent/typedefs.list:array_unnest_fctx
/srvr/z5089358/postgresql-10.4/src/tools/pgindent/typedefs.list:plperl_array_info
/srvr/z5089358/postgresql-10.4/src/port/getopt.c: * it can be restarted on a new argv array after a previous call returned -1,
/srvr/z5089358/postgresql-10.4/src/port/getopt_long.c: * it can be restarted on a new argv array after a previous call returned -1,
/srvr/z5089358/postgresql-10.4/src/port/inet_net_ntop.c:	 * Preprocess: Copy the input (bytewise) array into a wordwise array. Find
/srvr/z5089358/postgresql-10.4/src/port/crypt.c: * representation is to store one bit per byte in an array of bytes.  Bit N of
/srvr/z5089358/postgresql-10.4/src/port/crypt.c: * the NBS spec is stored as the LSB of the Nth byte (index N-1) in the array.
/srvr/z5089358/postgresql-10.4/src/port/crypt.c: * (perhaps with expansion and/or contraction) one packed array of bits
/srvr/z5089358/postgresql-10.4/src/port/crypt.c: * (of size "chars_in" characters) into another array (of size "chars_out"
/srvr/z5089358/postgresql-10.4/src/pl/tcl/sql/pltcl_setup.sql:		if { [array exists $key] } {
/srvr/z5089358/postgresql-10.4/src/pl/tcl/sql/pltcl_setup.sql:			foreach akey [lsort [ array names $key ] ] {
/srvr/z5089358/postgresql-10.4/src/pl/tcl/sql/pltcl_setup.sql:    return [array get NEW]
/srvr/z5089358/postgresql-10.4/src/pl/tcl/sql/pltcl_setup.sql:-- We use split(n) as a quick-and-dirty way of parsing the input array
/srvr/z5089358/postgresql-10.4/src/pl/tcl/sql/pltcl_setup.sql:        array set myArray $::errorCode
/srvr/z5089358/postgresql-10.4/src/pl/tcl/sql/pltcl_setup.sql:        foreach {key} [lsort [array names myArray]] {
/srvr/z5089358/postgresql-10.4/src/pl/tcl/sql/pltcl_setup.sql:-- test spi_exec and spi_execp with -array
/srvr/z5089358/postgresql-10.4/src/pl/tcl/sql/pltcl_setup.sql:    spi_execp -array A $prep {
/srvr/z5089358/postgresql-10.4/src/pl/tcl/sql/pltcl_setup.sql:    spi_exec -array A $query {
/srvr/z5089358/postgresql-10.4/src/pl/tcl/sql/pltcl_unicode.sql:  return [array get NEW]
/srvr/z5089358/postgresql-10.4/src/pl/tcl/sql/pltcl_queries.sql:select tcl_eval('spi_exec -array');
/srvr/z5089358/postgresql-10.4/src/pl/tcl/sql/pltcl_queries.sql:select tcl_eval('spi_execp -array');
/srvr/z5089358/postgresql-10.4/src/pl/tcl/sql/pltcl_queries.sql:  spi_exec -array C "SELECT id, name FROM old_table" {
/srvr/z5089358/postgresql-10.4/src/pl/tcl/sql/pltcl_queries.sql:  spi_exec -array C "SELECT id, name FROM new_table" {
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltclerrcodes.h:	"array_subscript_error", ERRCODE_ARRAY_SUBSCRIPT_ERROR
/srvr/z5089358/postgresql-10.4/src/pl/tcl/expected/pltcl_setup.out:		if { [array exists $key] } {
/srvr/z5089358/postgresql-10.4/src/pl/tcl/expected/pltcl_setup.out:			foreach akey [lsort [ array names $key ] ] {
/srvr/z5089358/postgresql-10.4/src/pl/tcl/expected/pltcl_setup.out:    return [array get NEW]
/srvr/z5089358/postgresql-10.4/src/pl/tcl/expected/pltcl_setup.out:-- We use split(n) as a quick-and-dirty way of parsing the input array
/srvr/z5089358/postgresql-10.4/src/pl/tcl/expected/pltcl_setup.out:        array set myArray $::errorCode
/srvr/z5089358/postgresql-10.4/src/pl/tcl/expected/pltcl_setup.out:        foreach {key} [lsort [array names myArray]] {
/srvr/z5089358/postgresql-10.4/src/pl/tcl/expected/pltcl_setup.out:-- test spi_exec and spi_execp with -array
/srvr/z5089358/postgresql-10.4/src/pl/tcl/expected/pltcl_setup.out:    spi_execp -array A $prep {
/srvr/z5089358/postgresql-10.4/src/pl/tcl/expected/pltcl_setup.out:    spi_exec -array A $query {
/srvr/z5089358/postgresql-10.4/src/pl/tcl/expected/pltcl_unicode.out:  return [array get NEW]
/srvr/z5089358/postgresql-10.4/src/pl/tcl/expected/pltcl_queries.out:ERROR:  wrong # args: should be "spi_exec ?-count n? ?-array name? query ?loop body?"
/srvr/z5089358/postgresql-10.4/src/pl/tcl/expected/pltcl_queries.out:ERROR:  missing argument to -count or -array
/srvr/z5089358/postgresql-10.4/src/pl/tcl/expected/pltcl_queries.out:select tcl_eval('spi_exec -array');
/srvr/z5089358/postgresql-10.4/src/pl/tcl/expected/pltcl_queries.out:ERROR:  missing argument to -count or -array
/srvr/z5089358/postgresql-10.4/src/pl/tcl/expected/pltcl_queries.out:ERROR:  missing argument to -count or -array
/srvr/z5089358/postgresql-10.4/src/pl/tcl/expected/pltcl_queries.out:ERROR:  missing argument to -array, -count or -nulls
/srvr/z5089358/postgresql-10.4/src/pl/tcl/expected/pltcl_queries.out:select tcl_eval('spi_execp -array');
/srvr/z5089358/postgresql-10.4/src/pl/tcl/expected/pltcl_queries.out:ERROR:  missing argument to -array, -count or -nulls
/srvr/z5089358/postgresql-10.4/src/pl/tcl/expected/pltcl_queries.out:ERROR:  missing argument to -array, -count or -nulls
/srvr/z5089358/postgresql-10.4/src/pl/tcl/expected/pltcl_queries.out:  spi_exec -array C "SELECT id, name FROM old_table" {
/srvr/z5089358/postgresql-10.4/src/pl/tcl/expected/pltcl_queries.out:  spi_exec -array C "SELECT id, name FROM new_table" {
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:	/* these arrays have nargs entries: */
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:						 const char *arrayname,
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:static void pltcl_set_tuple_values(Tcl_Interp *interp, const char *arrayname,
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:				 * For tuple values, add a list for 'array set ...'
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:	 * the magic strings OK or SKIP, or a list from array get.
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:							  "array set NEW $__PLTcl_Tup_NEW\n", -1);
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:							  "array set OLD $__PLTcl_Tup_OLD\n", -1);
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:							 "array set %d $__PLTcl_Tup_%d\n",
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:	const char *volatile arrayname = NULL;
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:		"-array", "-count", (const char *) NULL
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:						 "?-count n? ?-array name? query ?loop body?");
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:							 Tcl_NewStringObj("missing argument to -count or -array", -1));
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:				arrayname = Tcl_GetString(objv[i++]);
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:										 arrayname,
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:						 const char *arrayname,
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:					pltcl_set_tuple_values(interp, arrayname, 0,
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:					pltcl_set_tuple_values(interp, arrayname, i,
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:	const char *arrayname = NULL;
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:		"-array", "-count", "-nulls", (const char *) NULL
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:							 Tcl_NewStringObj("missing argument to -array, -count or -nulls", -1));
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:				arrayname = Tcl_GetString(objv[i++]);
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:						 Tcl_NewStringObj("missing argument to -count or -array", -1));
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:						 "?-count n? ?-array name? ?-nulls string? "
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:		 * Setup the value array for SPI_execute_plan() using
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:										 arrayname,
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c: * Note: arrayname is presumed to be UTF8; it usually came from Tcl
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:pltcl_set_tuple_values(Tcl_Interp *interp, const char *arrayname,
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:	if (arrayname == NULL)
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:		arrptr = &arrayname;
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:		 * When outputting to an array, fill the ".tupno" element with the
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c:		Tcl_SetVar2Ex(interp, arrayname, ".tupno", Tcl_NewWideIntObj(tupno), 0);
/srvr/z5089358/postgresql-10.4/src/pl/tcl/pltcl.c: * pltcl_build_tuple_argument() - Build a list object usable for 'array set'
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_gram.y:						PLpgSQL_arrayelem	*new;
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_gram.y:						new = palloc0(sizeof(PLpgSQL_arrayelem));
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_gram.y:						new->arrayparentno = $1->dno;
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_gram.y:						 * that is an array element, but for now we don't, so
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_gram.y:		/* Check for array overflow */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_funcs.c:			return _("FOREACH over array");
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_funcs.c:				free_expr(((PLpgSQL_arrayelem *) d)->subscript);
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_funcs.c:					   ((PLpgSQL_arrayelem *) d)->arrayparentno);
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_funcs.c:				dump_expr(((PLpgSQL_arrayelem *) d)->subscript);
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_scanner.c: * We keep reserved and unreserved keywords in separate arrays.  The
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_scanner.c:	PG_KEYWORD("array", K_ARRAY, UNRESERVED_KEYWORD)
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/plpgsql.h: * Datum array node types
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/plpgsql.h:	bool		typisarray;		/* is "true" array, or domain over one */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/plpgsql.h: * Generic datum array item
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/plpgsql.h: * PLpgSQL_row, PLpgSQL_rec, PLpgSQL_recfield, and PLpgSQL_arrayelem
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/plpgsql.h: * Element of array variable
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/plpgsql.h:typedef struct PLpgSQL_arrayelem
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/plpgsql.h:	int			arrayparentno;	/* dno of parent array variable */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/plpgsql.h:	/* Remaining fields are cached info about the array variable's type */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/plpgsql.h:	Oid			parenttypoid;	/* type of array variable; 0 if not yet set */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/plpgsql.h:	int32		parenttypmod;	/* typmod of array variable */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/plpgsql.h:	Oid			arraytypoid;	/* OID of actual array type */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/plpgsql.h:	int32		arraytypmod;	/* typmod of array (and its elements too) */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/plpgsql.h:	int16		arraytyplen;	/* typlen of array type */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/plpgsql.h:	Oid			elemtypoid;		/* OID of array element type */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/plpgsql.h:} PLpgSQL_arrayelem;
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/plpgsql.h: * FOREACH item in array loop
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/plpgsql.h:	PLpgSQL_expr *expr;			/* array expression */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_comp.c:				/* Remember arguments in appropriate arrays */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_comp.c: * plpgsql_build_variable - build a datum-array entry of a given
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_comp.c: * array, and optionally to the current namespace.
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_comp.c:	/* Detect if type is true array, or domain thereof */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_comp.c:	/* NB: this is only used to decide whether to apply expand_array */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_comp.c:		 * disallow non-toastable array types (i.e. oidvector and int2vector).
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_comp.c:		typ->typisarray = (typeStruct->typlen == -1 &&
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_comp.c:		typ->typisarray = (typeStruct->typlen == -1 &&
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_comp.c:		typ->typisarray = false;
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_comp.c: * plpgsql_add_initdatums		Make an array of the datum numbers of
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_comp.c: * are integer, integer-array or integer-range.  Also, we go ahead and report
Binary file /srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/plpgsql.so matches
Binary file /srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.o matches
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					 * Force any array-valued parameter to be stored in
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					 * a hack, really: why only arrays? Need more thought
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					 * typisarray-specific heuristic in exec_assign_value.)
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					if (!var->isnull && var->datatype->typisarray)
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:							/* flat array, so force to expanded form */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:											  expand_array(var->value,
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:		 * So we can't use construct_array().
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:						  PointerGetDatum(construct_md_array(elems, NULL,
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c: * exec_stmt_foreach_a			Loop over elements or slices of an array
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c: * array stores (eg: integer), when looping through slices, the loop variable
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c: * is an array of size and dimensions to match the size of the slice.
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:	ArrayIterator array_iterator;
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:	/* get the value of the array expression */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:	/* check the type of the expression - must be an array */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				 errmsg("FOREACH expression must yield an array, not type %s",
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:	 * We must copy the array into stmt_mcontext, else it will disappear in
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:	/* Slice dimension must be less than or equal to array dimension */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:	/* Set up the loop variable and see if it is of an array type */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:		 * Record/row variable is certainly not of array type, and might not
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:	 * if the array-ness of the loop variable is not right.
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				 errmsg("FOREACH ... SLICE loop variable must be of an array type")));
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				 errmsg("FOREACH loop variable must not be of an array type")));
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:	/* Create an iterator to step through the array */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:	array_iterator = array_create_iterator(arr, stmt->slice, NULL);
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:		/* When slicing, nominal type of result is same as array type */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:		/* Without slicing, results are individual array elements */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:	/* Iterate over the array elements or slices */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:	while (array_iterate(array_iterator, &value, &isnull))
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:	/* Release temporary memory, including the array value */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:	/* caller is expected to fill the datums array */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				 * If it's an array, we force the value to be stored in R/W
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				 * a lot of array subscripting operations on the variable, and
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				 * cases where it'd be useful to force non-array values into
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					if (var->datatype->typisarray &&
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:						/* array and not already R/W, so apply expand_array */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:						newvalue = expand_array(newvalue,
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				 * Target is an element of an array
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				PLpgSQL_arrayelem *arrayelem;
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				Datum		oldarraydatum,
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:							newarraydatum,
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				bool		oldarrayisnull;
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				 * be prepared to deal with a chain of arrayelem datums. Chase
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				 * back to find the base array datum, and save the subscript
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				 * minimize surprises.)  Note that arrayelem is left pointing
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				 * to the leftmost arrayelem datum, where we will cache the
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				 * array element type data.
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					arrayelem = (PLpgSQL_arrayelem *) target;
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:								 errmsg("number of array dimensions (%d) exceeds the maximum allowed (%d)",
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					subscripts[nsubscripts++] = arrayelem->subscript;
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					target = estate->datums[arrayelem->arrayparentno];
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				/* Fetch current value of array datum */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:								&oldarraydatum, &oldarrayisnull);
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				if (arrayelem->parenttypoid != parenttypoid ||
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					arrayelem->parenttypmod != parenttypmod)
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					Oid			arraytypoid;
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					int32		arraytypmod = parenttypmod;
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					int16		arraytyplen;
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					/* If target is domain over array, reduce to base type */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					arraytypoid = getBaseTypeAndTypmod(parenttypoid,
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:													   &arraytypmod);
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					elemtypoid = get_element_type(arraytypoid);
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:								 errmsg("subscripted object is not an array")));
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					arraytyplen = get_typlen(arraytypoid);
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					arrayelem->parenttypoid = parenttypoid;
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					arrayelem->parenttypmod = parenttypmod;
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					arrayelem->arraytypoid = arraytypoid;
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					arrayelem->arraytypmod = arraytypmod;
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					arrayelem->arraytyplen = arraytyplen;
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					arrayelem->elemtypoid = elemtypoid;
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					arrayelem->elemtyplen = elemtyplen;
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					arrayelem->elemtypbyval = elemtypbyval;
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					arrayelem->elemtypalign = elemtypalign;
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:								 errmsg("array subscript in assignment must not be null")));
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				/* Coerce source value to match array element type. */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:												arrayelem->elemtypoid,
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:												arrayelem->arraytypmod);
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				 * If the original array is null, cons up an empty array so
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				 * one-element array containing just the assigned-to
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				 * subscript.  This only works for varlena arrays, though; for
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				 * fixed-length array types we skip the assignment.  We can't
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				 * array, either, so that's a no-op too.  This is all ugly but
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				if (arrayelem->arraytyplen > 0 &&	/* fixed-length array? */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					(oldarrayisnull || isNull))
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				/* empty array, if any, and newarraydatum are short-lived */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				if (oldarrayisnull)
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:					oldarraydatum = PointerGetDatum(construct_empty_array(arrayelem->elemtypoid));
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				 * Build the modified array value.
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				newarraydatum = array_set_element(oldarraydatum,
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:												  arrayelem->arraytyplen,
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:												  arrayelem->elemtyplen,
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:												  arrayelem->elemtypbyval,
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:												  arrayelem->elemtypalign);
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				 * Assign the new array to the base variable.  It's never NULL
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:				 * coercing the base array type back up to the domain will
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:								  newarraydatum,
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:								  arrayelem->arraytypoid,
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:								  arrayelem->arraytypmod);
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c: * At present this doesn't handle PLpgSQL_expr or PLpgSQL_arrayelem datums;
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c: * an array value to be subscripted.)
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c: * We share a single ParamListInfo array across all SPI calls made from this
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c: * object pointer.  A shared array is generally OK since any given slot in
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c: * the array would need to contain the same current datum value no matter
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c: * When creating a cursor, we do not use the shared ParamListInfo array
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c:		 * We need to mark the shared params array dirty if we're about to
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_exec.c: * If we have an assignment like "x := array_append(x, foo)" in which the
Binary file /srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_scanner.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_comp.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_funcs.o matches
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_gram.c:/* The size of an array large to enough to hold all stacks, each with
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_gram.c:						PLpgSQL_arrayelem	*new;
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_gram.c:						new = palloc0(sizeof(PLpgSQL_arrayelem));
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_gram.c:						new->arrayparentno = (yyvsp[-2].datum)->dno;
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_gram.c:						 * that is an array element, but for now we don't, so
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/pl_gram.c:		/* Check for array overflow */
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/plerrcodes.h:	"array_subscript_error", ERRCODE_ARRAY_SUBSCRIPT_ERROR
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/zh_TW.po:msgid "FOREACH expression must yield an array, not type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/zh_TW.po:msgid "FOREACH ... SLICE loop variable must be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/zh_TW.po:msgid "FOREACH loop variable must not be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/zh_TW.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/zh_TW.po:msgid "subscripted object is not an array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/zh_TW.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/zh_TW.po:msgid "FOREACH over array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/it.po:msgid "FOREACH expression must yield an array, not type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/it.po:msgstr "l'espressione FOREACH deve generare un array, non il tipo %s"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/it.po:msgid "FOREACH ... SLICE loop variable must be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/it.po:msgstr "la variabile del ciclo FOREACH ... SLICE dev'essere di tipo array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/it.po:msgid "FOREACH loop variable must not be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/it.po:msgstr "la variabile di ciclo FOREACH non pu essere un tipo array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/it.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/it.po:msgstr "il numero di dimensioni dell'array (%d) eccede il massimo consentito (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/it.po:msgid "subscripted object is not an array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/it.po:msgstr "l'oggetto del quale  stato richiesto un elemento non  un array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/it.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/it.po:msgstr "l'indice di un array nell'assegnamento non pu essere nullo"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/it.po:msgid "FOREACH over array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/it.po:msgstr "FOREACH su array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ja.po:msgid "FOREACH expression must yield an array, not type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ja.po:msgid "FOREACH ... SLICE loop variable must be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ja.po:msgid "FOREACH loop variable must not be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ja.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ja.po:msgid "subscripted object is not an array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ja.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ja.po:msgid "FOREACH over array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/tr.po:msgid "FOREACH expression must yield an array, not type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/tr.po:msgstr "FOREACH ifadesi %s deil bir dizi (array) salamal"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/tr.po:msgid "FOREACH ... SLICE loop variable must be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/tr.po:msgstr "FOREACH ... SLICE dng deikeni bir dizi (array) tipinde olmal"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/tr.po:msgid "FOREACH loop variable must not be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/tr.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/tr.po:msgid "subscripted object is not an array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/tr.po:msgstr "subscript edilen nesne bir dizi (array) deil"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/tr.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/tr.po:msgstr "atamada array subscript null olamaz"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/tr.po:msgid "FOREACH over array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ko.po:msgid "FOREACH expression must yield an array, not type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ko.po:msgid "FOREACH ... SLICE loop variable must be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ko.po:msgid "FOREACH loop variable must not be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ko.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ko.po:msgid "subscripted object is not an array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ko.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ko.po:msgid "FOREACH over array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/cs.po:msgid "FOREACH expression must yield an array, not type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/cs.po:msgid "FOREACH ... SLICE loop variable must be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/cs.po:msgid "FOREACH loop variable must not be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/cs.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/cs.po:msgid "subscripted object is not an array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/cs.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/cs.po:msgid "FOREACH over array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ru.po:msgid "FOREACH expression must yield an array, not type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ru.po:msgid "FOREACH ... SLICE loop variable must be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ru.po:msgid "FOREACH loop variable must not be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ru.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ru.po:msgid "subscripted object is not an array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ru.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ru.po:msgid "FOREACH over array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/pt_BR.po:msgid "FOREACH expression must yield an array, not type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/pt_BR.po:msgid "FOREACH ... SLICE loop variable must be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/pt_BR.po:msgid "FOREACH loop variable must not be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/pt_BR.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/pt_BR.po:msgid "subscripted object is not an array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/pt_BR.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/pt_BR.po:msgid "FOREACH over array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/es.po:msgid "FOREACH expression must yield an array, not type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/es.po:msgstr "una expresin FOREACH debe retornar un array, no tipo %s"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/es.po:msgid "FOREACH ... SLICE loop variable must be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/es.po:msgstr "las variables de bucles FOREACH ... SLICE deben ser de un tipo array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/es.po:msgid "FOREACH loop variable must not be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/es.po:msgstr "la variable de bucle FOREACH no debe ser de tipo array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/es.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/es.po:msgstr "el nmero de dimensiones del array (%d) excede el mximo permitido (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/es.po:msgid "subscripted object is not an array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/es.po:msgstr "el objeto al que se le puso un subndice no es un array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/es.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/es.po:msgstr "subndice de array en asignacin no puede ser null"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/es.po:msgid "FOREACH over array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/es.po:msgstr "FOREACH en torno a un array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/sv.po:msgid "FOREACH expression must yield an array, not type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/sv.po:msgstr "FOREACH-uttryck mste ge en array, inte typ %s"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/sv.po:msgid "FOREACH ... SLICE loop variable must be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/sv.po:msgstr "FOREACH ... SLICE-loop-variabel mste ha typen array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/sv.po:msgid "FOREACH loop variable must not be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/sv.po:msgstr "FOREACH-loop-variable fr inte ha typen array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/sv.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/sv.po:msgstr "antalet array-dimensioner (%d) verskrider det maximalt tilltna (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/sv.po:msgid "subscripted object is not an array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/sv.po:msgstr "arrayindexobjekt r inte en array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/sv.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/sv.po:msgstr "arrayindex i tilldelning kan inte vara null"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/sv.po:msgid "FOREACH over array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/sv.po:msgstr "FOREACH ver array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/pl.po:msgid "FOREACH expression must yield an array, not type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/pl.po:msgid "FOREACH ... SLICE loop variable must be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/pl.po:msgid "FOREACH loop variable must not be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/pl.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/pl.po:msgid "subscripted object is not an array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/pl.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/pl.po:msgid "FOREACH over array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/de.po:msgid "FOREACH expression must yield an array, not type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/de.po:msgid "FOREACH ... SLICE loop variable must be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/de.po:msgid "FOREACH loop variable must not be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/de.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/de.po:msgid "subscripted object is not an array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/de.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/de.po:msgid "FOREACH over array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/zh_CN.po:msgid "FOREACH expression must yield an array, not type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/zh_CN.po:msgid "FOREACH ... SLICE loop variable must be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/zh_CN.po:msgid "FOREACH loop variable must not be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/zh_CN.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/zh_CN.po:msgid "subscripted object is not an array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/zh_CN.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/zh_CN.po:msgid "FOREACH over array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/fr.po:msgid "FOREACH expression must yield an array, not type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/fr.po:msgid "FOREACH ... SLICE loop variable must be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/fr.po:msgid "FOREACH loop variable must not be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/fr.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/fr.po:msgid "subscripted object is not an array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/fr.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/fr.po:msgid "FOREACH over array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ro.po:msgid "FOREACH expression must yield an array, not type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ro.po:msgid "FOREACH ... SLICE loop variable must be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ro.po:msgstr "variabila din bucla FOREACH ... SLICE trebuie s fie de tip array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ro.po:msgid "FOREACH loop variable must not be of an array type"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ro.po:msgstr "variabila din bucla FOREACH  nu trebuie s fie de tip array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ro.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ro.po:msgstr "numarul dimensiunilor array-ului  (%d)  depete maximul admis, %d"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ro.po:msgid "subscripted object is not an array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ro.po:msgstr "obiectul transmis nu este un array"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ro.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ro.po:msgstr "array-ul transmis pentru atribuire nu poate fi null"
/srvr/z5089358/postgresql-10.4/src/pl/plpgsql/src/po/ro.po:msgid "FOREACH over array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:	bool		fn_retisarray;	/* true if function returns array */
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:	Oid		   *arg_arraytype;	/* InvalidOid if not an array */
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c: * Information for PostgreSQL - Perl array conversion.
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:typedef struct plperl_array_info
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:} plperl_array_info;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:static SV  *plperl_ref_from_pg_array(Datum arg, Oid typid);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:static SV  *split_array(plperl_array_info *info, int first, int last, int nest);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:static SV  *make_array_ref(plperl_array_info *info, int first, int last);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:static SV  *get_perl_array_ref(SV *sv);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:static Datum plperl_array_to_datum(SV *src, Oid typid, int32 typmod);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:static void array_to_datum_internal(AV *av, ArrayBuildState *astate,
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:						Oid arraytypid, Oid elemtypid, int32 typmod,
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c: * if we are an array ref return the reference. this is special in that if we
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c: * are a PostgreSQL::InServer::ARRAY object we will return the 'magic' array.
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:get_perl_array_ref(SV *sv)
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:			SV		  **sav = hv_fetch_string(hv, "array");
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:			elog(ERROR, "could not get array reference from PostgreSQL::InServer::ARRAY object");
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c: * helper function for plperl_array_to_datum, recurses for multi-D arrays
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:array_to_datum_internal(AV *av, ArrayBuildState *astate,
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:						Oid arraytypid, Oid elemtypid, int32 typmod,
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:		/* fetch the array element */
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:		/* see if this element is an array, if so get that */
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:		SV		   *sav = svp ? get_perl_array_ref(*svp) : NULL;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:		/* multi-dimensional array? */
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:						 errmsg("number of array dimensions (%d) exceeds the maximum allowed (%d)",
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:						 errmsg("multidimensional arrays must have array expressions with matching dimensions")));
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:			/* recurse to fetch elements of this sub-array */
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:			array_to_datum_internal(nav, astate,
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:									arraytypid, elemtypid, typmod,
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:			/* scalar after some sub-arrays at same level? */
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:						 errmsg("multidimensional arrays must have array expressions with matching dimensions")));
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c: * convert perl array ref to a datum
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:plperl_array_to_datum(SV *src, Oid typid, int32 typmod)
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:				 errmsg("cannot convert Perl array to non-array type %s",
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:	array_to_datum_internal((AV *) SvRV(src), astate,
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:	/* ensure we get zero-D array for no inputs, as per PG convention */
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:		SV		   *sav = get_perl_array_ref(sv);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:			/* handle an arrayref */
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:			return plperl_array_to_datum(sav, typid, typmod);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:		/* Reference, but not reference to hash or array ... */
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:				 errmsg("PL/Perl function must return reference to hash or array")));
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c: * Convert PostgreSQL array datum to a perl array reference.
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c: * typid is arg's OID, which must be an array type.
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:plperl_ref_from_pg_array(Datum arg, Oid typid)
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:	plperl_array_info *info;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:	info = palloc0(sizeof(plperl_array_info));
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:	/* Get the number and bounds of array dimensions */
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:	/* No dimensions? Return an empty array */
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:		deconstruct_array(ar, elementtype, typlen, typbyval,
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:		av = split_array(info, 0, nitems, 0);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:	(void) hv_store(hv, "array", 5, av, 0);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c: * Recursively form array references from splices of the initial array
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:split_array(plperl_array_info *info, int first, int last, int nest)
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:	 * Base case, return a reference to a single-dimensional array
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:		return make_array_ref(info, first, last);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:		/* Recursively form references to arrays of lower dimensions */
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:		SV		   *ref = split_array(info, i, i + info->nelems[nest + 1], nest + 1);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c: * Create a Perl reference from a one-dimensional C array, converting
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:make_array_ref(plperl_array_info *info, int first, int last)
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:	desc.fn_retisarray = false;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:			if (OidIsValid(desc->arg_arraytype[i]))
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:				sv = plperl_ref_from_pg_array(fcinfo->arg[i], desc->arg_arraytype[i]);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:		 * If the Perl function returned an arrayref, we pretend that it
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:		 * called return_next() for each element of the array, to handle old
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:		sav = get_perl_array_ref(perlret);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:							"reference to array or use return_next")));
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:		prodesc->arg_arraytype = (Oid *) palloc0(prodesc->nargs * sizeof(Oid));
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:		prodesc->trftypes = isnull ? NIL : oid_array_to_list(protrftypes_datum);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:			prodesc->fn_retisarray =
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:				/* Identify array attributes */
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:					prodesc->arg_arraytype[i] = procStruct->proargtypes.values[i];
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:					prodesc->arg_arraytype[i] = InvalidOid;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:				sv = plperl_ref_from_pg_array(attr, tupdesc->attrs[i]->atttypid);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.c:					 errmsg("query result has too many rows to fit in a Perl array")));
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_util.sql:-- test encode_array_literal
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_util.sql:create or replace function perl_encode_array_literal() returns setof text language plperl as $$
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_util.sql:	return_next encode_array_literal(undef);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_util.sql:	return_next encode_array_literal(0);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_util.sql:	return_next encode_array_literal(42);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_util.sql:	return_next encode_array_literal($_)
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_util.sql:	return_next encode_array_literal($_,'|')
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_util.sql:select perl_encode_array_literal();
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_util.sql:-- test encode_array_constructor
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_util.sql:create or replace function perl_encode_array_constructor() returns setof text language plperl as $$
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_util.sql:	return_next encode_array_constructor(undef);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_util.sql:	return_next encode_array_constructor(0);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_util.sql:	return_next encode_array_constructor(42);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_util.sql:	return_next encode_array_constructor($_)
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_util.sql:select perl_encode_array_constructor();
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl.sql:--- Test array return
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl.sql:CREATE OR REPLACE FUNCTION  array_of_text() RETURNS TEXT[][]
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl.sql:SELECT array_of_text();
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl.sql:-- make sure we can't return an array as a scalar
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl.sql:CREATE OR REPLACE FUNCTION text_arrayref() RETURNS text AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl.sql:	return ['array'];
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl.sql:SELECT text_arrayref();
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:CREATE OR REPLACE FUNCTION plperl_sum_array(INTEGER[]) RETURNS text AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:	my $array_arg = shift;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:	my @arrays;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:	push @arrays, @$array_arg;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:	while (@arrays > 0) {
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:		my $el = shift @arrays;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:		if (is_array_ref($el)) {
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:			push @arrays, @$el;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:	return $result.' '.$array_arg;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:select plperl_sum_array('{1,2,NULL}');
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:select plperl_sum_array('{}');
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:select plperl_sum_array('{{1,2,3}, {4,5,6}}');
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:select plperl_sum_array('{{{1,2,3}, {4,5,6}}, {{7,8,9}, {10,11,12}}}');
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:-- check whether we can handle arrays of maximum dimension (6)
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:select plperl_sum_array(ARRAY[[[[[[1,2],[3,4]],[[5,6],[7,8]]],[[[9,10],[11,12]],
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:-- what would we do with the arrays exceeding maximum dimension (7)
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:select plperl_sum_array('{{{{{{{1,2},{3,4}},{{5,6},{7,8}}},{{{9,10},{11,12}},
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:select plperl_sum_array('{{{1,2,3}, {4,5,6,7}}, {{7,8,9}, {10, 11, 12}}}');
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:	my $array_arg = shift;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:	my @arrays;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:	push @arrays, @$array_arg;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:	while (@arrays > 0) {
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:		my $el = shift @arrays;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:		if (is_array_ref($el)) {
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:			push @arrays, @$el;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:	return $result.' '.$array_arg;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:-- array of rows --
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:CREATE OR REPLACE FUNCTION plperl_array_of_rows(foo[]) RETURNS TEXT AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:	my $array_arg = shift;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:	for my $row_ref (@$array_arg) {
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:	return $result .' '. $array_arg;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:select plperl_array_of_rows(ARRAY[ ROW(2, 'coffee'), ROW(0, 'sugar')]::foo[]);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:-- composite type containing arrays
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:		die "not an array reference".ref ($row_ref->{baz})
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:		unless (is_array_ref($row_ref->{baz}));
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:		# process a single-dimensional array
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:-- composite type containing array of another composite type, which, in order,
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:-- contains an array of integers.
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:CREATE OR REPLACE FUNCTION plperl_sum_array_of_rows(rowbar) RETURNS TEXT AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:		my $row_array_ref = $rowfoo_ref->{foo};
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:		if (is_array_ref($row_array_ref)) {
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:			foreach my $row_ref (@{$row_array_ref}) {
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:					die "not an array reference".ref ($row_ref->{baz})
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:					unless (is_array_ref($row_ref->{baz}));
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:			die "not a reference to an array of rowfoo elements"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:select plperl_sum_array_of_rows(ROW(ARRAY[ROW(1, ARRAY[2,3,4,5,6,7,8,9,10])::rowfoo,
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:-- check arrays as out parameters
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:CREATE OR REPLACE FUNCTION plperl_arrays_out(OUT INTEGER[]) AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:select plperl_arrays_out();
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:-- check that we can return the array we passed in
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:CREATE OR REPLACE FUNCTION plperl_arrays_inout(INTEGER[]) returns INTEGER[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:select plperl_arrays_inout('{{1}, {2}, {3}}');
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:-- check that we can return an array literal
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:CREATE OR REPLACE FUNCTION plperl_arrays_inout_l(INTEGER[]) returns INTEGER[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:select plperl_arrays_inout_l('{{1}, {2}, {3}}');
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:create or replace function perl_setof_array(integer[]) returns setof integer[] language plperl as $$
/srvr/z5089358/postgresql-10.4/src/pl/plperl/sql/plperl_array.sql:select perl_setof_array('{{1}, {2}, {3}}');
/srvr/z5089358/postgresql-10.4/src/pl/plperl/ppport.h:dowantarray|||
/srvr/z5089358/postgresql-10.4/src/pl/plperl/ppport.h:find_array_subscript|||
/srvr/z5089358/postgresql-10.4/src/pl/plperl/ppport.h:ref_array_or_hash|||
/srvr/z5089358/postgresql-10.4/src/pl/plperl/GNUmakefile:REGRESS = plperl plperl_lc plperl_trigger plperl_shared plperl_elog plperl_util plperl_init plperlu plperl_array
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plc_perlboot.pl:sub ::is_array_ref
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plc_perlboot.pl:sub ::encode_array_literal
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plc_perlboot.pl:	return $arg unless (::is_array_ref($arg));
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plc_perlboot.pl:			$res .= ::encode_array_literal($elem, $delim);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plc_perlboot.pl:sub ::encode_array_constructor
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plc_perlboot.pl:	return ::quote_nullable($arg) unless ::is_array_ref($arg);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plc_perlboot.pl:	  map { (ref $_) ? ::encode_array_constructor($_) : ::quote_nullable($_) }
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plc_perlboot.pl:		return ::encode_typed_literal($self->{'array'}, $self->{'typeoid'});
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plc_perlboot.pl:		return shift->{'array'};
/srvr/z5089358/postgresql-10.4/src/pl/plperl/plperl.h:/* Perl 5.19.4 changed array indices from I32 to SSize_t */
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_util.out:-- test encode_array_literal
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_util.out:create or replace function perl_encode_array_literal() returns setof text language plperl as $$
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_util.out:	return_next encode_array_literal(undef);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_util.out:	return_next encode_array_literal(0);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_util.out:	return_next encode_array_literal(42);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_util.out:	return_next encode_array_literal($_)
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_util.out:	return_next encode_array_literal($_,'|')
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_util.out:select perl_encode_array_literal();
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_util.out: perl_encode_array_literal 
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_util.out:-- test encode_array_constructor
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_util.out:create or replace function perl_encode_array_constructor() returns setof text language plperl as $$
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_util.out:	return_next encode_array_constructor(undef);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_util.out:	return_next encode_array_constructor(0);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_util.out:	return_next encode_array_constructor(42);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_util.out:	return_next encode_array_constructor($_)
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_util.out:select perl_encode_array_constructor();
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_util.out:      perl_encode_array_constructor      
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl.out:ERROR:  cannot convert Perl array to non-array type footype
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl.out:ERROR:  set-returning PL/Perl function must return reference to array or use return_next
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl.out:ERROR:  set-returning PL/Perl function must return reference to array or use return_next
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl.out:--- Test array return
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl.out:CREATE OR REPLACE FUNCTION  array_of_text() RETURNS TEXT[][]
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl.out:SELECT array_of_text();
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl.out:             array_of_text             
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl.out:-- make sure we can't return an array as a scalar
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl.out:CREATE OR REPLACE FUNCTION text_arrayref() RETURNS text AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl.out:	return ['array'];
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl.out:SELECT text_arrayref();
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl.out:ERROR:  cannot convert Perl array to non-array type text
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl.out:CONTEXT:  PL/Perl function "text_arrayref"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl.out:ERROR:  PL/Perl function must return reference to hash or array
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:CREATE OR REPLACE FUNCTION plperl_sum_array(INTEGER[]) RETURNS text AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:	my $array_arg = shift;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:	my @arrays;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:	push @arrays, @$array_arg;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:	while (@arrays > 0) {
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:		my $el = shift @arrays;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:		if (is_array_ref($el)) {
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:			push @arrays, @$el;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:	return $result.' '.$array_arg;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:select plperl_sum_array('{1,2,NULL}');
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out: plperl_sum_array 
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:select plperl_sum_array('{}');
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out: plperl_sum_array 
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:select plperl_sum_array('{{1,2,3}, {4,5,6}}');
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:   plperl_sum_array   
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:select plperl_sum_array('{{{1,2,3}, {4,5,6}}, {{7,8,9}, {10,11,12}}}');
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:              plperl_sum_array               
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:-- check whether we can handle arrays of maximum dimension (6)
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:select plperl_sum_array(ARRAY[[[[[[1,2],[3,4]],[[5,6],[7,8]]],[[[9,10],[11,12]],
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:                                                                                                                                                 plperl_sum_array                                                                                                                                                 
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:-- what would we do with the arrays exceeding maximum dimension (7)
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:select plperl_sum_array('{{{{{{{1,2},{3,4}},{{5,6},{7,8}}},{{{9,10},{11,12}},
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:ERROR:  number of array dimensions (7) exceeds the maximum allowed (6)
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:LINE 1: select plperl_sum_array('{{{{{{{1,2},{3,4}},{{5,6},{7,8}}},{...
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:select plperl_sum_array('{{{1,2,3}, {4,5,6,7}}, {{7,8,9}, {10, 11, 12}}}');
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:ERROR:  malformed array literal: "{{{1,2,3}, {4,5,6,7}}, {{7,8,9}, {10, 11, 12}}}"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:LINE 1: select plperl_sum_array('{{{1,2,3}, {4,5,6,7}}, {{7,8,9}, {1...
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:DETAIL:  Multidimensional arrays must have sub-arrays with matching dimensions.
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:	my $array_arg = shift;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:	my @arrays;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:	push @arrays, @$array_arg;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:	while (@arrays > 0) {
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:		my $el = shift @arrays;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:		if (is_array_ref($el)) {
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:			push @arrays, @$el;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:	return $result.' '.$array_arg;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:-- array of rows --
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:CREATE OR REPLACE FUNCTION plperl_array_of_rows(foo[]) RETURNS TEXT AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:	my $array_arg = shift;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:	for my $row_ref (@$array_arg) {
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:	return $result .' '. $array_arg;
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:select plperl_array_of_rows(ARRAY[ ROW(2, 'coffee'), ROW(0, 'sugar')]::foo[]);
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:                      plperl_array_of_rows                      
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:-- composite type containing arrays
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:		die "not an array reference".ref ($row_ref->{baz})
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:		unless (is_array_ref($row_ref->{baz}));
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:		# process a single-dimensional array
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:-- composite type containing array of another composite type, which, in order,
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:-- contains an array of integers.
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:CREATE OR REPLACE FUNCTION plperl_sum_array_of_rows(rowbar) RETURNS TEXT AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:		my $row_array_ref = $rowfoo_ref->{foo};
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:		if (is_array_ref($row_array_ref)) {
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:			foreach my $row_ref (@{$row_array_ref}) {
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:					die "not an array reference".ref ($row_ref->{baz})
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:					unless (is_array_ref($row_ref->{baz}));
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:			die "not a reference to an array of rowfoo elements"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:select plperl_sum_array_of_rows(ROW(ARRAY[ROW(1, ARRAY[2,3,4,5,6,7,8,9,10])::rowfoo,
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out: plperl_sum_array_of_rows 
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:-- check arrays as out parameters
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:CREATE OR REPLACE FUNCTION plperl_arrays_out(OUT INTEGER[]) AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:select plperl_arrays_out();
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out: plperl_arrays_out 
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:-- check that we can return the array we passed in
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:CREATE OR REPLACE FUNCTION plperl_arrays_inout(INTEGER[]) returns INTEGER[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:select plperl_arrays_inout('{{1}, {2}, {3}}');
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out: plperl_arrays_inout 
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:-- check that we can return an array literal
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:CREATE OR REPLACE FUNCTION plperl_arrays_inout_l(INTEGER[]) returns INTEGER[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:select plperl_arrays_inout_l('{{1}, {2}, {3}}');
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out: plperl_arrays_inout_l 
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:create or replace function perl_setof_array(integer[]) returns setof integer[] language plperl as $$
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out:select perl_setof_array('{{1}, {2}, {3}}');
/srvr/z5089358/postgresql-10.4/src/pl/plperl/expected/plperl_array.out: perl_setof_array 
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/it.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/it.po:msgstr "il numero di dimensioni dell'array (%d) eccede il massimo consentito (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/it.po:msgid "multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/it.po:msgstr "gli array multidimensionali devono avere espressioni array di dimensioni corrispondenti"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/it.po:msgid "cannot convert Perl array to non-array type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/it.po:msgstr "non  possibile convertire un array Perl nel tipo non-array %s"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/it.po:msgid "PL/Perl function must return reference to hash or array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/it.po:msgstr "la funzione PL/Perl deve restituire un riferimento a hash o array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/it.po:msgid "set-returning PL/Perl function must return reference to array or use return_next"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/it.po:msgstr "la funzione PL/Perl che restituisce un insieme deve restituire un riferimento ad un array o usare return_next"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/it.po:msgid "query result has too many rows to fit in a Perl array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/it.po:msgstr "il risultato della query ha troppe righe per un array Perl"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ja.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ja.po:"multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ja.po:msgid "cannot convert Perl array to non-array type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ja.po:msgid "PL/Perl function must return reference to hash or array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ja.po:"set-returning PL/Perl function must return reference to array or use "
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ja.po:msgid "query result has too many rows to fit in a Perl array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/tr.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/tr.po:msgid "multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/tr.po:msgid "cannot convert Perl array to non-array type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/tr.po:msgstr "Perl dizisi (array) dizi olmayan %s tipine dntrlemiyor"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/tr.po:msgid "PL/Perl function must return reference to hash or array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/tr.po:msgid "set-returning PL/Perl function must return reference to array or use return_next"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/tr.po:msgid "query result has too many rows to fit in a Perl array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/tr.po:msgstr "sorgu sonucunda bir Perl dizisine (array) sabilecekten ok fazla satr var"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ko.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ko.po:"multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ko.po:msgid "cannot convert Perl array to non-array type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ko.po:msgid "PL/Perl function must return reference to hash or array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ko.po:"set-returning PL/Perl function must return reference to array or use "
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ko.po:msgid "query result has too many rows to fit in a Perl array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/cs.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/cs.po:"multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/cs.po:msgid "cannot convert Perl array to non-array type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/cs.po:msgid "PL/Perl function must return reference to hash or array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/cs.po:"set-returning PL/Perl function must return reference to array or use "
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ru.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ru.po:"multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ru.po:msgid "cannot convert Perl array to non-array type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ru.po:msgid "PL/Perl function must return reference to hash or array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ru.po:"set-returning PL/Perl function must return reference to array or use "
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ru.po:msgid "query result has too many rows to fit in a Perl array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/pt_BR.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/pt_BR.po:msgid "multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/pt_BR.po:msgid "cannot convert Perl array to non-array type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/pt_BR.po:msgstr "no pode converter array Perl para tipo que no  array %s"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/pt_BR.po:msgid "PL/Perl function must return reference to hash or array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/pt_BR.po:msgid "set-returning PL/Perl function must return reference to array or use return_next"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/pt_BR.po:msgid "query result has too many rows to fit in a Perl array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/pt_BR.po:msgstr "resultado da consulta tem muitos registros para caber em um array Perl"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/es.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/es.po:msgstr "el nmero de dimensiones del array (%d) excede el mximo permitido (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/es.po:msgid "multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/es.po:msgstr "los arrays multidimensionales deben tener expresiones de arrays con dimensiones coincidentes"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/es.po:msgid "cannot convert Perl array to non-array type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/es.po:msgstr "no se puede convertir un array de Perl al tipo no-array %s"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/es.po:msgid "PL/Perl function must return reference to hash or array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/es.po:msgstr "una funcin Perl debe retornar una referencia a un hash o array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/es.po:msgid "set-returning PL/Perl function must return reference to array or use return_next"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/es.po:msgstr "una funcin PL/Perl que retorna un conjunto debe retornar una referencia a un array o usar return_next"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/es.po:msgid "query result has too many rows to fit in a Perl array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/es.po:msgstr "el resultado de la consulta tiene demasiados registros y no entran en un array de Perl"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/sv.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/sv.po:msgstr "antalet array-dimensioner (%d) verskrider det maximalt tilltna (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/sv.po:msgid "multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/sv.po:msgstr "flerdimensionella vektorer mste ha array-uttryck av passande dimensioner"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/sv.po:msgid "cannot convert Perl array to non-array type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/sv.po:msgstr "kan inte omvandla perlvektor till icke-array av typ \"%s\"."
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/sv.po:msgid "PL/Perl function must return reference to hash or array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/sv.po:msgstr "Funktioner i PL/Perl mste svara med referens till hash eller array."
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/sv.po:msgid "set-returning PL/Perl function must return reference to array or use return_next"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/sv.po:msgid "query result has too many rows to fit in a Perl array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/sv.po:msgstr "frgeresultatet har fr mnga rader fr att f plats i en Perl-array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/pl.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/pl.po:msgid "multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/pl.po:msgid "cannot convert Perl array to non-array type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/pl.po:msgid "PL/Perl function must return reference to hash or array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/pl.po:msgid "set-returning PL/Perl function must return reference to array or use return_next"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/pl.po:msgid "query result has too many rows to fit in a Perl array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/de.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/de.po:msgid "multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/de.po:msgid "cannot convert Perl array to non-array type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/de.po:msgid "PL/Perl function must return reference to hash or array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/de.po:msgid "set-returning PL/Perl function must return reference to array or use return_next"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/de.po:msgid "query result has too many rows to fit in a Perl array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/zh_CN.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/zh_CN.po:"multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/zh_CN.po:msgid "cannot convert Perl array to non-array type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/zh_CN.po:msgid "PL/Perl function must return reference to hash or array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/zh_CN.po:"set-returning PL/Perl function must return reference to array or use "
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/zh_CN.po:msgid "query result has too many rows to fit in a Perl array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/fr.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/fr.po:msgid "multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/fr.po:msgid "cannot convert Perl array to non-array type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/fr.po:msgid "PL/Perl function must return reference to hash or array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/fr.po:msgid "set-returning PL/Perl function must return reference to array or use return_next"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/fr.po:msgid "query result has too many rows to fit in a Perl array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ro.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ro.po:msgstr "numarul dimensiunilor array-ului  (%d)  depete maximul admis, %d"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ro.po:msgid "multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ro.po:msgstr "array-urile multidimensionale trebuie s aib expresii de tip array cu dimensiuni corespunztoare"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ro.po:msgid "cannot convert Perl array to non-array type %s"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ro.po:msgstr "nu pot converti un array Perl n tipul de dat  %s"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ro.po:msgid "PL/Perl function must return reference to hash or array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ro.po:msgstr "funcia PL/Perl trebuie s returneze o referin la hash sau array"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ro.po:msgid "set-returning PL/Perl function must return reference to array or use return_next"
/srvr/z5089358/postgresql-10.4/src/pl/plperl/po/ro.po:msgstr "funcia PL/Perl care are rezultat de tip set trebuie s intoarc o referin la un array sau s foloseasc return_next"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_procedure.h:	int			nargs;			/* length of namedargs array */
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_cursorobject.c:		/* cleanup plan->values array */
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:CREATE FUNCTION test_type_conversion_array_int4(x int4[]) RETURNS int4[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:SELECT * FROM test_type_conversion_array_int4(ARRAY[0, 100]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:SELECT * FROM test_type_conversion_array_int4(ARRAY[0,-100,55]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:SELECT * FROM test_type_conversion_array_int4(ARRAY[NULL,1]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:SELECT * FROM test_type_conversion_array_int4(ARRAY[]::integer[]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:SELECT * FROM test_type_conversion_array_int4(NULL);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:SELECT * FROM test_type_conversion_array_int4(ARRAY[[1,2,3],[4,5,6]]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:SELECT * FROM test_type_conversion_array_int4(ARRAY[[[1,2,NULL],[NULL,5,6]],[[NULL,8,9],[10,11,12]]]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:SELECT * FROM test_type_conversion_array_int4('[2:4]={1,2,3}');
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:CREATE FUNCTION test_type_conversion_array_int8(x int8[]) RETURNS int8[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:SELECT * FROM test_type_conversion_array_int8(ARRAY[[[1,2,NULL],[NULL,5,6]],[[NULL,8,9],[10,11,12]]]::int8[]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:CREATE FUNCTION test_type_conversion_array_date(x date[]) RETURNS date[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:SELECT * FROM test_type_conversion_array_date(ARRAY[[['2016-09-21','2016-09-22',NULL],[NULL,'2016-10-21','2016-10-22']],
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:CREATE FUNCTION test_type_conversion_array_timestamp(x timestamp[]) RETURNS timestamp[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:SELECT * FROM test_type_conversion_array_timestamp(ARRAY[[['2016-09-21 15:34:24.078792-04','2016-10-22 11:34:24.078795-04',NULL],
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:CREATE FUNCTION test_type_conversion_array_text(x text[]) RETURNS text[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:SELECT * FROM test_type_conversion_array_text(ARRAY['foo', 'bar']);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:SELECT * FROM test_type_conversion_array_text(ARRAY[['foo', 'bar'],['foo2', 'bar2']]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:CREATE FUNCTION test_type_conversion_array_bytea(x bytea[]) RETURNS bytea[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:SELECT * FROM test_type_conversion_array_bytea(ARRAY[E'\\xdeadbeef'::bytea, NULL]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:CREATE FUNCTION test_type_conversion_array_mixed1() RETURNS text[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:SELECT * FROM test_type_conversion_array_mixed1();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:CREATE FUNCTION test_type_conversion_array_mixed2() RETURNS int[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:SELECT * FROM test_type_conversion_array_mixed2();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:CREATE FUNCTION test_type_conversion_mdarray_malformed() RETURNS int[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:SELECT * FROM test_type_conversion_mdarray_malformed();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:CREATE FUNCTION test_type_conversion_mdarray_toodeep() RETURNS int[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:SELECT * FROM test_type_conversion_mdarray_toodeep();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:CREATE FUNCTION test_type_conversion_array_record() RETURNS type_record[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:SELECT * FROM test_type_conversion_array_record();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:CREATE FUNCTION test_type_conversion_array_string() RETURNS text[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:SELECT * FROM test_type_conversion_array_string();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:CREATE FUNCTION test_type_conversion_array_tuple() RETURNS text[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:SELECT * FROM test_type_conversion_array_tuple();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:CREATE FUNCTION test_type_conversion_array_error() RETURNS int[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:SELECT * FROM test_type_conversion_array_error();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:-- Domains over arrays
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:CREATE DOMAIN ordered_pair_domain AS integer[] CHECK (array_length(VALUE,1)=2 AND VALUE[1] < VALUE[2]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:CREATE FUNCTION test_type_conversion_array_domain(x ordered_pair_domain) RETURNS ordered_pair_domain AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:SELECT * FROM test_type_conversion_array_domain(ARRAY[0, 100]::ordered_pair_domain);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:SELECT * FROM test_type_conversion_array_domain(NULL::ordered_pair_domain);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:CREATE FUNCTION test_type_conversion_array_domain_check_violation() RETURNS ordered_pair_domain AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_types.sql:SELECT * FROM test_type_conversion_array_domain_check_violation();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_import.sql:  import array
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_composite.sql:CREATE FUNCTION multiout_array(OUT integer[], OUT text) RETURNS SETOF record AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_composite.sql:SELECT * FROM multiout_array();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_composite.sql:-- multi-dimensional array of composite types.
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_composite.sql:-- Starting with PostgreSQL 10, a composite type in an array cannot be
/srvr/z5089358/postgresql-10.4/src/pl/plpython/sql/plpython_composite.sql:-- arrays. So this throws an error now. The error should contain a useful hint
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_spi.c:		 * cleanup plan->values array
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.h: * The 'inarray' argument to the conversion function is true, if the
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.h: * converted value was in an array (Python list). It is used to give a
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.h:typedef Datum (*PLyObToDatumFunc) (struct PLyObToDatum *arg, int32 typmod, PyObject *val, bool inarray);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.h:extern Datum PLyObject_ToCompositeDatum(PLyTypeInfo *info, TupleDesc desc, PyObject *plrv, bool isarray);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:static Datum PLyObject_ToBool(PLyObToDatum *arg, int32 typmod, PyObject *plrv, bool inarray);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:static Datum PLyObject_ToBytea(PLyObToDatum *arg, int32 typmod, PyObject *plrv, bool inarray);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:static Datum PLyObject_ToComposite(PLyObToDatum *arg, int32 typmod, PyObject *plrv, bool inarray);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:static Datum PLyObject_ToDatum(PLyObToDatum *arg, int32 typmod, PyObject *plrv, bool inarray);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:static Datum PLyObject_ToTransform(PLyObToDatum *arg, int32 typmod, PyObject *plrv, bool inarray);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:static Datum PLySequence_ToArray(PLyObToDatum *arg, int32 typmod, PyObject *plrv, bool inarray);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:static Datum PLyString_ToComposite(PLyTypeInfo *info, TupleDesc desc, PyObject *string, bool inarray);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:static Datum PLyGenericObject_ToComposite(PLyTypeInfo *info, TupleDesc desc, PyObject *object, bool inarray);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:PLyObject_ToCompositeDatum(PLyTypeInfo *info, TupleDesc desc, PyObject *plrv, bool inarray)
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:		datum = PLyString_ToComposite(info, desc, plrv, inarray);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:		datum = PLyGenericObject_ToComposite(info, desc, plrv, inarray);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:	ArrayType  *array = DatumGetArrayTypeP(d);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:	if (ARR_NDIM(array) == 0)
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:	ndim = ARR_NDIM(array);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:	dims = ARR_DIMS(array);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:	 * We iterate the SQL array in the physical order it's stored in the
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:	 * datum. For example, for a 3-dimensional array the order of iteration
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:	 * represented as a list of lists. So a 3-d array of [n,m,k] elements is a
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:	 * list of n m-element arrays, each element of which is k-element array.
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:	dataptr = ARR_DATA_PTR(array);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:	bitmap = ARR_NULLBITMAP(array);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:		 * Innermost dimension. Fill the list with the values from the array
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:PLyObject_ToBool(PLyObToDatum *arg, int32 typmod, PyObject *plrv, bool inarray)
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:PLyObject_ToBytea(PLyObToDatum *arg, int32 typmod, PyObject *plrv, bool inarray)
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:PLyObject_ToComposite(PLyObToDatum *arg, int32 typmod, PyObject *plrv, bool inarray)
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:	rv = PLyObject_ToCompositeDatum(&info, desc, plrv, inarray);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:PLyObject_ToDatum(PLyObToDatum *arg, int32 typmod, PyObject *plrv, bool inarray)
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:	 * If we are parsing a composite type within an array, and the string
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:	 * array, containing record ('foo', 'bar'). PostgreSQL 10 added support
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:	 * for multi-dimensional arrays, and it is now interpreted as a
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:	 * two-dimensional array, containing two records, 'foo', and 'bar'.
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:	 * are parsing an array of composite types, and we see a string literal
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:	if (inarray && arg->typfunc.fn_oid == F_RECORD_IN)
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:					 errhint("To return a composite type in an array, return the composite type as a Python tuple, e.g., \"[('foo',)]\".")));
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:PLyObject_ToTransform(PLyObToDatum *arg, int32 typmod, PyObject *plrv, bool inarray)
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:PLySequence_ToArray(PLyObToDatum *arg, int32 typmod, PyObject *plrv, bool inarray)
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:	ArrayType  *array;
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:			PLy_elog(ERROR, "number of array dimensions exceeds the maximum allowed (%d)", MAXDIM);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:			PLy_elog(ERROR, "array size exceeds the maximum allowed");
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:			PLy_elog(ERROR, "array size exceeds the maximum allowed");
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:	 * tuples or strings to arrays in general, but in the first level, be
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:	 * kind, treat it as a one-dimensional array.
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:			PLy_elog(ERROR, "return value of function with array return type is not a Python sequence");
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:	 * elements at the bottom level into 'elems'/'nulls' arrays.
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:	array = construct_md_array(elems,
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:	 * If the result type is a domain of array, the resulting array must be
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:	rv = PointerGetDatum(array);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:				 (errdetail("To construct a multidimensional array, the inner sequences must all have the same length."))));
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:PLyString_ToComposite(PLyTypeInfo *info, TupleDesc desc, PyObject *string, bool inarray)
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:	result = PLyObject_ToDatum(&locinfo.out.d, desc->tdtypmod, string, inarray);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:PLyGenericObject_ToComposite(PLyTypeInfo *info, TupleDesc desc, PyObject *object, bool inarray)
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:				 * If we are parsing a composite type in an array, a likely
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:				 * array, with a composite type (123, 'foo') in it. But now
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:				 * it's interpreted as a two-dimensional array, and we try to
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:						 inarray ?
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_typeio.c:						 errhint("To return a composite type in an array, return the composite type as a Python tuple, e.g., \"[('foo',)]\".") :
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:CREATE FUNCTION test_type_conversion_array_int4(x int4[]) RETURNS int4[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:SELECT * FROM test_type_conversion_array_int4(ARRAY[0, 100]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out: test_type_conversion_array_int4 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:SELECT * FROM test_type_conversion_array_int4(ARRAY[0,-100,55]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out: test_type_conversion_array_int4 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:SELECT * FROM test_type_conversion_array_int4(ARRAY[NULL,1]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out: test_type_conversion_array_int4 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:SELECT * FROM test_type_conversion_array_int4(ARRAY[]::integer[]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out: test_type_conversion_array_int4 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:SELECT * FROM test_type_conversion_array_int4(NULL);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out: test_type_conversion_array_int4 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:SELECT * FROM test_type_conversion_array_int4(ARRAY[[1,2,3],[4,5,6]]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out: test_type_conversion_array_int4 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:SELECT * FROM test_type_conversion_array_int4(ARRAY[[[1,2,NULL],[NULL,5,6]],[[NULL,8,9],[10,11,12]]]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:          test_type_conversion_array_int4          
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:SELECT * FROM test_type_conversion_array_int4('[2:4]={1,2,3}');
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out: test_type_conversion_array_int4 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:CREATE FUNCTION test_type_conversion_array_int8(x int8[]) RETURNS int8[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:SELECT * FROM test_type_conversion_array_int8(ARRAY[[[1,2,NULL],[NULL,5,6]],[[NULL,8,9],[10,11,12]]]::int8[]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:          test_type_conversion_array_int8          
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:CREATE FUNCTION test_type_conversion_array_date(x date[]) RETURNS date[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:SELECT * FROM test_type_conversion_array_date(ARRAY[[['2016-09-21','2016-09-22',NULL],[NULL,'2016-10-21','2016-10-22']],
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:                                                 test_type_conversion_array_date                                                 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:CREATE FUNCTION test_type_conversion_array_timestamp(x timestamp[]) RETURNS timestamp[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:SELECT * FROM test_type_conversion_array_timestamp(ARRAY[[['2016-09-21 15:34:24.078792-04','2016-10-22 11:34:24.078795-04',NULL],
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:                                                                                                                                                      test_type_conversion_array_timestamp                                                                                                                                                      
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:CREATE FUNCTION test_type_conversion_array_text(x text[]) RETURNS text[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:SELECT * FROM test_type_conversion_array_text(ARRAY['foo', 'bar']);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out: test_type_conversion_array_text 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:SELECT * FROM test_type_conversion_array_text(ARRAY[['foo', 'bar'],['foo2', 'bar2']]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out: test_type_conversion_array_text 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:CREATE FUNCTION test_type_conversion_array_bytea(x bytea[]) RETURNS bytea[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:SELECT * FROM test_type_conversion_array_bytea(ARRAY[E'\\xdeadbeef'::bytea, NULL]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out: test_type_conversion_array_bytea 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:CREATE FUNCTION test_type_conversion_array_mixed1() RETURNS text[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:SELECT * FROM test_type_conversion_array_mixed1();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out: test_type_conversion_array_mixed1 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:CREATE FUNCTION test_type_conversion_array_mixed2() RETURNS int[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:SELECT * FROM test_type_conversion_array_mixed2();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:PL/Python function "test_type_conversion_array_mixed2"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:CREATE FUNCTION test_type_conversion_mdarray_malformed() RETURNS int[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:SELECT * FROM test_type_conversion_mdarray_malformed();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:DETAIL:  To construct a multidimensional array, the inner sequences must all have the same length.
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:PL/Python function "test_type_conversion_mdarray_malformed"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:CREATE FUNCTION test_type_conversion_mdarray_toodeep() RETURNS int[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:SELECT * FROM test_type_conversion_mdarray_toodeep();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:ERROR:  number of array dimensions exceeds the maximum allowed (6)
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:PL/Python function "test_type_conversion_mdarray_toodeep"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:CREATE FUNCTION test_type_conversion_array_record() RETURNS type_record[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:SELECT * FROM test_type_conversion_array_record();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out: test_type_conversion_array_record 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:CREATE FUNCTION test_type_conversion_array_string() RETURNS text[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:SELECT * FROM test_type_conversion_array_string();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out: test_type_conversion_array_string 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:CREATE FUNCTION test_type_conversion_array_tuple() RETURNS text[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:SELECT * FROM test_type_conversion_array_tuple();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out: test_type_conversion_array_tuple 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:CREATE FUNCTION test_type_conversion_array_error() RETURNS int[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:SELECT * FROM test_type_conversion_array_error();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:ERROR:  return value of function with array return type is not a Python sequence
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:PL/Python function "test_type_conversion_array_error"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:-- Domains over arrays
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:CREATE DOMAIN ordered_pair_domain AS integer[] CHECK (array_length(VALUE,1)=2 AND VALUE[1] < VALUE[2]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:CREATE FUNCTION test_type_conversion_array_domain(x ordered_pair_domain) RETURNS ordered_pair_domain AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:SELECT * FROM test_type_conversion_array_domain(ARRAY[0, 100]::ordered_pair_domain);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out: test_type_conversion_array_domain 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:SELECT * FROM test_type_conversion_array_domain(NULL::ordered_pair_domain);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out: test_type_conversion_array_domain 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:CREATE FUNCTION test_type_conversion_array_domain_check_violation() RETURNS ordered_pair_domain AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:SELECT * FROM test_type_conversion_array_domain_check_violation();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types.out:PL/Python function "test_type_conversion_array_domain_check_violation"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:CREATE FUNCTION test_type_conversion_array_int4(x int4[]) RETURNS int4[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:SELECT * FROM test_type_conversion_array_int4(ARRAY[0, 100]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out: test_type_conversion_array_int4 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:SELECT * FROM test_type_conversion_array_int4(ARRAY[0,-100,55]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out: test_type_conversion_array_int4 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:SELECT * FROM test_type_conversion_array_int4(ARRAY[NULL,1]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out: test_type_conversion_array_int4 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:SELECT * FROM test_type_conversion_array_int4(ARRAY[]::integer[]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out: test_type_conversion_array_int4 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:SELECT * FROM test_type_conversion_array_int4(NULL);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out: test_type_conversion_array_int4 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:SELECT * FROM test_type_conversion_array_int4(ARRAY[[1,2,3],[4,5,6]]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out: test_type_conversion_array_int4 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:SELECT * FROM test_type_conversion_array_int4(ARRAY[[[1,2,NULL],[NULL,5,6]],[[NULL,8,9],[10,11,12]]]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:          test_type_conversion_array_int4          
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:SELECT * FROM test_type_conversion_array_int4('[2:4]={1,2,3}');
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out: test_type_conversion_array_int4 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:CREATE FUNCTION test_type_conversion_array_int8(x int8[]) RETURNS int8[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:SELECT * FROM test_type_conversion_array_int8(ARRAY[[[1,2,NULL],[NULL,5,6]],[[NULL,8,9],[10,11,12]]]::int8[]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:          test_type_conversion_array_int8          
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:CREATE FUNCTION test_type_conversion_array_date(x date[]) RETURNS date[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:SELECT * FROM test_type_conversion_array_date(ARRAY[[['2016-09-21','2016-09-22',NULL],[NULL,'2016-10-21','2016-10-22']],
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:                                                 test_type_conversion_array_date                                                 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:CREATE FUNCTION test_type_conversion_array_timestamp(x timestamp[]) RETURNS timestamp[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:SELECT * FROM test_type_conversion_array_timestamp(ARRAY[[['2016-09-21 15:34:24.078792-04','2016-10-22 11:34:24.078795-04',NULL],
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:                                                                                                                                                      test_type_conversion_array_timestamp                                                                                                                                                      
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:CREATE FUNCTION test_type_conversion_array_text(x text[]) RETURNS text[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:SELECT * FROM test_type_conversion_array_text(ARRAY['foo', 'bar']);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out: test_type_conversion_array_text 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:SELECT * FROM test_type_conversion_array_text(ARRAY[['foo', 'bar'],['foo2', 'bar2']]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out: test_type_conversion_array_text 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:CREATE FUNCTION test_type_conversion_array_bytea(x bytea[]) RETURNS bytea[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:SELECT * FROM test_type_conversion_array_bytea(ARRAY[E'\\xdeadbeef'::bytea, NULL]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out: test_type_conversion_array_bytea 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:CREATE FUNCTION test_type_conversion_array_mixed1() RETURNS text[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:SELECT * FROM test_type_conversion_array_mixed1();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out: test_type_conversion_array_mixed1 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:CREATE FUNCTION test_type_conversion_array_mixed2() RETURNS int[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:SELECT * FROM test_type_conversion_array_mixed2();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:PL/Python function "test_type_conversion_array_mixed2"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:CREATE FUNCTION test_type_conversion_mdarray_malformed() RETURNS int[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:SELECT * FROM test_type_conversion_mdarray_malformed();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:DETAIL:  To construct a multidimensional array, the inner sequences must all have the same length.
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:PL/Python function "test_type_conversion_mdarray_malformed"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:CREATE FUNCTION test_type_conversion_mdarray_toodeep() RETURNS int[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:SELECT * FROM test_type_conversion_mdarray_toodeep();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:ERROR:  number of array dimensions exceeds the maximum allowed (6)
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:PL/Python function "test_type_conversion_mdarray_toodeep"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:CREATE FUNCTION test_type_conversion_array_record() RETURNS type_record[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:SELECT * FROM test_type_conversion_array_record();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out: test_type_conversion_array_record 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:CREATE FUNCTION test_type_conversion_array_string() RETURNS text[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:SELECT * FROM test_type_conversion_array_string();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out: test_type_conversion_array_string 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:CREATE FUNCTION test_type_conversion_array_tuple() RETURNS text[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:SELECT * FROM test_type_conversion_array_tuple();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out: test_type_conversion_array_tuple 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:CREATE FUNCTION test_type_conversion_array_error() RETURNS int[] AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:SELECT * FROM test_type_conversion_array_error();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:ERROR:  return value of function with array return type is not a Python sequence
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:PL/Python function "test_type_conversion_array_error"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:-- Domains over arrays
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:CREATE DOMAIN ordered_pair_domain AS integer[] CHECK (array_length(VALUE,1)=2 AND VALUE[1] < VALUE[2]);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:CREATE FUNCTION test_type_conversion_array_domain(x ordered_pair_domain) RETURNS ordered_pair_domain AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:SELECT * FROM test_type_conversion_array_domain(ARRAY[0, 100]::ordered_pair_domain);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out: test_type_conversion_array_domain 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:SELECT * FROM test_type_conversion_array_domain(NULL::ordered_pair_domain);
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out: test_type_conversion_array_domain 
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:CREATE FUNCTION test_type_conversion_array_domain_check_violation() RETURNS ordered_pair_domain AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:SELECT * FROM test_type_conversion_array_domain_check_violation();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_types_3.out:PL/Python function "test_type_conversion_array_domain_check_violation"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_import.out:  import array
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_composite.out:CREATE FUNCTION multiout_array(OUT integer[], OUT text) RETURNS SETOF record AS $$
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_composite.out:SELECT * FROM multiout_array();
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_composite.out:-- multi-dimensional array of composite types.
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_composite.out:-- Starting with PostgreSQL 10, a composite type in an array cannot be
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_composite.out:-- arrays. So this throws an error now. The error should contain a useful hint
/srvr/z5089358/postgresql-10.4/src/pl/plpython/expected/plpython_composite.out:HINT:  To return a composite type in an array, return the composite type as a Python tuple, e.g., "[('foo',)]".
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/it.po:msgid "To return a composite type in an array, return the composite type as a Python tuple, e.g., \"[('foo',)]\"."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/it.po:msgstr "Per restutuire un tipo composito in un array, restituisci il tipo composito come tupla Python, per esempio \"[('foo',)]\" "
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/it.po:msgid "number of array dimensions exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/it.po:msgstr "il numero di dimensioni dell'array supera il massimo consentito (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/it.po:msgid "array size exceeds the maximum allowed"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/it.po:msgstr "la dimensione dell'array supera il massimo consentito"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/it.po:msgid "return value of function with array return type is not a Python sequence"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/it.po:msgstr "il valore restituito dalla funzione con tipo restituito array non  una sequenza Python"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/it.po:msgid "To construct a multidimensional array, the inner sequences must all have the same length."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/it.po:msgstr "Per costruire un array multidimensionale le sequenze interne devono avere tutte la stessa lunghezza."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/ja.po:"To return a composite type in an array, return the composite type as a "
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/ja.po:msgid "number of array dimensions exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/ja.po:msgid "array size exceeds the maximum allowed"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/ja.po:"return value of function with array return type is not a Python sequence"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/ja.po:"To construct a multidimensional array, the inner sequences must all have the "
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/tr.po:msgid "To return a composite type in an array, return the composite type as a Python tuple, e.g., \"[('foo',)]\"."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/tr.po:msgstr "Bir bileik tr dizi (array) iinde dndrmek iin, bileik tr bir Python tuple, e.g., \"[('foo',)]\"."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/tr.po:msgid "number of array dimensions exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/tr.po:msgstr "dizi (array) boyut says izin verilen en yksek deeri (%d) amaktadr"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/tr.po:msgid "array size exceeds the maximum allowed"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/tr.po:msgstr "dizi (array) boyutu izin verilen en yksek deeri amaktadr"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/tr.po:msgid "return value of function with array return type is not a Python sequence"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/tr.po:msgid "To construct a multidimensional array, the inner sequences must all have the same length."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/tr.po:#~ msgid "PL/Python only supports one-dimensional arrays."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/tr.po:#~ msgid "cannot convert multidimensional array to Python list"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/tr.po:#~ msgid "PL/Python does not support conversion to arrays of row types."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/ko.po:"To return a composite type in an array, return the composite type as a "
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/ko.po:msgid "number of array dimensions exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/ko.po:msgid "array size exceeds the maximum allowed"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/ko.po:"return value of function with array return type is not a Python sequence"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/ko.po:"To construct a multidimensional array, the inner sequences must all have the "
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/ru.po:"To return a composite type in an array, return the composite type as a "
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/ru.po:msgid "number of array dimensions exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/ru.po:msgid "array size exceeds the maximum allowed"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/ru.po:"return value of function with array return type is not a Python sequence"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/ru.po:"To construct a multidimensional array, the inner sequences must all have the "
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/ru.po:#~ "multidimensional arrays must have array expressions with matching "
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/ru.po:#~ msgid "cannot convert multidimensional array to Python list"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/ru.po:#~ msgid "PL/Python only supports one-dimensional arrays."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/ru.po:#~ msgid "PL/Python does not support conversion to arrays of row types."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/pt_BR.po:msgid "cannot convert multidimensional array to Python list"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/pt_BR.po:msgid "PL/Python only supports one-dimensional arrays."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/pt_BR.po:msgid "return value of function with array return type is not a Python sequence"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/es.po:msgid "To return a composite type in an array, return the composite type as a Python tuple, e.g., \"[('foo',)]\"."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/es.po:msgstr "Para retornar un tipo compuesto en un array, retorne el tipo compuesto como una tupla de Python, e.g., [('foo',)]."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/es.po:msgid "number of array dimensions exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/es.po:msgstr "el nmero de dimensiones del array excede el mximo permitido (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/es.po:msgid "array size exceeds the maximum allowed"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/es.po:msgstr "el tamao del array excede el mximo permitido"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/es.po:msgid "return value of function with array return type is not a Python sequence"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/es.po:msgstr "el valor de retorno de la funcin con tipo de retorno array no es una secuencia Python"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/es.po:msgid "multidimensional arrays must have array expressions with matching dimensions. PL/Python function return value has sequence length %d while expected %d"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/es.po:msgstr "los arrays multidimensionales deben contener expresiones de array con igual nmero de dimensiones. El valor de retorno de la funcin PL/Python tiene un tamao de secuencia %d pero se esperaba %d"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/es.po:#~ msgid "cannot convert multidimensional array to Python list"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/es.po:#~ msgstr "no se puede convertir array multidimensional a una lista Python"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/es.po:#~ msgid "PL/Python only supports one-dimensional arrays."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/es.po:#~ msgstr "PL/Python slo soporta arrays unidimensionales."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/es.po:#~ msgid "PL/Python does not support conversion to arrays of row types."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/es.po:#~ msgstr "PL/Python no soporta la conversin de arrays a tipos de registro."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/sv.po:msgid "To return a composite type in an array, return the composite type as a Python tuple, e.g., \"[('foo',)]\"."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/sv.po:msgstr "Fr att returnera en composite-typ i en array, returnera composite-typen som en Python-tupel, t.ex. \"[('foo',)]\"."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/sv.po:msgid "number of array dimensions exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/sv.po:msgstr "antal array-dimensioner verskriver maximalt tilltna (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/sv.po:msgid "array size exceeds the maximum allowed"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/sv.po:msgstr "array-storlek verskrider maximalt tilltna"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/sv.po:msgid "return value of function with array return type is not a Python sequence"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/sv.po:msgstr "returvrde fr funktion med array-returtyp r inte en Python-sekvens"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/sv.po:msgid "To construct a multidimensional array, the inner sequences must all have the same length."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/sv.po:msgstr "Fr att skapa en multidimensionell array s skall alla de inre sekvenserna ha samma lngd."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/pl.po:msgid "To return a composite type in an array, return the composite type as a Python tuple, e.g. \"[('foo')]\""
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/pl.po:#| msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/pl.po:msgid "number of array dimensions exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/pl.po:#| msgid "array size exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/pl.po:msgid "array size exceeds the maximum allowed"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/pl.po:msgid "return value of function with array return type is not a Python sequence"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/pl.po:#| msgid "multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/pl.po:msgid "multidimensional arrays must have array expressions with matching dimensions. PL/Python function return value has sequence length %d while expected %d"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/pl.po:#~ msgid "PL/Python does not support conversion to arrays of row types."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/pl.po:#~ msgid "PL/Python only supports one-dimensional arrays."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/pl.po:#~ msgid "cannot convert multidimensional array to Python list"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/de.po:msgid "To return a composite type in an array, return the composite type as a Python tuple, e.g., \"[('foo',)]\"."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/de.po:msgid "number of array dimensions exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/de.po:msgid "array size exceeds the maximum allowed"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/de.po:msgid "return value of function with array return type is not a Python sequence"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/de.po:msgid "To construct a multidimensional array, the inner sequences must all have the same length."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/zh_CN.po:msgid "cannot convert multidimensional array to Python list"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/zh_CN.po:msgid "PL/Python only supports one-dimensional arrays."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/zh_CN.po:"return value of function with array return type is not a Python sequence"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/zh_CN.po:#~ msgid "PL/Python does not support conversion to arrays of row types."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/fr.po:msgid "To return a composite type in an array, return the composite type as a Python tuple, e.g., \"[('foo',)]\"."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/fr.po:msgid "number of array dimensions exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/fr.po:msgid "array size exceeds the maximum allowed"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/fr.po:msgid "return value of function with array return type is not a Python sequence"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/fr.po:msgid "To construct a multidimensional array, the inner sequences must all have the same length."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/fr.po:#~ msgid "cannot convert multidimensional array to Python list"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/fr.po:#~ msgid "PL/Python only supports one-dimensional arrays."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/fr.po:#~ msgid "PL/Python does not support conversion to arrays of row types."
/srvr/z5089358/postgresql-10.4/src/pl/plpython/po/fr.po:#~ msgid "multidimensional arrays must have array expressions with matching dimensions. PL/Python function return value has sequence length %d while expected %d"
/srvr/z5089358/postgresql-10.4/src/pl/plpython/plpy_procedure.c:		proc->trftypes = isnull ? NIL : oid_array_to_list(protrftypes_datum);
/srvr/z5089358/postgresql-10.4/src/tutorial/syscat.source:-- lists all user-defined base types (not including array types)
/srvr/z5089358/postgresql-10.4/src/tutorial/syscat.source:    and t.typelem = 0    -- no arrays
/srvr/z5089358/postgresql-10.4/src/tutorial/intSet.c:        // array length extend
/srvr/z5089358/postgresql-10.4/src/tutorial/syscat.sql:-- lists all user-defined base types (not including array types)
/srvr/z5089358/postgresql-10.4/src/tutorial/syscat.sql:    and t.typelem = 0    -- no arrays
/srvr/z5089358/postgresql-10.4/src/include/executor/executor.h:	 * us to use the slot's Datum/isnull arrays as workspace.
/srvr/z5089358/postgresql-10.4/src/include/executor/execParallel.h:	/* These two arrays have pcxt->nworkers_launched entries: */
/srvr/z5089358/postgresql-10.4/src/include/executor/tuptable.h: *		4. "virtual" tuple consisting of Datum/isnull arrays
/srvr/z5089358/postgresql-10.4/src/include/executor/tuptable.h: * The Datum/isnull arrays of a TupleTableSlot serve double duty.  When the
/srvr/z5089358/postgresql-10.4/src/include/executor/tuptable.h: * slot contains a physical tuple, the arrays contain data extracted from
/srvr/z5089358/postgresql-10.4/src/include/executor/tuptable.h: * arrays.  When the slot is holding a "virtual" tuple this must be equal
/srvr/z5089358/postgresql-10.4/src/include/executor/nodeIndexscan.h:					   IndexArrayKeyInfo **arrayKeys, int *numArrayKeys);
/srvr/z5089358/postgresql-10.4/src/include/executor/nodeIndexscan.h:					   IndexArrayKeyInfo *arrayKeys, int numArrayKeys);
/srvr/z5089358/postgresql-10.4/src/include/executor/nodeIndexscan.h:extern bool ExecIndexAdvanceArrayKeys(IndexArrayKeyInfo *arrayKeys, int numArrayKeys);
/srvr/z5089358/postgresql-10.4/src/include/executor/execExpr.h: * array in execExprInterp.c:ExecInterpExpr().
/srvr/z5089358/postgresql-10.4/src/include/executor/execExpr.h:	/* Process an array subscript; short-circuit expression to NULL if NULL */
/srvr/z5089358/postgresql-10.4/src/include/executor/execExpr.h:	 * Compute old array element/slice when an ArrayRef assignment expression
/srvr/z5089358/postgresql-10.4/src/include/executor/execExpr.h:	/* non-existent operation, used e.g. to check array lengths */
/srvr/z5089358/postgresql-10.4/src/include/executor/execExpr.h:			int			nelems; /* length of the above arrays */
/srvr/z5089358/postgresql-10.4/src/include/executor/execExpr.h:			Oid			elemtype;	/* array element type */
/srvr/z5089358/postgresql-10.4/src/include/executor/execExpr.h:			int16		elemlength; /* typlen of the array element type */
/srvr/z5089358/postgresql-10.4/src/include/executor/execExpr.h:			bool		multidims;	/* is array expression multi-D? */
/srvr/z5089358/postgresql-10.4/src/include/executor/execExpr.h:		}			arrayexpr;
/srvr/z5089358/postgresql-10.4/src/include/executor/execExpr.h:			Oid			resultelemtype; /* element type of result array */
/srvr/z5089358/postgresql-10.4/src/include/executor/execExpr.h:			struct ArrayMapState *amstate;	/* workspace for array_map */
/srvr/z5089358/postgresql-10.4/src/include/executor/execExpr.h:		}			arraycoerce;
/srvr/z5089358/postgresql-10.4/src/include/executor/execExpr.h:		}			arrayref_subscript;
/srvr/z5089358/postgresql-10.4/src/include/executor/execExpr.h:		}			arrayref;
/srvr/z5089358/postgresql-10.4/src/include/executor/execExpr.h:			int16		typlen; /* array element type storage info */
/srvr/z5089358/postgresql-10.4/src/include/executor/execExpr.h:		}			scalararrayop;
/srvr/z5089358/postgresql-10.4/src/include/executor/execExpr.h:/* Non-inline data for array operations */
/srvr/z5089358/postgresql-10.4/src/include/executor/execExpr.h:	Oid			refelemtype;	/* OID of the array element type */
/srvr/z5089358/postgresql-10.4/src/include/executor/execExpr.h:	int16		refattrlength;	/* typlen of array type */
/srvr/z5089358/postgresql-10.4/src/include/executor/execExpr.h:	int16		refelemlength;	/* typlen of the array element type */
/srvr/z5089358/postgresql-10.4/src/include/executor/spi_priv.h: * Ordinarily, the _SPI_plan struct itself as well as the argtypes array
/srvr/z5089358/postgresql-10.4/src/include/executor/spi_priv.h: * argument type array, which is why it's seemingly-redundantly stored.
/srvr/z5089358/postgresql-10.4/src/include/executor/hashjoin.h:	/* buckets array is per-batch storage, as are all the tuples */
/srvr/z5089358/postgresql-10.4/src/include/executor/hashjoin.h:	int			skewBucketLen;	/* size of skewBucket array (a power of 2!) */
/srvr/z5089358/postgresql-10.4/src/include/executor/hashjoin.h:	int		   *skewBucketNums; /* array indexes of active skew buckets */
/srvr/z5089358/postgresql-10.4/src/include/executor/hashjoin.h:	 * These arrays are allocated for the life of the hash join, but only if
/srvr/z5089358/postgresql-10.4/src/include/executor/hashjoin.h:	 * (otherwise its pointer remains NULL).  Note that the zero'th array
/srvr/z5089358/postgresql-10.4/src/include/executor/hashjoin.h:	 * hashed. These are arrays of the same length as the number of hash join
/srvr/z5089358/postgresql-10.4/src/include/c.h: *		Index into any memory resident array.
/srvr/z5089358/postgresql-10.4/src/include/c.h: *		Offset into any memory resident array.
/srvr/z5089358/postgresql-10.4/src/include/c.h: * Specialized array types.  These are physically laid out just the same
/srvr/z5089358/postgresql-10.4/src/include/c.h: * as regular arrays (so that the regular array subscripting code works
/srvr/z5089358/postgresql-10.4/src/include/c.h: * pg_proc, and we can't use the normal btree array support routines for that
/srvr/z5089358/postgresql-10.4/src/include/c.h: *		Number of elements in an array.
/srvr/z5089358/postgresql-10.4/src/include/c.h:#define lengthof(array) (sizeof (array) / sizeof ((array)[0]))
/srvr/z5089358/postgresql-10.4/src/include/c.h: *		Address of the element one past the last in an array.
/srvr/z5089358/postgresql-10.4/src/include/c.h:#define endof(array)	(&(array)[lengthof(array)])
/srvr/z5089358/postgresql-10.4/src/include/statistics/statistics.h:/* size of the struct excluding the items array */
/srvr/z5089358/postgresql-10.4/src/include/statistics/statistics.h:/* size of the struct excluding the items array */
/srvr/z5089358/postgresql-10.4/src/include/statistics/statistics.h:/* size of the struct excluding the deps array */
/srvr/z5089358/postgresql-10.4/src/include/statistics/statistics.h:/* size of the struct excluding the deps array */
/srvr/z5089358/postgresql-10.4/src/include/rewrite/rowsecurity.h:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/include/pg_config.h.win32:/* Define to nothing if C supports flexible array members, and to 1 if it does
/srvr/z5089358/postgresql-10.4/src/include/pg_config.h.win32:/* Define to 1 if you have the external array `tzname'. */
/srvr/z5089358/postgresql-10.4/src/include/lib/simplehash.h:	 * Size of data / bucket array, 64 bits to handle UINT32_MAX sized hash
/srvr/z5089358/postgresql-10.4/src/include/lib/simplehash.h:/* max data array size,we allow up to PG_UINT32_MAX buckets, including 0 */
/srvr/z5089358/postgresql-10.4/src/include/lib/simplehash.h: * desired, the array of elements can be allocated using a passed-in allocator;
/srvr/z5089358/postgresql-10.4/src/include/lib/simplehash.h: * this could be useful in order to place the array of elements in a shared
/srvr/z5089358/postgresql-10.4/src/include/lib/simplehash.h: * Memory other than for the array of elements will still be allocated from
/srvr/z5089358/postgresql-10.4/src/include/lib/hyperloglog.h: *		hashesArr			array of hashes
/srvr/z5089358/postgresql-10.4/src/include/lib/binaryheap.h: *		bh_nodes		variable-length array of "space" nodes
/srvr/z5089358/postgresql-10.4/src/include/fe_utils/string_utils.h:extern bool parsePGArray(const char *atext, char ***itemarray, int *nitems);
/srvr/z5089358/postgresql-10.4/src/include/fe_utils/print.h:	const char **headers;		/* NULL-terminated array of header strings */
/srvr/z5089358/postgresql-10.4/src/include/fe_utils/print.h:	const char **cells;			/* NULL-terminated array of cell content
/srvr/z5089358/postgresql-10.4/src/include/libpq/hba.h: * Note: keep this in sync with the UserAuthName array in hba.c.
/srvr/z5089358/postgresql-10.4/src/include/optimizer/pathnode.h:extern void setup_simple_rel_arrays(PlannerInfo *root);
/srvr/z5089358/postgresql-10.4/src/include/pgstat.h:	 * st_progress_param array is command-specific.
/srvr/z5089358/postgresql-10.4/src/include/pgstat.h: * When we build the backend status array, we use LocalPgBackendStatus to be
/srvr/z5089358/postgresql-10.4/src/include/nodes/parsenodes.h:	List	   *arrayBounds;	/* array bounds */
/srvr/z5089358/postgresql-10.4/src/include/nodes/parsenodes.h: * Note: any array subscripting or selection of fields from composite columns
/srvr/z5089358/postgresql-10.4/src/include/nodes/parsenodes.h:	AEXPR_OP_ANY,				/* scalar op ANY (array) */
/srvr/z5089358/postgresql-10.4/src/include/nodes/parsenodes.h:	AEXPR_OP_ALL,				/* scalar op ALL (array) */
/srvr/z5089358/postgresql-10.4/src/include/nodes/parsenodes.h: * A_Indices - array subscript or slice bounds ([idx] or [lidx:uidx])
/srvr/z5089358/postgresql-10.4/src/include/nodes/parsenodes.h: * A_Indirection - select a field and/or array element from an expression
/srvr/z5089358/postgresql-10.4/src/include/nodes/parsenodes.h:	List	   *elements;		/* array element expressions */
/srvr/z5089358/postgresql-10.4/src/include/nodes/bitmapset.h:	int			nwords;			/* number of words in array */
/srvr/z5089358/postgresql-10.4/src/include/nodes/plannodes.h: * "CTID = pseudoconstant" or "CTID = ANY(pseudoconstant_array)".
/srvr/z5089358/postgresql-10.4/src/include/nodes/plannodes.h:	/* these are arrays, but have the same length as the mergeclauses list: */
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h:								 * combined into an array last argument */
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h: *	ArrayRef: describes an array subscripting operation
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h: * An ArrayRef can describe fetching a single element from an array,
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h: * fetching a subarray (array slice), storing a single element into
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h: * an array, or storing a slice.  The "store" cases work with an
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h: * initial array value and a source value that is inserted into the
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h: * appropriate part of the array; the result of the operation is an
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h: * entire new modified array value.
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h: * If reflowerindexpr = NIL, then we are fetching or storing a single array
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h: * fetching or storing an array slice, that is a rectangular subarray
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h: * NULL, meaning "substitute the array's current lower or upper bound".
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h: * element; but it is the array type when doing subarray fetch or either
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h: * Note: for the cases where an array is returned, if refexpr yields a R/W
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h: * expanded array, then the implementation is allowed to modify that object
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h:	Oid			refarraytype;	/* type of the array proper */
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h:	Oid			refelemtype;	/* type of the array elements */
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h:	int32		reftypmod;		/* typmod of the array (and elements too) */
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h:									 * array indexes */
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h:									 * array indexes, or NIL for single array
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h:	Expr	   *refexpr;		/* the expression that evaluates to an array
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h:								 * combined into an array last argument */
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h: * ScalarArrayOpExpr - expression node for "scalar op ANY/ALL (array)"
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h: * and each element of the righthand array, and the results are combined
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h:	List	   *args;			/* the scalar and array operands */
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h: * ARRAY requires just one target column, and creates an array of the target
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h: * ArrayCoerceExpr represents a type coercion from one array type to another,
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h: * function to each element of the source array.  If elemfuncid is InvalidOid
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h: * array header).
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h:	Expr	   *arg;			/* input expression (yields an array) */
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h:	Oid			resulttype;		/* output type of coercion (an array type) */
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h: * constituent expressions all yield arrays of element_typeid (ie, the same
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h: * type as array_typeid); at runtime we must check for compatible subscripts.
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h:	Oid			array_typeid;	/* type of expression result */
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h:	Oid			array_collid;	/* OID of collation, or InvalidOid if none */
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h:	Oid			element_typeid; /* common type of array elements */
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h:	List	   *elements;		/* the array elements or sub-arrays */
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h:	bool		multidims;		/* true if elements are sub-arrays */
/srvr/z5089358/postgresql-10.4/src/include/nodes/primnodes.h: *		UPDATE table SET arraycol[1] = ..., arraycol[2] = ..., ...
/srvr/z5089358/postgresql-10.4/src/include/nodes/relation.h:	/* NB: UPPERREL_FINAL must be last enum entry; it's used to size arrays */
/srvr/z5089358/postgresql-10.4/src/include/nodes/relation.h:	 * simple_rel_array holds pointers to "base rels" and "other rels" (see
/srvr/z5089358/postgresql-10.4/src/include/nodes/relation.h:	struct RelOptInfo **simple_rel_array;	/* All 1-rel RelOptInfos */
/srvr/z5089358/postgresql-10.4/src/include/nodes/relation.h:	int			simple_rel_array_size;	/* allocated size of array */
/srvr/z5089358/postgresql-10.4/src/include/nodes/relation.h:	 * simple_rte_array is the same length as simple_rel_array and holds
/srvr/z5089358/postgresql-10.4/src/include/nodes/relation.h:	RangeTblEntry **simple_rte_array;	/* rangetable as an array */
/srvr/z5089358/postgresql-10.4/src/include/nodes/relation.h: * In places where it's known that simple_rte_array[] must have been prepared
/srvr/z5089358/postgresql-10.4/src/include/nodes/relation.h:	((root)->simple_rte_array ? (root)->simple_rte_array[rti] : \
/srvr/z5089358/postgresql-10.4/src/include/nodes/relation.h: * simple_rel_array and join_rel_list respectively.
/srvr/z5089358/postgresql-10.4/src/include/nodes/relation.h: *		attr_needed - array of bitmapsets indicating the highest joinrel
/srvr/z5089358/postgresql-10.4/src/include/nodes/relation.h:	Relids	   *attr_needed;	/* array indexed [min_attr .. max_attr] */
/srvr/z5089358/postgresql-10.4/src/include/nodes/relation.h:	int32	   *attr_widths;	/* array indexed [min_attr .. max_attr] */
/srvr/z5089358/postgresql-10.4/src/include/nodes/relation.h: *		Zeroes in the indexkeys[] array indicate index columns that are
/srvr/z5089358/postgresql-10.4/src/include/nodes/relation.h:	bool		amsearcharray;	/* can AM handle ScalarArrayOpExpr quals? */
/srvr/z5089358/postgresql-10.4/src/include/nodes/relation.h: * The per-FK-column arrays can be fixed-size because we allow at most
/srvr/z5089358/postgresql-10.4/src/include/nodes/relation.h: * INDEX_MAX_KEYS columns in a foreign key constraint.  Each array has
/srvr/z5089358/postgresql-10.4/src/include/nodes/relation.h: * anyarray_ops would never work without this.  Use em_datatype when
/srvr/z5089358/postgresql-10.4/src/include/nodes/relation.h: * sortgrouprefs[] is an array of the same length as exprs, containing the
/srvr/z5089358/postgresql-10.4/src/include/nodes/relation.h: * "CTID = pseudoconstant" or "CTID = ANY(pseudoconstant_array)".
/srvr/z5089358/postgresql-10.4/src/include/nodes/params.h: *	  ParamListInfo arrays are used to pass parameters into the executor
/srvr/z5089358/postgresql-10.4/src/include/nodes/params.h: *	  for parameterized plans.  Each entry in the array defines the value
/srvr/z5089358/postgresql-10.4/src/include/nodes/params.h: *	  ptype == InvalidOid to signal an unused array entry.
/srvr/z5089358/postgresql-10.4/src/include/nodes/params.h: *	  array to support dynamic parameter handling.  First, if paramFetch
/srvr/z5089358/postgresql-10.4/src/include/nodes/params.h: *	  Although the data structure is really an array, not a list, we keep
/srvr/z5089358/postgresql-10.4/src/include/nodes/params.h: *	  array of ParamExecData records, which is referenced through
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	int			steps_alloc;	/* allocated length of steps array */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	Oid		   *ii_ExclusionOps;	/* array with one entry per column */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	Oid		   *ii_ExclusionProcs;	/* array with one entry per column */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	uint16	   *ii_ExclusionStrats; /* array with one entry per column */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	Oid		   *ii_UniqueOps;	/* array with one entry per column */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	Oid		   *ii_UniqueProcs; /* array with one entry per column */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	uint16	   *ii_UniqueStrats;	/* array with one entry per column */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	/* array of relation descriptors for indices */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	/* array of key/attr info for indices */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	/* array of trigger WHEN expr states */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	/* array of constraint-checking expr states */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	ResultRelInfo *es_result_relations; /* array of ResultRelInfos */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	int			es_num_result_relations;	/* length of array */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	ResultRelInfo *es_result_relation_info; /* currently active array elt */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	ResultRelInfo *es_root_result_relations;	/* array of ResultRelInfos */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	int			es_num_root_result_relations;	/* length of the array */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	 * particular array entry is valid; and es_epqScanDone[] is state to
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	HeapTuple  *es_epqTuple;	/* array of EPQ substitute tuples */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h: * are set to point to the caller's function arrays while doing such a search.
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	Datum		curArray;		/* most recent array from ARRAY() subplan */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	Node	  **elems;			/* array of expression states */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	ExprDoneCond *elemdone;		/* array of per-SRF is-done states */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	int			nelems;			/* length of elemdone[] array */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	int			mt_nplans;		/* number of plans in the array */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	int			mt_num_dispatch;	/* Number of entries in the above array */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:									 * arrays */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h: *		nplans			how many plans are in the array
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	PlanState **appendplans;	/* array of PlanStates for my inputs */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h: *		nplans			how many plans are in the array
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	PlanState **mergeplans;		/* array of PlanStates for my inputs */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	SortSupport ms_sortkeys;	/* array of length ms_nkeys */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	TupleTableSlot **ms_slots;	/* array of length ms_nplans */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	PlanState **bitmapplans;	/* array of PlanStates for my inputs */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	PlanState **bitmapplans;	/* array of PlanStates for my inputs */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	ExprState  *array_expr;		/* expr to evaluate to get array value */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	int			next_elem;		/* next array element to use */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	int			num_elems;		/* number of elems in current array value */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	Datum	   *elem_values;	/* array of num_elems Datums */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	bool	   *elem_nulls;		/* array of num_elems is-null flags */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h: *		TidList		   evaluated item pointers (array of size NumTids)
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	struct FunctionScanPerFuncState *funcstates;	/* array of length nfuncs */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h: *		exprlists			array of expression lists being evaluated
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h: *		array_len			size of array
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h: *		curr_idx			current array index (0-based)
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	int			array_len;
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	MergeJoinClause mj_Clauses; /* array of length mj_NumClauses */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h: *	ecxt_aggnulls arrays, which hold the computed agg values for the current
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	AggStatePerPhase phases;	/* array of all phases */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	AggStatePerGroup *hash_pergroup;	/* array of per-group pointers */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	struct TupleQueueReader **reader;	/* array with nreaders active entries */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	SortSupport gm_sortkeys;	/* array of length gm_nkeys */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	/* (but the arrays are not reallocated, just cleared) */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	TupleTableSlot **gm_slots;	/* array with nreaders+1 entries */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	struct TupleQueueReader **reader;	/* array with nreaders active entries */
/srvr/z5089358/postgresql-10.4/src/include/nodes/execnodes.h:	int			lr_ntables;		/* length of lr_curtuples[] array */
/srvr/z5089358/postgresql-10.4/src/include/parser/kwlist.h:PG_KEYWORD("array", ARRAY, RESERVED_KEYWORD)
/srvr/z5089358/postgresql-10.4/src/include/parser/parse_oper.h:extern Expr *make_scalar_array_op(ParseState *pstate, List *opname,
/srvr/z5089358/postgresql-10.4/src/include/parser/parse_node.h:extern Oid	transformArrayType(Oid *arrayType, int32 *arrayTypmod);
/srvr/z5089358/postgresql-10.4/src/include/parser/parse_node.h:						 Node *arrayBase,
/srvr/z5089358/postgresql-10.4/src/include/parser/parse_node.h:						 Oid arrayType,
/srvr/z5089358/postgresql-10.4/src/include/parser/parse_node.h:						 int32 arrayTypMod,
/srvr/z5089358/postgresql-10.4/src/include/access/spgist.h:	Datum	   *datums;			/* their datums (array of length nTuples) */
/srvr/z5089358/postgresql-10.4/src/include/access/spgist.h:	ScanKey		scankeys;		/* array of operators and comparison values */
/srvr/z5089358/postgresql-10.4/src/include/access/spgist.h:	int			nkeys;			/* length of array */
/srvr/z5089358/postgresql-10.4/src/include/access/spgist.h:	int		   *nodeNumbers;	/* their indexes in the node array */
/srvr/z5089358/postgresql-10.4/src/include/access/spgist.h:	ScanKey		scankeys;		/* array of operators and comparison values */
/srvr/z5089358/postgresql-10.4/src/include/access/spgist.h:	int			nkeys;			/* length of array */
/srvr/z5089358/postgresql-10.4/src/include/access/skey.h: * a table or index column and a constant.  When it's part of an array of
/srvr/z5089358/postgresql-10.4/src/include/access/skey.h: * argument type, but rather an array of such values, and the per-element
/srvr/z5089358/postgresql-10.4/src/include/access/skey.h: * only those that set amsearcharray or amsearchnulls respectively.
/srvr/z5089358/postgresql-10.4/src/include/access/skey.h: * a separate array of ScanKeys, one for each column of the row comparison.
/srvr/z5089358/postgresql-10.4/src/include/access/skey.h: *		sk_argument: pointer to subsidiary ScanKey array
/srvr/z5089358/postgresql-10.4/src/include/access/skey.h: * If the header is part of a ScanKey array that's sorted by attno, it
/srvr/z5089358/postgresql-10.4/src/include/access/skey.h: * The subsidiary ScanKey array appears in logical column order of the row
/srvr/z5089358/postgresql-10.4/src/include/access/skey.h: * comparison, which may be different from index column order.  The array
/srvr/z5089358/postgresql-10.4/src/include/access/skey.h: * elements are like a normal ScanKey array except that:
/srvr/z5089358/postgresql-10.4/src/include/access/skey.h: * sk_strategy must be the same in all elements of the subsidiary array,
/srvr/z5089358/postgresql-10.4/src/include/access/amapi.h:	bool		amsearcharray;
/srvr/z5089358/postgresql-10.4/src/include/access/htup_details.h: * require increases in the size of work arrays.
/srvr/z5089358/postgresql-10.4/src/include/access/gist_private.h: * local arrays used during split.  Note that there is also a limit on the
/srvr/z5089358/postgresql-10.4/src/include/access/gist_private.h:	/* pre-allocated workspace arrays */
/srvr/z5089358/postgresql-10.4/src/include/access/gist_private.h:	OffsetNumber nPageData;		/* number of valid items in array */
/srvr/z5089358/postgresql-10.4/src/include/access/gist_private.h:	 * resizable array of free blocks.
/srvr/z5089358/postgresql-10.4/src/include/access/gist_private.h:	int			nFreeBlocks;	/* # of currently free blocks in the array */
/srvr/z5089358/postgresql-10.4/src/include/access/gist_private.h:	int			freeBlocksLen;	/* current allocated length of the array */
/srvr/z5089358/postgresql-10.4/src/include/access/gist_private.h:	 * Dynamically-sized array of buffers that currently have their last page
/srvr/z5089358/postgresql-10.4/src/include/access/heapam_xlog.h: * 'offsets' array is omitted if the whole page is reinitialized
/srvr/z5089358/postgresql-10.4/src/include/access/heapam_xlog.h: * The array of OffsetNumbers following the fixed part of the record contains:
/srvr/z5089358/postgresql-10.4/src/include/access/heapam_xlog.h: * Backup block 0's data contains an array of xl_heap_freeze_tuple structs,
/srvr/z5089358/postgresql-10.4/src/include/access/tupmacs.h: * check to see if the ATT'th bit of an array of 8-bit bytes is set.
/srvr/z5089358/postgresql-10.4/src/include/access/tupmacs.h: *	* within arrays, we unconditionally align varlenas (XXX this should be
/srvr/z5089358/postgresql-10.4/src/include/access/spgist_private.h:	ScanKey		keyData;		/* array of index qualifier descriptors */
/srvr/z5089358/postgresql-10.4/src/include/access/spgist_private.h: * header/optional prefix/array of nodes, which are SpGistNodeTuples
/srvr/z5089358/postgresql-10.4/src/include/access/brin_page.h:	 * This array will fill all available space on the page.  It should be
/srvr/z5089358/postgresql-10.4/src/include/access/brin_page.h:/* max num of items in the array */
/srvr/z5089358/postgresql-10.4/src/include/access/gist.h: * is responsible for palloc'ing both of these arrays!).  The tuple counts
/srvr/z5089358/postgresql-10.4/src/include/access/gist.h:	OffsetNumber *spl_left;		/* array of entries that go left */
/srvr/z5089358/postgresql-10.4/src/include/access/gist.h:	int			spl_nleft;		/* size of this array */
/srvr/z5089358/postgresql-10.4/src/include/access/gist.h:	OffsetNumber *spl_right;	/* array of entries that go right */
/srvr/z5089358/postgresql-10.4/src/include/access/gist.h:	int			spl_nright;		/* size of the array */
/srvr/z5089358/postgresql-10.4/src/include/access/slru.h:	 * Optional array of WAL flush LSNs associated with entries in the SLRU
/srvr/z5089358/postgresql-10.4/src/include/access/nbtree.h: * into a separate workspace array; each BTScanPosItem stores its tuple's
/srvr/z5089358/postgresql-10.4/src/include/access/nbtree.h: * offset within that array.
/srvr/z5089358/postgresql-10.4/src/include/access/nbtree.h:	BlockNumber currPage;		/* page referenced by items array */
/srvr/z5089358/postgresql-10.4/src/include/access/nbtree.h:	 * The items array is always ordered in index order (ie, increasing
/srvr/z5089358/postgresql-10.4/src/include/access/nbtree.h:	 * array back-to-front, so we start at the last slot and fill downwards.
/srvr/z5089358/postgresql-10.4/src/include/access/nbtree.h:	int			scan_key;		/* index of associated key in arrayKeyData */
/srvr/z5089358/postgresql-10.4/src/include/access/nbtree.h:	int			num_elems;		/* number of elems in current array value */
/srvr/z5089358/postgresql-10.4/src/include/access/nbtree.h:	Datum	   *elem_values;	/* array of num_elems Datums */
/srvr/z5089358/postgresql-10.4/src/include/access/nbtree.h:	ScanKey		keyData;		/* array of preprocessed scan keys */
/srvr/z5089358/postgresql-10.4/src/include/access/nbtree.h:	ScanKey		arrayKeyData;	/* modified copy of scan->keyData */
/srvr/z5089358/postgresql-10.4/src/include/access/nbtree.h:	int			numArrayKeys;	/* number of equality-type array keys (-1 if
/srvr/z5089358/postgresql-10.4/src/include/access/nbtree.h:								 * there are any unsatisfiable array keys) */
/srvr/z5089358/postgresql-10.4/src/include/access/nbtree.h:	int			arrayKeyCount;	/* count indicating number of array scan keys
/srvr/z5089358/postgresql-10.4/src/include/access/nbtree.h:	BTArrayKeyInfo *arrayKeys;	/* info about each equality-type array key */
/srvr/z5089358/postgresql-10.4/src/include/access/nbtree.h:	MemoryContext arrayContext; /* scan-lifespan context for array data */
/srvr/z5089358/postgresql-10.4/src/include/access/nbtree.h: * index's indoption[] array entry for the index attribute.
/srvr/z5089358/postgresql-10.4/src/include/access/nbtree.h:extern void _bt_parallel_advance_array_keys(IndexScanDesc scan);
/srvr/z5089358/postgresql-10.4/src/include/access/nbtree.h:extern void _bt_preprocess_array_keys(IndexScanDesc scan);
/srvr/z5089358/postgresql-10.4/src/include/access/nbtree.h:extern void _bt_start_array_keys(IndexScanDesc scan, ScanDirection dir);
/srvr/z5089358/postgresql-10.4/src/include/access/nbtree.h:extern bool _bt_advance_array_keys(IndexScanDesc scan, ScanDirection dir);
/srvr/z5089358/postgresql-10.4/src/include/access/nbtree.h:extern void _bt_mark_array_keys(IndexScanDesc scan);
/srvr/z5089358/postgresql-10.4/src/include/access/nbtree.h:extern void _bt_restore_array_keys(IndexScanDesc scan);
/srvr/z5089358/postgresql-10.4/src/include/access/reloptions.h: * Note: the functions dealing with text-array reloptions values declare
/srvr/z5089358/postgresql-10.4/src/include/access/reloptions.h: * them as Datum, not ArrayType *, to avoid needing to include array.h
/srvr/z5089358/postgresql-10.4/src/include/access/reloptions.h: * The normal way to use this is to loop on the relopt_value array returned by
/srvr/z5089358/postgresql-10.4/src/include/access/ginblock.h: * Leaf pages contain GinPostingLists and an uncompressed array of item
/srvr/z5089358/postgresql-10.4/src/include/access/ginblock.h: * that's the beginning of the array of PostingItems. For compressed leaf
/srvr/z5089358/postgresql-10.4/src/include/access/ginblock.h: * pages, it's the beginning of the ItemPointer array.
/srvr/z5089358/postgresql-10.4/src/include/access/brin_tuple.h: * has (besides the null flags) an array of Datum whose size is determined by
/srvr/z5089358/postgresql-10.4/src/include/access/brin_tuple.h:	/* output arrays for brin_deform_tuple: */
/srvr/z5089358/postgresql-10.4/src/include/access/brin_tuple.h:	Datum	   *bt_values;		/* values array */
/srvr/z5089358/postgresql-10.4/src/include/access/brin_tuple.h:	bool	   *bt_allnulls;	/* allnulls array */
/srvr/z5089358/postgresql-10.4/src/include/access/brin_tuple.h:	bool	   *bt_hasnulls;	/* hasnulls array */
/srvr/z5089358/postgresql-10.4/src/include/access/brin_tuple.h:	/* not an output array, but must be last */
/srvr/z5089358/postgresql-10.4/src/include/access/relscan.h:	ScanKey		rs_key;			/* array of scan key descriptors */
/srvr/z5089358/postgresql-10.4/src/include/access/relscan.h:	ScanKey		keyData;		/* array of index qualifier descriptors */
/srvr/z5089358/postgresql-10.4/src/include/access/relscan.h:	ScanKey		orderByData;	/* array of ordering op descriptors */
/srvr/z5089358/postgresql-10.4/src/include/access/hash.h:	uint16		hashm_bmsize;	/* bitmap array size (bytes) - must be a power
/srvr/z5089358/postgresql-10.4/src/include/access/hash.h:	uint16		hashm_bmshift;	/* log2(bitmap array size in BITS) */
/srvr/z5089358/postgresql-10.4/src/include/access/hash.h: * giant bit array.  The number of bits that fit on a page obviously
/srvr/z5089358/postgresql-10.4/src/include/access/spgxlog.h:	 *		array of deleted tuple numbers, length nMoves
/srvr/z5089358/postgresql-10.4/src/include/access/spgxlog.h:	 *		array of inserted tuple numbers, length nMoves + 1 or 1
/srvr/z5089358/postgresql-10.4/src/include/access/spgxlog.h: * Buffer references in the rdata array are:
/srvr/z5089358/postgresql-10.4/src/include/access/spgxlog.h:	 *		array of deleted tuple numbers, length nDelete
/srvr/z5089358/postgresql-10.4/src/include/access/spgxlog.h:	 *		array of inserted tuple numbers, length nInsert
/srvr/z5089358/postgresql-10.4/src/include/access/spgxlog.h:	 *		array of page selector bytes for inserted tuples, length nInsert
/srvr/z5089358/postgresql-10.4/src/include/access/tupdesc.h:	AttrDefault *defval;		/* array */
/srvr/z5089358/postgresql-10.4/src/include/access/tupdesc.h:	ConstrCheck *check;			/* array */
/srvr/z5089358/postgresql-10.4/src/include/access/gistxlog.h:	 * follow: 1. gistxlogPage and array of IndexTupleData per page
/srvr/z5089358/postgresql-10.4/src/include/access/gin_private.h:	/* array of GinScanEntry pointers, one per extracted search condition */
/srvr/z5089358/postgresql-10.4/src/include/access/gin_private.h:	/* array of check flags, reported to consistentFn */
/srvr/z5089358/postgresql-10.4/src/include/access/gin_private.h:	/* NB: these three arrays have only nuserentries elements! */
/srvr/z5089358/postgresql-10.4/src/include/access/nbtxlog.h: * have a zero length array of offsets. Earlier records must have at least one.
/srvr/z5089358/postgresql-10.4/src/include/access/ginxlog.h:	/* array of inserted tuples follows */
/srvr/z5089358/postgresql-10.4/src/include/access/ginxlog.h:	/* array of inserted tuples follows */
/srvr/z5089358/postgresql-10.4/src/include/utils/rel.h:	 * arrays are indexed by support function number, which is a sufficient
/srvr/z5089358/postgresql-10.4/src/include/utils/rel.h: * The per-FK-column arrays can be fixed-size because we allow at most
/srvr/z5089358/postgresql-10.4/src/include/utils/rel.h:	/* these arrays each have nkeys valid entries: */
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * array.h
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: *	  Declarations for Postgres arrays.
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * A standard varlena array has the following internal structure:
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: *	  <ndim>		- number of dimensions of the array
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: *	  <dimensions>	- length of each array axis (C array of int)
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: *	  <lower bnds>	- lower boundary of each dimension (C array of int)
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * The <dimensions> and <lower bnds> arrays each have ndim elements.
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * The <null bitmap> may be omitted if the array contains no NULL elements.
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * <dataoffset> is nonzero and is equal to the offset from the array start
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * array are aligned as specified by the array element type.  They are
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * NOTE: it is important that array elements of toastable datatypes NOT be
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * the toaster to compress the whole array as one input.)
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * generic arrays, but they support only one-dimensional arrays with no
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * There are also some "fixed-length array" datatypes, such as NAME and
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * We support subscripting on these types, but array_in() and array_out()
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * only work with varlena arrays.
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * In addition, arrays are a major user of the "expanded object" TOAST
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * infrastructure.  This allows a varlena array to be converted to a
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * arrays holding the elements.
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * src/include/utils/array.h
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * CAUTION: if you change the header for ordinary arrays you will also
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * An expanded array is contained within a private memory context (as
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * The expanded array might contain a regular "flat" array if that was the
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * contents are represented by Datum/isnull arrays plus dimensionality and
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * the original array for access purposes but not yet changed it.  For pass-
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * by-reference element types, the Datums would point into the flat array in
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * this situation.  Once we start modifying array elements, new pass-by-ref
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:	/* Magic value identifying an expanded array (for debugging only) */
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:	int		   *dims;			/* array dimensions */
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:	 * If we have a Datum-array representation of the array, it's kept here;
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:	 * else dvalues/dnulls are NULL.  The dvalues and dnulls arrays are always
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:	Datum	   *dvalues;		/* array of Datums */
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:	bool	   *dnulls;			/* array of is-null flags for Datums */
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:	int			dvalueslen;		/* allocated length of above arrays */
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:	int			nelems;			/* number of valid entries in above arrays */
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:	 * the expanded array, if known; otherwise it's 0.  We store this to make
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:	ArrayType  *fvalue;			/* must be a fully detoasted array */
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * Functions that can handle either a "flat" varlena array or an expanded
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * array use this union to work with their input.
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * note that the input must be scalars (legal array elements)
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:	Datum	   *dvalues;		/* array of accumulated Datums */
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:	bool	   *dnulls;			/* array of is-null flags for Datums */
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:	int			alen;			/* allocated length of above arrays */
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:	int			nelems;			/* number of valid entries in above arrays */
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * note that the input must be arrays, and the same array type is returned
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:	Oid			array_type;		/* data type of the arrays */
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:	Oid			element_type;	/* data type of the array elements */
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:	ArrayBuildStateArr *arraystate;
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * structure to cache type metadata needed for array manipulation
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * private state needed by array_map (here because caller must provide it)
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:/* ArrayIteratorData is private in arrayfuncs.c */
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:/* fmgr macros for regular varlena array objects */
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:/* fmgr macros for expanded array objects */
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * Access macros for varlena array header fields.
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * ARR_DIMS returns a pointer to an array of array dimensions (number of
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * elements along the various array axes).
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * ARR_LBOUND returns a pointer to an array of array lower bounds.
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * That is: if the third axis of an array has elements 5 through 8, then
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * The total array header size (in bytes) for an array with the specified
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * Returns a pointer to the actual array data.
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * prototypes for functions defined in arrayfuncs.c
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:extern void CopyArrayEls(ArrayType *array,
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:extern Datum array_get_element(Datum arraydatum, int nSubscripts, int *indx,
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:				  int arraytyplen, int elmlen, bool elmbyval, char elmalign,
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:extern Datum array_set_element(Datum arraydatum, int nSubscripts, int *indx,
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:				  int arraytyplen, int elmlen, bool elmbyval, char elmalign);
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:extern Datum array_get_slice(Datum arraydatum, int nSubscripts,
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:				int arraytyplen, int elmlen, bool elmbyval, char elmalign);
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:extern Datum array_set_slice(Datum arraydatum, int nSubscripts,
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:				int arraytyplen, int elmlen, bool elmbyval, char elmalign);
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:extern Datum array_ref(ArrayType *array, int nSubscripts, int *indx,
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:		  int arraytyplen, int elmlen, bool elmbyval, char elmalign,
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:extern ArrayType *array_set(ArrayType *array, int nSubscripts, int *indx,
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:		  int arraytyplen, int elmlen, bool elmbyval, char elmalign);
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:extern Datum array_map(FunctionCallInfo fcinfo, Oid retType,
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:extern void array_bitmap_copy(bits8 *destbitmap, int destoffset,
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:extern ArrayType *construct_array(Datum *elems, int nelems,
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:extern ArrayType *construct_md_array(Datum *elems,
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:extern ArrayType *construct_empty_array(Oid elmtype);
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:extern ExpandedArrayHeader *construct_empty_expanded_array(Oid element_type,
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:extern void deconstruct_array(ArrayType *array,
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:extern bool array_contains_nulls(ArrayType *array);
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:extern ArrayBuildStateArr *initArrayResultArr(Oid array_type, Oid element_type,
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:					Oid array_type,
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:extern ArrayIterator array_create_iterator(ArrayType *arr, int slice_ndim, ArrayMetaState *mstate);
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:extern bool array_iterate(ArrayIterator iterator, Datum *value, bool *isnull);
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:extern void array_free_iterator(ArrayIterator iterator);
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * prototypes for functions defined in arrayutils.c
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h: * prototypes for functions defined in array_expanded.c
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:extern Datum expand_array(Datum arraydatum, MemoryContext parentcontext,
/srvr/z5089358/postgresql-10.4/src/include/utils/array.h:extern void deconstruct_expanded_array(ExpandedArrayHeader *eah);
/srvr/z5089358/postgresql-10.4/src/include/utils/typcache.h:	 * information hasn't yet been requested.  Also note that for array and
/srvr/z5089358/postgresql-10.4/src/include/utils/typcache.h:	 * to functions such as array_eq, array_cmp, hash_array.  There is not
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonb.h:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonb.h: * boolean value, numeric value, or string value.  However, array elements
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonb.h: * supports the definition of the "exists" operator, which treats array
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonb.h:#define JGINFLAG_KEY	0x01	/* key (or string array element) */
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonb.h:#define JGINFLAG_STR	0x05	/* string value (if not an array element) */
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonb.h: * header indicates what kind of a node it is, e.g. a string or an array,
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonb.h: * Instead, the container array or object has an array that holds the JEntrys
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonb.h: * The root node is an exception; it has no parent array or object that could
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonb.h: * is implicitly known that the root node must be an array or an object,
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonb.h: * the two.  For that purpose, both an array and an object begin with a uint32
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonb.h: * an array with one element, with the flags in the array's header field set
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonb.h: * always stored an offset, but this resulted in JEntry arrays with horrible
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonb.h: * but it makes random access into large arrays expensive (O(N) not O(1)).
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonb.h:#define JENTRY_ISCONTAINER		0x50000000	/* array or object */
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonb.h: * A jsonb array or object node, within a Jsonb Datum.
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonb.h: * An array has one child for each element, stored in array order.
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonb.h:			bool		rawScalar;	/* Top-level "raw scalar" array? */
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonb.h:		}			array;		/* Array container type */
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonb.h:	uint32		nElems;			/* Number of elements in children array (will
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonb.h:	bool		isScalar;		/* Pseudo-array scalar value? */
/srvr/z5089358/postgresql-10.4/src/include/utils/snapshot.h:	 * is stored as an optimization to avoid needing to search the XID arrays
/srvr/z5089358/postgresql-10.4/src/include/utils/snapshot.h:	bool		suboverflowed;	/* has the subxip array overflowed? */
/srvr/z5089358/postgresql-10.4/src/include/utils/arrayaccess.h: * arrayaccess.h
/srvr/z5089358/postgresql-10.4/src/include/utils/arrayaccess.h: *	  Declarations for element-by-element access to Postgres arrays.
/srvr/z5089358/postgresql-10.4/src/include/utils/arrayaccess.h: * src/include/utils/arrayaccess.h
/srvr/z5089358/postgresql-10.4/src/include/utils/arrayaccess.h:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/include/utils/arrayaccess.h: * Functions for iterating through elements of a flat or expanded array.
/srvr/z5089358/postgresql-10.4/src/include/utils/arrayaccess.h: * These require a state struct "array_iter iter".
/srvr/z5089358/postgresql-10.4/src/include/utils/arrayaccess.h: * Use "array_iter_setup(&iter, arrayptr);" to prepare to iterate, and
/srvr/z5089358/postgresql-10.4/src/include/utils/arrayaccess.h: * "datumvar = array_iter_next(&iter, &isnullvar, index, ...);" to fetch
/srvr/z5089358/postgresql-10.4/src/include/utils/arrayaccess.h:typedef struct array_iter
/srvr/z5089358/postgresql-10.4/src/include/utils/arrayaccess.h:	/* datumptr being NULL or not tells if we have flat or expanded array */
/srvr/z5089358/postgresql-10.4/src/include/utils/arrayaccess.h:	/* Fields used when we have an expanded array */
/srvr/z5089358/postgresql-10.4/src/include/utils/arrayaccess.h:	Datum	   *datumptr;		/* Pointer to Datum array */
/srvr/z5089358/postgresql-10.4/src/include/utils/arrayaccess.h:	bool	   *isnullptr;		/* Pointer to isnull array */
/srvr/z5089358/postgresql-10.4/src/include/utils/arrayaccess.h:	/* Fields used when we have a flat array */
/srvr/z5089358/postgresql-10.4/src/include/utils/arrayaccess.h:} array_iter;
/srvr/z5089358/postgresql-10.4/src/include/utils/arrayaccess.h:array_iter_setup(array_iter *it, AnyArrayType *a)
/srvr/z5089358/postgresql-10.4/src/include/utils/arrayaccess.h:			/* Work with flat array embedded in the expanded datum */
/srvr/z5089358/postgresql-10.4/src/include/utils/arrayaccess.h:array_iter_next(array_iter *it, bool *isnull, int i,
/srvr/z5089358/postgresql-10.4/src/include/utils/acl.h: *	  An ACL array is simply an array of AclItems, representing the union
/srvr/z5089358/postgresql-10.4/src/include/utils/acl.h: *	  array represents "no privileges".
/srvr/z5089358/postgresql-10.4/src/include/utils/acl.h: *	  The order of items in the array is important as client utilities (in
/srvr/z5089358/postgresql-10.4/src/include/utils/acl.h: *	  to issue GRANTs in the ordering of the items in the array.  The reason
/srvr/z5089358/postgresql-10.4/src/include/utils/acl.h:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/include/utils/acl.h: * Definitions for convenient access to Acl (array of AclItem).
/srvr/z5089358/postgresql-10.4/src/include/utils/acl.h: * These are standard PostgreSQL arrays, but are restricted to have one
/srvr/z5089358/postgresql-10.4/src/include/utils/acl.h: * CAUTION: as of PostgreSQL 7.1, these arrays are toastable (just like all
/srvr/z5089358/postgresql-10.4/src/include/utils/acl.h: * other array types).  Therefore, be careful to detoast them with the
/srvr/z5089358/postgresql-10.4/src/include/utils/acl.h: * macros provided, unless you know for certain that a particular array
/srvr/z5089358/postgresql-10.4/src/include/utils/acl.h: * Acl			a one-dimensional array of AclItem
/srvr/z5089358/postgresql-10.4/src/include/utils/datetime.h:	int			numabbrevs;		/* number of entries in abbrevs[] array */
/srvr/z5089358/postgresql-10.4/src/include/utils/datetime.h:	/* DynamicZoneAbbrev(s) may follow the abbrevs[] array */
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonapi.h:	json_struct_action array_start;
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonapi.h:	json_struct_action array_end;
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonapi.h:	json_aelem_action array_element_start;
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonapi.h:	json_aelem_action array_element_end;
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonapi.h: * json_count_array_elements performs a fast secondary parse to determine the
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonapi.h: * number of elements in passed array lex context. It should be called from an
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonapi.h: * array_start action.
/srvr/z5089358/postgresql-10.4/src/include/utils/jsonapi.h:extern int	json_count_array_elements(JsonLexContext *lex);
/srvr/z5089358/postgresql-10.4/src/include/utils/guc.h:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/include/utils/guc.h: * The possible values of an enum variable are specified by an array of
/srvr/z5089358/postgresql-10.4/src/include/utils/guc.h:extern void ProcessGUCArray(ArrayType *array,
/srvr/z5089358/postgresql-10.4/src/include/utils/guc.h:extern ArrayType *GUCArrayAdd(ArrayType *array, const char *name, const char *value);
/srvr/z5089358/postgresql-10.4/src/include/utils/guc.h:extern ArrayType *GUCArrayDelete(ArrayType *array, const char *name);
/srvr/z5089358/postgresql-10.4/src/include/utils/guc.h:extern ArrayType *GUCArrayReset(ArrayType *array);
/srvr/z5089358/postgresql-10.4/src/include/utils/selfuncs.h:extern Selectivity scalararraysel(PlannerInfo *root,
/srvr/z5089358/postgresql-10.4/src/include/utils/selfuncs.h:extern int	estimate_array_length(Node *arrayexpr);
/srvr/z5089358/postgresql-10.4/src/include/utils/selfuncs.h:/* Functions in array_selfuncs.c */
/srvr/z5089358/postgresql-10.4/src/include/utils/selfuncs.h:extern Selectivity scalararraysel_containment(PlannerInfo *root,
/srvr/z5089358/postgresql-10.4/src/include/utils/lsyscache.h:	Datum	   *values;			/* slot's "values" array, or NULL if none */
/srvr/z5089358/postgresql-10.4/src/include/utils/lsyscache.h:	float4	   *numbers;		/* slot's "numbers" array, or NULL if none */
/srvr/z5089358/postgresql-10.4/src/include/utils/lsyscache.h:	void	   *values_arr;		/* palloc'd values array, if any */
/srvr/z5089358/postgresql-10.4/src/include/utils/lsyscache.h:	void	   *numbers_arr;	/* palloc'd numbers array, if any */
/srvr/z5089358/postgresql-10.4/src/include/utils/lsyscache.h:extern Oid	get_array_type(Oid typid);
/srvr/z5089358/postgresql-10.4/src/include/utils/lsyscache.h:extern Oid	get_promoted_array_type(Oid typid);
/srvr/z5089358/postgresql-10.4/src/include/utils/lsyscache.h:#define type_is_array(typid)  (get_element_type(typid) != InvalidOid)
/srvr/z5089358/postgresql-10.4/src/include/utils/lsyscache.h:/* type_is_array_domain accepts both plain arrays and domains over arrays */
/srvr/z5089358/postgresql-10.4/src/include/utils/lsyscache.h:#define type_is_array_domain(typid)  (get_base_element_type(typid) != InvalidOid)
/srvr/z5089358/postgresql-10.4/src/include/utils/syscache.h: *		of the entries in the array cacheinfo[] in syscache.c.
/srvr/z5089358/postgresql-10.4/src/include/utils/relcache.h: *		array.  -cim 9/10/89
/srvr/z5089358/postgresql-10.4/src/include/utils/expandeddatum.h: * Complex data types, particularly container types such as arrays and
/srvr/z5089358/postgresql-10.4/src/include/utils/tzparser.h: * The result of parsing a timezone configuration file is an array of
/srvr/z5089358/postgresql-10.4/src/include/utils/geo_decls.h: * POLYGON - Specified by an array of doubles defining the points,
/srvr/z5089358/postgresql-10.4/src/include/utils/plancache.h:	Oid		   *param_types;	/* array of parameter type OIDs, or NULL */
/srvr/z5089358/postgresql-10.4/src/include/utils/plancache.h:	int			num_params;		/* length of param_types array */
/srvr/z5089358/postgresql-10.4/src/include/utils/reltrigger.h:	Trigger    *triggers;		/* array of Trigger structs */
/srvr/z5089358/postgresql-10.4/src/include/utils/reltrigger.h:	int			numtriggers;	/* number of array entries */
/srvr/z5089358/postgresql-10.4/src/include/utils/reltrigger.h:	 * These flags indicate whether the array contains at least one of each
/srvr/z5089358/postgresql-10.4/src/include/utils/reltrigger.h:	 * type of trigger.  We use these to skip searching the array if not.
/srvr/z5089358/postgresql-10.4/src/include/tsearch/ts_type.h: * 2) int32		size - number of lexemes (WordEntry array entries)
/srvr/z5089358/postgresql-10.4/src/include/tsearch/ts_type.h: *				array to start of lexeme's string, which is of length len.
/srvr/z5089358/postgresql-10.4/src/include/tsearch/ts_type.h:	/* lexemes follow the entries[] array */
/srvr/z5089358/postgresql-10.4/src/include/tsearch/ts_type.h:/* pointer to start of a tsvector's WordEntry array */
/srvr/z5089358/postgresql-10.4/src/include/tsearch/ts_type.h: *	(len)(size)(array of QueryItem)(operands as '\0'-terminated c-strings)
/srvr/z5089358/postgresql-10.4/src/include/tsearch/dicts/spell.h:	/* number of entries in CompoundAffixFlags array */
/srvr/z5089358/postgresql-10.4/src/include/tsearch/dicts/spell.h:	/* allocated length of CompoundAffixFlags array */
/srvr/z5089358/postgresql-10.4/src/include/tsearch/dicts/spell.h:	/* Temporary array of all words in the dict file */
/srvr/z5089358/postgresql-10.4/src/include/tsearch/dicts/spell.h:	int			nspell;			/* number of valid entries in Spell array */
/srvr/z5089358/postgresql-10.4/src/include/tsearch/dicts/spell.h:	int			mspell;			/* allocated length of Spell array */
/srvr/z5089358/postgresql-10.4/src/include/tsearch/ts_utils.h:		 * When apos array is used, apos[0] is the number of elements in the
/srvr/z5089358/postgresql-10.4/src/include/tsearch/ts_utils.h:		 * array (excluding apos[0]), and alen is the allocated size of the
/srvr/z5089358/postgresql-10.4/src/include/tsearch/ts_utils.h:		 * array.
/srvr/z5089358/postgresql-10.4/src/include/tsearch/ts_utils.h: * consult the position bits of the pos array, ie, WEP_GETPOS(data->pos[i]).
/srvr/z5089358/postgresql-10.4/src/include/tsearch/ts_utils.h: * portion of a tsvector value.  If "allocated" is true then the pos array
/srvr/z5089358/postgresql-10.4/src/include/tsearch/ts_utils.h: * "negate" means that the pos array contains positions where the query does
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_operator.h:DATA(insert OID = 349 (  "||"	   PGNSP PGUID b f f 2277 2283 2277 0 0 array_append   -	   -	 ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_operator.h:DESCR("append element onto end of array");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_operator.h:DATA(insert OID = 374 (  "||"	   PGNSP PGUID b f f 2283 2277 2277 0 0 array_prepend  -	   -	 ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_operator.h:DESCR("prepend element onto front of array");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_operator.h:DATA(insert OID = 375 (  "||"	   PGNSP PGUID b f f 2277 2277 2277 0 0 array_cat	   -	   -	 ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_operator.h:/* generic array comparison operators */
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_operator.h:DATA(insert OID = 1070 (  "="	   PGNSP PGUID b t t 2277 2277 16 1070 1071 array_eq eqsel eqjoinsel ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_operator.h:DATA(insert OID = 1071 (  "<>"	   PGNSP PGUID b f f 2277 2277 16 1071 1070 array_ne neqsel neqjoinsel ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_operator.h:DATA(insert OID = 1072 (  "<"	   PGNSP PGUID b f f 2277 2277 16 1073 1075 array_lt scalarltsel scalarltjoinsel ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_operator.h:DATA(insert OID = 1073 (  ">"	   PGNSP PGUID b f f 2277 2277 16 1072 1074 array_gt scalargtsel scalargtjoinsel ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_operator.h:DATA(insert OID = 1074 (  "<="	   PGNSP PGUID b f f 2277 2277 16 1075 1073 array_le scalarltsel scalarltjoinsel ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_operator.h:DATA(insert OID = 1075 (  ">="	   PGNSP PGUID b f f 2277 2277 16 1074 1072 array_ge scalargtsel scalargtjoinsel ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_operator.h:/* overlap/contains/contained for arrays */
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_operator.h:DATA(insert OID = 2750 (  "&&"	   PGNSP PGUID b f f 2277 2277	16 2750  0 arrayoverlap arraycontsel arraycontjoinsel ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_operator.h:DATA(insert OID = 2751 (  "@>"	   PGNSP PGUID b f f 2277 2277	16 2752  0 arraycontains arraycontsel arraycontjoinsel ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_operator.h:DATA(insert OID = 2752 (  "<@"	   PGNSP PGUID b f f 2277 2277	16 2751  0 arraycontained arraycontsel arraycontjoinsel ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_operator.h:DATA(insert OID = 3964 (  "->"	   PGNSP PGUID b f f 114 23 114 0 0 json_array_element - - ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_operator.h:DESCR("get json array element");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_operator.h:DATA(insert OID = 3965 (  "->>"    PGNSP PGUID b f f 114 23 25 0 0 json_array_element_text - - ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_operator.h:DESCR("get json array element as text");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_operator.h:DATA(insert OID = 3212 (  "->"	   PGNSP PGUID b f f 3802 23 3802 0 0 jsonb_array_element - - ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_operator.h:DESCR("get jsonb array element");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_operator.h:DATA(insert OID = 3481 (  "->>"    PGNSP PGUID b f f 3802 23 25 0 0 jsonb_array_element_text - - ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_operator.h:DESCR("get jsonb array element as text");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_operator.h:DESCR("delete array element");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_opclass.h:DATA(insert (	403		array_ops			PGNSP PGUID  397 2277 t 0 ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_opclass.h:DATA(insert (	405		array_ops			PGNSP PGUID  627 2277 t 0 ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_opclass.h:DATA(insert (	2742	array_ops			PGNSP PGUID 2745  2277 t 2283 ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_opclass.h:/* no brin opclass for record, anyarray */
/srvr/z5089358/postgresql-10.4/src/include/catalog/binary_upgrade.h:extern PGDLLIMPORT Oid binary_upgrade_next_array_pg_type_oid;
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_statistic_ext.h:	int2vector	stxkeys;		/* array of column keys */
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_opfamily.h:DATA(insert OID =  397 (	403		array_ops		PGNSP PGUID ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_opfamily.h:DATA(insert OID =  627 (	405		array_ops		PGNSP PGUID ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_opfamily.h:DATA(insert OID = 2745 (	2742	array_ops		PGNSP PGUID ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_partitioned_table.h:	int2vector	partattrs;		/* each member of the array is the attribute
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc_fn.h:extern List *oid_array_to_list(Datum datum);
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_amop.h: *	btree array_ops
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_amop.h:/* array_ops */
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_amop.h: * gin array_ops
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:	Oid			provariadic;	/* element type of variadic array, or 0 */
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 382 (  btarraycmp		   PGNSP PGUID 12 1 0 0 0 f f f f t f i s 2 0 23 "2277 2277" _null_ _null_ _null_ _null_ _null_ btarraycmp _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 626 (  hash_array		   PGNSP PGUID 12 1 0 0 0 f f f f t f i s 1 0 23 "2277" _null_ _null_ _null_ _null_ _null_ hash_array _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 744 (  array_eq		   PGNSP PGUID 12 1 0 0 0 f f f f t f i s 2 0 16 "2277 2277" _null_ _null_ _null_ _null_ _null_ array_eq _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 390 (  array_ne		   PGNSP PGUID 12 1 0 0 0 f f f f t f i s 2 0 16 "2277 2277" _null_ _null_ _null_ _null_ _null_ array_ne _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 391 (  array_lt		   PGNSP PGUID 12 1 0 0 0 f f f f t f i s 2 0 16 "2277 2277" _null_ _null_ _null_ _null_ _null_ array_lt _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 392 (  array_gt		   PGNSP PGUID 12 1 0 0 0 f f f f t f i s 2 0 16 "2277 2277" _null_ _null_ _null_ _null_ _null_ array_gt _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 393 (  array_le		   PGNSP PGUID 12 1 0 0 0 f f f f t f i s 2 0 16 "2277 2277" _null_ _null_ _null_ _null_ _null_ array_le _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 396 (  array_ge		   PGNSP PGUID 12 1 0 0 0 f f f f t f i s 2 0 16 "2277 2277" _null_ _null_ _null_ _null_ _null_ array_ge _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 747 (  array_dims		   PGNSP PGUID 12 1 0 0 0 f f f f t f i s 1 0 25 "2277" _null_ _null_ _null_ _null_ _null_ array_dims _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("array dimensions");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 748 (  array_ndims	   PGNSP PGUID 12 1 0 0 0 f f f f t f i s 1 0 23 "2277" _null_ _null_ _null_ _null_ _null_ array_ndims _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("number of array dimensions");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 750 (  array_in		   PGNSP PGUID 12 1 0 0 0 f f f f t f s s 3 0 2277 "2275 26 23" _null_ _null_ _null_ _null_ _null_	array_in _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 751 (  array_out		   PGNSP PGUID 12 1 0 0 0 f f f f t f s s 1 0 2275 "2277" _null_ _null_ _null_ _null_ _null_ array_out _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 2091 (  array_lower	   PGNSP PGUID 12 1 0 0 0 f f f f t f i s 2 0 23 "2277 23" _null_ _null_ _null_ _null_ _null_ array_lower _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("array lower dimension");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 2092 (  array_upper	   PGNSP PGUID 12 1 0 0 0 f f f f t f i s 2 0 23 "2277 23" _null_ _null_ _null_ _null_ _null_ array_upper _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("array upper dimension");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 2176 (  array_length	   PGNSP PGUID 12 1 0 0 0 f f f f t f i s 2 0 23 "2277 23" _null_ _null_ _null_ _null_ _null_ array_length _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("array length");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3179 (  cardinality	   PGNSP PGUID 12 1 0 0 0 f f f f t f i s 1 0 23 "2277" _null_ _null_ _null_ _null_ _null_ array_cardinality _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("array cardinality");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 378 (  array_append	   PGNSP PGUID 12 1 0 0 0 f f f f f f i s 2 0 2277 "2277 2283" _null_ _null_ _null_ _null_ _null_ array_append _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("append element onto end of array");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 379 (  array_prepend	   PGNSP PGUID 12 1 0 0 0 f f f f f f i s 2 0 2277 "2283 2277" _null_ _null_ _null_ _null_ _null_ array_prepend _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("prepend element onto front of array");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 383 (  array_cat		   PGNSP PGUID 12 1 0 0 0 f f f f f f i s 2 0 2277 "2277 2277" _null_ _null_ _null_ _null_ _null_ array_cat _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 394 (  string_to_array   PGNSP PGUID 12 1 0 0 0 f f f f f f i s 2 0 1009 "25 25" _null_ _null_ _null_ _null_ _null_ text_to_array _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 395 (  array_to_string   PGNSP PGUID 12 1 0 0 0 f f f f t f s s 2 0 25 "2277 25" _null_ _null_ _null_ _null_ _null_ array_to_text _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("concatenate array elements, using delimiter, into text");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 376 (  string_to_array   PGNSP PGUID 12 1 0 0 0 f f f f f f i s 3 0 1009 "25 25 25" _null_ _null_ _null_ _null_ _null_ text_to_array_null _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 384 (  array_to_string   PGNSP PGUID 12 1 0 0 0 f f f f f f s s 3 0 25 "2277 25 25" _null_ _null_ _null_ _null_ _null_ array_to_text_null _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("concatenate array elements, using delimiter and null string, into text");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 515 (  array_larger	   PGNSP PGUID 12 1 0 0 0 f f f f t f i s 2 0 2277 "2277 2277" _null_ _null_ _null_ _null_ _null_ array_larger _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 516 (  array_smaller	   PGNSP PGUID 12 1 0 0 0 f f f f t f i s 2 0 2277 "2277 2277" _null_ _null_ _null_ _null_ _null_ array_smaller _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3277 (  array_position		   PGNSP PGUID 12 1 0 0 0 f f f f f f i s 2 0 23 "2277 2283" _null_ _null_ _null_ _null_ _null_ array_position _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("returns an offset of value in array");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3278 (  array_position		   PGNSP PGUID 12 1 0 0 0 f f f f f f i s 3 0 23 "2277 2283 23" _null_ _null_ _null_ _null_ _null_ array_position_start _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("returns an offset of value in array with start index");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3279 (  array_positions		   PGNSP PGUID 12 1 0 0 0 f f f f f f i s 2 0 1007 "2277 2283" _null_ _null_ _null_ _null_ _null_ array_positions _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("returns an array of offsets of some value in array");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("array subscripts generator");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("array subscripts generator");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 1193 (  array_fill PGNSP PGUID 12 1 0 0 0 f f f f f f i s 2 0 2277 "2283 1007" _null_ _null_ _null_ _null_ _null_ array_fill _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("array constructor with value");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 1286 (  array_fill PGNSP PGUID 12 1 0 0 0 f f f f f f i s 3 0 2277 "2283 1007 1007" _null_ _null_ _null_ _null_ _null_ array_fill_with_lower_bounds _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("array constructor with value");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 2331 (  unnest		   PGNSP PGUID 12 1 100 0 0 f f f f t t i s 1 0 2283 "2277" _null_ _null_ _null_ _null_ _null_ array_unnest _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("expand array to set of rows");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3167 (  array_remove	   PGNSP PGUID 12 1 0 0 0 f f f f f f i s 2 0 2277 "2277 2283" _null_ _null_ _null_ _null_ _null_ array_remove _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("remove any occurrences of an element from an array");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3168 (  array_replace    PGNSP PGUID 12 1 0 0 0 f f f f f f i s 3 0 2277 "2277 2283 2283" _null_ _null_ _null_ _null_ _null_ array_replace _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("replace any occurrences of an element in an array");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 2333 (  array_agg_transfn   PGNSP PGUID 12 1 0 0 0 f f f f f f i s 2 0 2281 "2281 2776" _null_ _null_ _null_ _null_ _null_ array_agg_transfn _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 2334 (  array_agg_finalfn   PGNSP PGUID 12 1 0 0 0 f f f f f f i s 2 0 2277 "2281 2776" _null_ _null_ _null_ _null_ _null_ array_agg_finalfn _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 2335 (  array_agg		   PGNSP PGUID 12 1 0 0 0 t f f f f f i s 1 0 2277 "2776" _null_ _null_ _null_ _null_ _null_ aggregate_dummy _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("concatenate aggregate input into an array");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 4051 (  array_agg_array_transfn	PGNSP PGUID 12 1 0 0 0 f f f f f f i s 2 0 2281 "2281 2277" _null_ _null_ _null_ _null_ _null_ array_agg_array_transfn _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 4052 (  array_agg_array_finalfn	PGNSP PGUID 12 1 0 0 0 f f f f f f i s 2 0 2277 "2281 2277" _null_ _null_ _null_ _null_ _null_ array_agg_array_finalfn _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 4053 (  array_agg		   PGNSP PGUID 12 1 0 0 0 t f f f f f i s 1 0 2277 "2277" _null_ _null_ _null_ _null_ _null_ aggregate_dummy _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("concatenate aggregate input into an array");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3218 ( width_bucket	   PGNSP PGUID 12 1 0 0 0 f f f f t f i s 2 0 23 "2283 2277" _null_ _null_ _null_ _null_ _null_ width_bucket_array _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("bucket number of operand given a sorted array of bucket lower bounds");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3816 (  array_typanalyze PGNSP PGUID 12 1 0 0 0 f f f f t f s s 1 0 16 "2281" _null_ _null_ _null_ _null_ _null_ array_typanalyze _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("array typanalyze");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3817 (  arraycontsel	   PGNSP PGUID 12 1 0 0 0 f f f f t f s s 4 0 701 "2281 26 2281 23" _null_ _null_ _null_ _null_ _null_ arraycontsel _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("restriction selectivity for array-containment operators");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3818 (  arraycontjoinsel PGNSP PGUID 12 1 0 0 0 f f f f t f s s 5 0 701 "2281 26 2281 21 2281" _null_ _null_ _null_ _null_ _null_ arraycontjoinsel _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("join selectivity for array-containment operators");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("convert ACL item array to table, for use by information schema");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID =  2767 ( regexp_split_to_array PGNSP PGUID 12 1 0 0 0 f f f f t f i s 2 0 1009 "25 25" _null_ _null_ _null_ _null_ _null_	regexp_split_to_array_no_flags _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID =  2768 ( regexp_split_to_array PGNSP PGUID 12 1 0 0 0 f f f f t f i s 3 0 1009 "25 25 25" _null_ _null_ _null_ _null_ _null_ regexp_split_to_array _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 2289 (  pg_options_to_table		PGNSP PGUID 12 1 3 0 0 f f f f t t s s 1 0 2249 "1009" "{1009,25,25}" "{i,o,o}" "{options_array,option_name,option_value}" _null_ _null_ pg_options_to_table _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("convert generic options array to name/value table");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("get array of PIDs of sessions blocking specified backend PID from acquiring a heavyweight lock");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("get array of PIDs of sessions blocking specified backend PID from acquiring a safe snapshot");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("get OID-based object address from name/args arrays");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("maximum value of all anyarray input values");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("minimum value of all anyarray input values");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("parse qualified identifier to array of identifiers");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 2296 (  anyarray_in		PGNSP PGUID 12 1 0 0 0 f f f f t f i s 1 0 2277 "2275" _null_ _null_ _null_ _null_ _null_ anyarray_in _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 2297 (  anyarray_out		PGNSP PGUID 12 1 0 0 0 f f f f t f s s 1 0 2275 "2277" _null_ _null_ _null_ _null_ _null_ anyarray_out _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 2777 (  anynonarray_in	PGNSP PGUID 12 1 0 0 0 f f f f t f i s 1 0 2776 "2275" _null_ _null_ _null_ _null_ _null_ anynonarray_in _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 2778 (  anynonarray_out	PGNSP PGUID 12 1 0 0 0 f f f f t f i s 1 0 2275 "2776" _null_ _null_ _null_ _null_ _null_ anynonarray_out _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 2400 (  array_recv		   PGNSP PGUID 12 1 0 0 0 f f f f t f s s 3 0 2277 "2281 26 23" _null_ _null_ _null_ _null_  _null_ array_recv _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 2401 (  array_send		   PGNSP PGUID 12 1 0 0 0 f f f f t f s s 1 0 17 "2277" _null_ _null_ _null_ _null_ _null_	array_send _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 2502 (  anyarray_recv		   PGNSP PGUID 12 1 0 0 0 f f f f t f s s 1 0 2277 "2281" _null_ _null_ _null_ _null_ _null_ anyarray_recv _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 2503 (  anyarray_send		   PGNSP PGUID 12 1 0 0 0 f f f f t f s s 1 0 17 "2277" _null_ _null_ _null_ _null_ _null_	anyarray_send _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:/* GIN array support */
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 2743 (  ginarrayextract	 PGNSP PGUID 12 1 0 0 0 f f f f t f i s 3 0 2281 "2277 2281 2281" _null_ _null_ _null_ _null_ _null_ ginarrayextract _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("GIN array support");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 2774 (  ginqueryarrayextract	PGNSP PGUID 12 1 0 0 0 f f f f t f i s 7 0 2281 "2277 2281 21 2281 2281 2281 2281" _null_ _null_ _null_ _null_ _null_ ginqueryarrayextract _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("GIN array support");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 2744 (  ginarrayconsistent	PGNSP PGUID 12 1 0 0 0 f f f f t f i s 8 0 16 "2281 21 2277 23 2281 2281 2281 2281" _null_ _null_ _null_ _null_ _null_ ginarrayconsistent _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("GIN array support");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3920 (  ginarraytriconsistent PGNSP PGUID 12 1 0 0 0 f f f f t f i s 7 0 18 "2281 21 2277 23 2281 2281 2281" _null_ _null_ _null_ _null_ _null_ ginarraytriconsistent _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("GIN array support");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3076 (  ginarrayextract	 PGNSP PGUID 12 1 0 0 0 f f f f t f i s 2 0 2281 "2277 2281" _null_ _null_ _null_ _null_ _null_ ginarrayextract_2args _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("GIN array support (obsolete)");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 2747 (  arrayoverlap		   PGNSP PGUID 12 1 0 0 0 f f f f t f i s 2 0 16 "2277 2277" _null_ _null_ _null_ _null_ _null_ arrayoverlap _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 2748 (  arraycontains		   PGNSP PGUID 12 1 0 0 0 f f f f t f i s 2 0 16 "2277 2277" _null_ _null_ _null_ _null_ _null_ arraycontains _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 2749 (  arraycontained	   PGNSP PGUID 12 1 0 0 0 f f f f t f i s 2 0 16 "2277 2277" _null_ _null_ _null_ _null_ _null_ arraycontained _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3153 (  array_to_json    PGNSP PGUID 12 1 0 0 0 f f f f t f s s 1 0 114 "2277" _null_ _null_ _null_ _null_ _null_ array_to_json _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("map array to json");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3154 (  array_to_json    PGNSP PGUID 12 1 0 0 0 f f f f t f s s 2 0 114 "2277 16" _null_ _null_ _null_ _null_ _null_ array_to_json_pretty _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("map array to json with optional pretty printing");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3198 (  json_build_array	   PGNSP PGUID 12 1 0 2276 0 f f f f f f s s 1 0 114 "2276" "{2276}" "{v}" _null_ _null_ _null_ json_build_array _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("build a json array from any inputs");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3199 (  json_build_array	   PGNSP PGUID 12 1 0 0 0 f f f f f f s s 0 0 114  "" _null_ _null_ _null_ _null_ _null_ json_build_array_noargs _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("build an empty json array");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("map text array of key value pairs to json object");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("map text arrays of keys and values to json object");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3949 (  json_array_element		PGNSP PGUID 12 1 0 0 0 f f f f t f i s 2 0 114 "114 23" _null_ _null_ "{from_json, element_index}" _null_ _null_ json_array_element _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3950 (  json_array_element_text	PGNSP PGUID 12 1 0 0 0 f f f f t f i s 2 0 25  "114 23" _null_ _null_ "{from_json, element_index}" _null_ _null_ json_array_element_text _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3955 (  json_array_elements		PGNSP PGUID 12 1 100 0 0 f f f f t t i s 1 0 114 "114" "{114,114}" "{i,o}" "{from_json,value}" _null_ _null_ json_array_elements _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3969 (  json_array_elements_text	PGNSP PGUID 12 1 100 0 0 f f f f t t i s 1 0 25 "114" "{114,25}" "{i,o}" "{from_json,value}" _null_ _null_ json_array_elements_text _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("elements of json array");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3956 (  json_array_length			PGNSP PGUID 12 1 0 0 0 f f f f t f i s 1 0 23 "114" _null_ _null_ _null_ _null_ _null_ json_array_length _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("length of json array");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("get set of records with fields from a json array of objects");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("get set of records with fields from a json array of objects");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("range between the two given enum values, as an ordered array");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("range of the given enum type, as an ordered array");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3326 (  tsvector_to_array		PGNSP PGUID 12 1 0	0 0 f f f f t f i s 1 0 1009 "3614" _null_ _null_ _null_ _null_ _null_ tsvector_to_array _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("convert tsvector to array of lexemes");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3327 (  array_to_tsvector		PGNSP PGUID 12 1 0	0 0 f f f f t f i s 1 0 3614 "1009" _null_ _null_ _null_ _null_ _null_ array_to_tsvector _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("build tsvector from array of lexemes");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("map text array of key value pairs to jsonb object");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("map text array of key value pairs to jsonb object");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3271 (  jsonb_build_array    PGNSP PGUID 12 1 0 2276 0 f f f f f f s s 1 0 3802 "2276" "{2276}" "{v}" _null_ _null_ _null_ jsonb_build_array _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("build a jsonb array from any inputs");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3272 (  jsonb_build_array    PGNSP PGUID 12 1 0 0 0 f f f f f f s s 0 0 3802	"" _null_ _null_ _null_ _null_ _null_ jsonb_build_array_noargs _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("build an empty jsonb array");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3215 (  jsonb_array_element		PGNSP PGUID 12 1 0 0 0 f f f f t f i s 2 0 3802 "3802 23" _null_ _null_ "{from_json, element_index}" _null_ _null_ jsonb_array_element _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3216 (  jsonb_array_element_text	PGNSP PGUID 12 1 0 0 0 f f f f t f i s 2 0 25  "3802 23" _null_ _null_ "{from_json, element_index}" _null_ _null_ jsonb_array_element_text _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3219 (  jsonb_array_elements		PGNSP PGUID 12 1 100 0 0 f f f f t t i s 1 0 3802 "3802" "{3802,3802}" "{i,o}" "{from_json,value}" _null_ _null_ jsonb_array_elements _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("elements of a jsonb array");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3465 (  jsonb_array_elements_text PGNSP PGUID 12 1 100 0 0 f f f f t t i s 1 0 25 "3802" "{3802,25}" "{i,o}" "{from_json,value}" _null_ _null_ jsonb_array_elements_text _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("elements of jsonb array");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3207 (  jsonb_array_length			PGNSP PGUID 12 1 0 0 0 f f f f t f i s 1 0 23 "3802" _null_ _null_ _null_ _null_ _null_ jsonb_array_length _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("length of jsonb array");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("get set of records with fields from a jsonb array of objects");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DESCR("get set of records with fields from a jsonb array of objects");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3343 ( jsonb_delete	   PGNSP PGUID 12 1 0 25 0 f f f f t f i s 2 0 3802 "3802 1009" "{3802,1009}" "{i,v}" "{from_json,path_elems}" _null_ _null_ jsonb_delete_array _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_proc.h:DATA(insert OID = 3584 ( binary_upgrade_set_next_array_pg_type_oid PGNSP PGUID	12 1 0 0 0 f f f f t f v r 1 0 2278 "26" _null_ _null_ _null_ _null_ _null_ binary_upgrade_set_next_array_pg_type_oid _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_statistic.h:	 *		numbers			float4 array (for statistical values)
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_statistic.h:	 *		values			anyarray (for representations of data values)
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_statistic.h:	 * Values in these arrays are values of the column's data type, or of some
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_statistic.h:	 * related type such as an array element type.  We presently have to cheat
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_statistic.h:	 * quite a bit to allow polymorphic arrays of this kind, but perhaps
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_statistic.h:	anyarray	stavalues1;
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_statistic.h:	anyarray	stavalues2;
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_statistic.h:	anyarray	stavalues3;
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_statistic.h:	anyarray	stavalues4;
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_statistic.h:	anyarray	stavalues5;
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_statistic.h: * shall be ordered in decreasing frequency.  Note that since the arrays are
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_statistic.h: * values.  This is useful when the column datatype is an array or some other
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_statistic.h: * the number of distinct element values present in each row of an array-type
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_statistic.h: * into a single array, with the lower bounds of each value forming a
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:	char		typdelim;		/* delimiter for arrays of this type */
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:	 * current type can then be subscripted like an array yielding values of
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:	 * "real" array type; some ordinary fixed-length types can also be
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:	 * turned into pseudo-arrays like that. Hence, the way to determine
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:	 * whether a type is a "true" array type is if:
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:	 * If there is a "true" array type having this type as element type,
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:	 * typarray links to it.  Zero if no associated "true" array type.
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:	Oid			typarray;
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:	 * typndims is the declared number of dimensions for an array domain type
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:	 * (i.e., typbasetype is an array type).  Otherwise zero.
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:#define Anum_pg_type_typarray			13
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DESCR("array of int2, used in system tables");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DESCR("array of oids, used in system tables");
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 143 ( _xml	   PGNSP PGUID -1 f b A f t \054 0 142 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 199 ( _json	   PGNSP PGUID -1 f b A f t \054 0 114 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 629 (  _line	   PGNSP PGUID	-1 f b A f t \054 0 628 0 array_in array_out array_recv array_send - - array_typanalyze d x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 719 (  _circle   PGNSP PGUID	-1 f b A f t \054 0  718 0 array_in array_out array_recv array_send - - array_typanalyze d x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 791 (  _money    PGNSP PGUID	-1 f b A f t \054 0  790 0 array_in array_out array_recv array_send - - array_typanalyze d x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1000 (  _bool		 PGNSP PGUID -1 f b A f t \054 0	16 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1001 (  _bytea	 PGNSP PGUID -1 f b A f t \054 0	17 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1002 (  _char		 PGNSP PGUID -1 f b A f t \054 0	18 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1003 (  _name		 PGNSP PGUID -1 f b A f t \054 0	19 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1005 (  _int2		 PGNSP PGUID -1 f b A f t \054 0	21 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1006 (  _int2vector PGNSP PGUID -1 f b A f t \054 0	22 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1007 (  _int4		 PGNSP PGUID -1 f b A f t \054 0	23 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1008 (  _regproc	 PGNSP PGUID -1 f b A f t \054 0	24 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1009 (  _text		 PGNSP PGUID -1 f b A f t \054 0	25 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 100 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1028 (  _oid		 PGNSP PGUID -1 f b A f t \054 0	26 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1010 (  _tid		 PGNSP PGUID -1 f b A f t \054 0	27 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1011 (  _xid		 PGNSP PGUID -1 f b A f t \054 0	28 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1012 (  _cid		 PGNSP PGUID -1 f b A f t \054 0	29 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1013 (  _oidvector PGNSP PGUID -1 f b A f t \054 0	30 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1014 (  _bpchar	 PGNSP PGUID -1 f b A f t \054 0 1042 0 array_in array_out array_recv array_send bpchartypmodin bpchartypmodout array_typanalyze i x f 0 -1 0 100 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1015 (  _varchar	 PGNSP PGUID -1 f b A f t \054 0 1043 0 array_in array_out array_recv array_send varchartypmodin varchartypmodout array_typanalyze i x f 0 -1 0 100 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1016 (  _int8		 PGNSP PGUID -1 f b A f t \054 0	20 0 array_in array_out array_recv array_send - - array_typanalyze d x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1017 (  _point	 PGNSP PGUID -1 f b A f t \054 0 600 0 array_in array_out array_recv array_send - - array_typanalyze d x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1018 (  _lseg		 PGNSP PGUID -1 f b A f t \054 0 601 0 array_in array_out array_recv array_send - - array_typanalyze d x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1019 (  _path		 PGNSP PGUID -1 f b A f t \054 0 602 0 array_in array_out array_recv array_send - - array_typanalyze d x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1020 (  _box		 PGNSP PGUID -1 f b A f t \073 0 603 0 array_in array_out array_recv array_send - - array_typanalyze d x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1021 (  _float4	 PGNSP PGUID -1 f b A f t \054 0 700 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1022 (  _float8	 PGNSP PGUID -1 f b A f t \054 0 701 0 array_in array_out array_recv array_send - - array_typanalyze d x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1023 (  _abstime	 PGNSP PGUID -1 f b A f t \054 0 702 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1024 (  _reltime	 PGNSP PGUID -1 f b A f t \054 0 703 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1025 (  _tinterval PGNSP PGUID -1 f b A f t \054 0 704 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1027 (  _polygon	 PGNSP PGUID -1 f b A f t \054 0 604 0 array_in array_out array_recv array_send - - array_typanalyze d x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1034 (  _aclitem	 PGNSP PGUID -1 f b A f t \054 0 1033 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1040 (  _macaddr	 PGNSP PGUID -1 f b A f t \054 0  829 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 775  (  _macaddr8  PGNSP PGUID -1 f b A f t \054 0  774 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1041 (  _inet		 PGNSP PGUID -1 f b A f t \054 0  869 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 651  (  _cidr		 PGNSP PGUID -1 f b A f t \054 0  650 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1263 (  _cstring	 PGNSP PGUID -1 f b A f t \054 0 2275 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1115 ( _timestamp  PGNSP PGUID	-1 f b A f t \054 0 1114 0 array_in array_out array_recv array_send timestamptypmodin timestamptypmodout array_typanalyze d x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1182 ( _date		 PGNSP PGUID	-1 f b A f t \054 0 1082 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1183 ( _time		 PGNSP PGUID	-1 f b A f t \054 0 1083 0 array_in array_out array_recv array_send timetypmodin timetypmodout array_typanalyze d x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1185 ( _timestamptz PGNSP PGUID -1 f b A f t \054 0	1184 0 array_in array_out array_recv array_send timestamptztypmodin timestamptztypmodout array_typanalyze d x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1187 ( _interval	 PGNSP PGUID	-1 f b A f t \054 0 1186 0 array_in array_out array_recv array_send intervaltypmodin intervaltypmodout array_typanalyze d x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1231 (  _numeric	 PGNSP PGUID -1 f b A f t \054 0	1700 0 array_in array_out array_recv array_send numerictypmodin numerictypmodout array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1270 ( _timetz	 PGNSP PGUID -1 f b A f t \054 0	1266 0 array_in array_out array_recv array_send timetztypmodin timetztypmodout array_typanalyze d x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1561 ( _bit		 PGNSP PGUID -1 f b A f t \054 0	1560 0 array_in array_out array_recv array_send bittypmodin bittypmodout array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 1563 ( _varbit	 PGNSP PGUID -1 f b A f t \054 0	1562 0 array_in array_out array_recv array_send varbittypmodin varbittypmodout array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 2201 ( _refcursor    PGNSP PGUID -1 f b A f t \054 0 1790 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 2207 ( _regprocedure PGNSP PGUID -1 f b A f t \054 0 2202 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 2208 ( _regoper	   PGNSP PGUID -1 f b A f t \054 0 2203 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 2209 ( _regoperator  PGNSP PGUID -1 f b A f t \054 0 2204 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 2210 ( _regclass	   PGNSP PGUID -1 f b A f t \054 0 2205 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 2211 ( _regtype	   PGNSP PGUID -1 f b A f t \054 0 2206 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 4097 ( _regrole	   PGNSP PGUID -1 f b A f t \054 0 4096 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 4090 ( _regnamespace PGNSP PGUID -1 f b A f t \054 0 4089 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 2951 ( _uuid			PGNSP PGUID -1 f b A f t \054 0 2950 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 3221 ( _pg_lsn			PGNSP PGUID -1 f b A f t \054 0 3220 0 array_in array_out array_recv array_send - - array_typanalyze d x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 3643 ( _tsvector		PGNSP PGUID -1 f b A f t \054 0 3614 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 3644 ( _gtsvector		PGNSP PGUID -1 f b A f t \054 0 3642 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 3645 ( _tsquery		PGNSP PGUID -1 f b A f t \054 0 3615 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 3735 ( _regconfig		PGNSP PGUID -1 f b A f t \054 0 3734 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 3770 ( _regdictionary PGNSP PGUID -1 f b A f t \054 0 3769 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 3807 ( _jsonb			PGNSP PGUID -1 f b A f t \054 0 3802 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 2949 ( _txid_snapshot PGNSP PGUID -1 f b A f t \054 0 2970 0 array_in array_out array_recv array_send - - array_typanalyze d x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 3905 ( _int4range		PGNSP PGUID  -1 f b A f t \054 0 3904 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 3907 ( _numrange		PGNSP PGUID  -1 f b A f t \054 0 3906 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 3909 ( _tsrange		PGNSP PGUID  -1 f b A f t \054 0 3908 0 array_in array_out array_recv array_send - - array_typanalyze d x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 3911 ( _tstzrange		PGNSP PGUID  -1 f b A f t \054 0 3910 0 array_in array_out array_recv array_send - - array_typanalyze d x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 3913 ( _daterange		PGNSP PGUID  -1 f b A f t \054 0 3912 0 array_in array_out array_recv array_send - - array_typanalyze i x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 3927 ( _int8range		PGNSP PGUID  -1 f b A f t \054 0 3926 0 array_in array_out array_recv array_send - - array_typanalyze d x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h: * but there is now support for it in records and arrays.  Perhaps we should
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 2287 ( _record		PGNSP PGUID -1 f p P f t \054 0 2249 0 array_in array_out array_recv array_send - - array_typanalyze d x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 2277 ( anyarray		PGNSP PGUID -1 f p P f t \054 0 0 0 anyarray_in anyarray_out anyarray_recv anyarray_send - - - d x f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type.h:DATA(insert OID = 2776 ( anynonarray	PGNSP PGUID  4 t p P f t \054 0 0 0 anynonarray_in anynonarray_out - - - - - i p f 0 -1 0 0 _null_ _null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_aggregate.h:DATA(insert ( 2050	n 0 array_larger	-				array_larger		-	-	-				-				-				f f 1073	2277	0	0		0	_null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_aggregate.h:DATA(insert ( 2051	n 0 array_smaller	-				array_smaller		-	-	-				-				-				f f 1072	2277	0	0		0	_null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_aggregate.h:/* array */
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_aggregate.h:DATA(insert ( 2335	n 0 array_agg_transfn		array_agg_finalfn		-	-	-	-		-				-				t f 0	2281	0	0		0	_null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_aggregate.h:DATA(insert ( 4053	n 0 array_agg_array_transfn array_agg_array_finalfn -	-	-	-		-				-				t f 0	2281	0	0		0	_null_ _null_ ));
/srvr/z5089358/postgresql-10.4/src/include/catalog/namespace.h:	int			nvargs;			/* number of args to become variadic array */
/srvr/z5089358/postgresql-10.4/src/include/catalog/namespace.h:extern int	fetch_search_path_array(Oid *sarray, int sarray_len);
/srvr/z5089358/postgresql-10.4/src/include/catalog/objectaddress.h:extern ArrayType *strlist_to_textarray(List *list);
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_type_fn.h:		   Oid arrayType,
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_attribute.h:	 * Note that (attnum - 1) is often used as the index to an array.
/srvr/z5089358/postgresql-10.4/src/include/catalog/pg_attribute.h:	 * attndims is the declared number of dimensions, if an array type,
/srvr/z5089358/postgresql-10.4/src/include/mb/pg_wchar.h: *			in the pg_enc2name_tbl[] array (in mb/encnames.c), and
/srvr/z5089358/postgresql-10.4/src/include/mb/pg_wchar.h: *			in the pg_wchar_table[] array (in mb/wchar.c)!
/srvr/z5089358/postgresql-10.4/src/include/mb/pg_wchar.h: * 2. Using a sorted array of source -> destination code pairs. This
/srvr/z5089358/postgresql-10.4/src/include/mb/pg_wchar.h: * Physically, all the trees are stored in one big array, in 'chars16' or
/srvr/z5089358/postgresql-10.4/src/include/mb/pg_wchar.h: * into the chars[16|32] array.
/srvr/z5089358/postgresql-10.4/src/include/mb/pg_wchar.h: * In the beginning of the chars[16|32] array, there is always a number of
/srvr/z5089358/postgresql-10.4/src/include/mb/pg_wchar.h:	uint32		b1root;			/* offset of table in the chars[16|32] array */
/srvr/z5089358/postgresql-10.4/src/include/replication/worker_internal.h:	/* Pointer to proc array. NULL if not running. */
/srvr/z5089358/postgresql-10.4/src/include/replication/slot.h:	 * This array should be declared [FLEXIBLE_ARRAY_MEMBER], but for some
/srvr/z5089358/postgresql-10.4/src/include/funcapi.h: * This struct holds arrays of individual attribute information
/srvr/z5089358/postgresql-10.4/src/include/funcapi.h:	/* array of attribute type input function finfo */
/srvr/z5089358/postgresql-10.4/src/include/funcapi.h:	/* array of attribute type i/o parameter OIDs */
/srvr/z5089358/postgresql-10.4/src/include/funcapi.h:	/* array of attribute typmod */
/srvr/z5089358/postgresql-10.4/src/include/funcapi.h: *		build a HeapTuple given user data in C string form. values is an array
/srvr/z5089358/postgresql-10.4/src/include/fmgr.h: * fields.  (In particular, scribbling on the argument arrays is a bad idea,
/srvr/z5089358/postgresql-10.4/src/include/fmgr.h: * for the arg[] and argnull[] arrays.  Performance testing has shown that
/srvr/z5089358/postgresql-10.4/src/include/fmgr.h: * out the argnull[] array in the macro.
/srvr/z5089358/postgresql-10.4/src/include/common/unicode_norm_table.h:/* codepoints array  */
/srvr/z5089358/postgresql-10.4/src/include/common/relpath.h:	 * FORKNAMECHARS below, and update the forkNames array in
/srvr/z5089358/postgresql-10.4/src/include/storage/block.h: * space requirements of the line pointer (ItemIdData) array on each
/srvr/z5089358/postgresql-10.4/src/include/storage/lwlock.h: * on a cache line boundary and make the array stride a power of 2.  This saves
/srvr/z5089358/postgresql-10.4/src/include/storage/lwlock.h: * useful, for example, in the main LWLock array, where the overall number of
/srvr/z5089358/postgresql-10.4/src/include/storage/lwlock.h: * as necessary for performance.  For an array that contains only LWLocks,
/srvr/z5089358/postgresql-10.4/src/include/storage/lwlock.h: * call GetNamedLWLockTranche() to obtain a pointer to an array containing
/srvr/z5089358/postgresql-10.4/src/include/storage/proc.h: * listed anywhere in the PGPROC array is not a running transaction.  Else we
/srvr/z5089358/postgresql-10.4/src/include/storage/proc.h: * in src/include/storage/procarray.h.
/srvr/z5089358/postgresql-10.4/src/include/storage/proc.h: * used for PROCARRAY_SLOTS_XMIN in procarray.h, so GetOldestXmin won't be able
/srvr/z5089358/postgresql-10.4/src/include/storage/proc.h:#define		PROC_RESERVED				0x20	/* reserved for procarray */
/srvr/z5089358/postgresql-10.4/src/include/storage/proc.h: * members into a separate array as tightly as possible sped up GetSnapshotData
/srvr/z5089358/postgresql-10.4/src/include/storage/proc.h:	/* Length of allProcs array */
/srvr/z5089358/postgresql-10.4/src/include/storage/fsm_internals.h:	 * fp_nodes contains the binary tree, stored in array. The first
/srvr/z5089358/postgresql-10.4/src/include/storage/standby.h:	TransactionId *xids;		/* array of (sub)xids still running */
/srvr/z5089358/postgresql-10.4/src/include/storage/procarray.h: * procarray.h
/srvr/z5089358/postgresql-10.4/src/include/storage/procarray.h: *	  POSTGRES process array definitions.
/srvr/z5089358/postgresql-10.4/src/include/storage/procarray.h: * src/include/storage/procarray.h
/srvr/z5089358/postgresql-10.4/src/include/storage/procarray.h: * to avoid forcing to include proc.h when including procarray.h. So if you modify
/srvr/z5089358/postgresql-10.4/src/include/storage/standbydefs.h:	int			nlocks;			/* number of entries in locks array */
/srvr/z5089358/postgresql-10.4/src/include/storage/off.h: * this is a 1-based index into the linp (ItemIdData) array in the
/srvr/z5089358/postgresql-10.4/src/include/storage/off.h: *		real C array index).
/srvr/z5089358/postgresql-10.4/src/include/storage/buf_internals.h: * array to be on a cache line boundary and force the elements to be cache
/srvr/z5089358/postgresql-10.4/src/include/storage/lock.h: * conflictTab -- this is an array of bitmasks showing lock
/srvr/z5089358/postgresql-10.4/src/include/storage/lock.h:	int			nRequested;		/* total of requested[] array */
/srvr/z5089358/postgresql-10.4/src/include/storage/lock.h:	int			nGranted;		/* total of granted[] array */
/srvr/z5089358/postgresql-10.4/src/include/storage/lock.h:	int			maxLockOwners;	/* allocated size of array */
/srvr/z5089358/postgresql-10.4/src/include/storage/lock.h:	LOCALLOCKOWNER *lockOwners; /* dynamically resizable array */
/srvr/z5089358/postgresql-10.4/src/include/storage/lock.h:	int			nelements;		/* The length of the array */
/srvr/z5089358/postgresql-10.4/src/include/storage/lock.h:	int			nprocs;			/* # of valid entries in procs[] array */
/srvr/z5089358/postgresql-10.4/src/include/storage/lock.h:	int			maxprocs;		/* Allocated length of procs[] array */
/srvr/z5089358/postgresql-10.4/src/include/storage/lock.h:	int			nlocks;			/* # of valid entries in locks[] array */
/srvr/z5089358/postgresql-10.4/src/include/storage/lock.h:	int			maxlocks;		/* Allocated length of locks[] array */
/srvr/z5089358/postgresql-10.4/src/include/storage/lock.h:	int			npids;			/* # of valid entries in waiter_pids[] array */
/srvr/z5089358/postgresql-10.4/src/include/storage/lock.h:	int			maxpids;		/* Allocated length of waiter_pids[] array */
/srvr/z5089358/postgresql-10.4/src/include/storage/bufpage.h: * linp1..N form an ItemId array.  ItemPointers point into this array
/srvr/z5089358/postgresql-10.4/src/include/storage/bufpage.h:	ItemIdData	pd_linp[FLEXIBLE_ARRAY_MEMBER]; /* line pointer array */
/srvr/z5089358/postgresql-10.4/src/include/storage/itemptr.h: * (ItemIdData) array we want.
/srvr/z5089358/postgresql-10.4/src/include/storage/checksum_impl.h: * dimensional array of 32 bit values. Each column is aggregated separately
/srvr/z5089358/postgresql-10.4/src/include/storage/smgr.h:	 * for md.c; per-fork arrays of the number of open segments
/srvr/z5089358/postgresql-10.4/src/include/pg_config.h:/* Define to nothing if C supports flexible array members, and to 1 if it does
/srvr/z5089358/postgresql-10.4/src/include/pg_config.h:/* Define to 1 if you have the external array `tzname'. */
/srvr/z5089358/postgresql-10.4/src/include/pg_config.h.in:/* Define to nothing if C supports flexible array members, and to 1 if it does
/srvr/z5089358/postgresql-10.4/src/include/pg_config.h.in:/* Define to 1 if you have the external array `tzname'. */
/srvr/z5089358/postgresql-10.4/src/include/commands/defrem.h:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/include/commands/vacuum.h:	 * want to store an array of something other than the analyzed column's
/srvr/z5089358/postgresql-10.4/src/include/regex/regguts.h: * less than colormap.max.  Any array entries beyond "max" are just garbage.
/srvr/z5089358/postgresql-10.4/src/include/regex/regguts.h: * Ideally, the mapping data would just be an array of colors indexed by
/srvr/z5089358/postgresql-10.4/src/include/regex/regguts.h: * common characters have smaller codes, so we can use a simple array for chr
/srvr/z5089358/postgresql-10.4/src/include/regex/regguts.h: * 2-D array of color entries, where row indexes correspond to individual chrs
/srvr/z5089358/postgresql-10.4/src/include/regex/regguts.h: * into the 2-D hicolormap array.
/srvr/z5089358/postgresql-10.4/src/include/regex/regguts.h:	int			rownum;			/* row index in hicolormap array (>= 1) */
/srvr/z5089358/postgresql-10.4/src/include/regex/regguts.h:	size_t		ncds;			/* allocated length of colordescs array */
/srvr/z5089358/postgresql-10.4/src/include/regex/regguts.h:	struct colordesc *cd;		/* pointer to array of colordescs */
/srvr/z5089358/postgresql-10.4/src/include/regex/regguts.h:	color	   *locolormap;		/* simple array indexed by chr code */
/srvr/z5089358/postgresql-10.4/src/include/regex/regguts.h:	color	   *hicolormap;		/* 2-D array of color entries */
/srvr/z5089358/postgresql-10.4/src/include/regex/regguts.h:	int			maxarrayrows;	/* number of array rows allocated */
/srvr/z5089358/postgresql-10.4/src/include/regex/regguts.h:	int			hiarrayrows;	/* number of array rows in use */
/srvr/z5089358/postgresql-10.4/src/include/regex/regguts.h:	int			hiarraycols;	/* number of array columns (2^N) */
/srvr/z5089358/postgresql-10.4/src/include/regex/regguts.h: * then the chrs[] and ranges[] arrays contain only members of that class
/srvr/z5089358/postgresql-10.4/src/include/regex/regguts.h: * freecvec(), both arrays of chrs are after the end of the struct, not
/srvr/z5089358/postgresql-10.4/src/include/regex/regguts.h: * each arc.  The list of out arcs for each state is an array beginning at
/srvr/z5089358/postgresql-10.4/src/include/regex/regguts.h:	/* states[n] are pointers into a single malloc'd array of arcs */
/srvr/z5089358/postgresql-10.4/src/common/md5.c: *	The returned array is allocated using malloc.  the caller should free it
/srvr/z5089358/postgresql-10.4/src/common/md5.c: *						  characters.  you thus need to provide an array
Binary file /srvr/z5089358/postgresql-10.4/src/common/keywords.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/common/libpgcommon_srv.a matches
/srvr/z5089358/postgresql-10.4/src/common/sha2.c: * unsigned 128-bit integer (represented using a two-element array of
/srvr/z5089358/postgresql-10.4/src/common/unicode_norm.c: * Decompose the given code into the array given by caller. The
/srvr/z5089358/postgresql-10.4/src/common/unicode_norm.c: * in the array result.
/srvr/z5089358/postgresql-10.4/src/common/unicode_norm.c: * The input is a 0-terminated array of codepoints.
/srvr/z5089358/postgresql-10.4/src/common/unicode_norm.c: * In frontend, returns a 0-terminated array of codepoints, allocated with
/srvr/z5089358/postgresql-10.4/src/common/unicode/generate-unicode_norm_table.pl:# Print the array of decomposed codes.
/srvr/z5089358/postgresql-10.4/src/common/unicode/generate-unicode_norm_table.pl:/* codepoints array  */
/srvr/z5089358/postgresql-10.4/src/common/unicode/generate-norm_test_table.pl:# and generate a C array from it, for norm_test.c.
/srvr/z5089358/postgresql-10.4/src/common/unicode/generate-norm_test_table.pl:# hexadecimal list format, suitable for outputting in a C array.
/srvr/z5089358/postgresql-10.4/src/common/unicode/generate-norm_test_table.pl:	$result .= '0';    # null-terminated the array
Binary file /srvr/z5089358/postgresql-10.4/src/common/libpgcommon.a matches
/srvr/z5089358/postgresql-10.4/src/common/pg_lzcompress.c: * Statically allocated work arrays for history
/srvr/z5089358/postgresql-10.4/src/common/pg_lzcompress.c:	 * hist_entries[] array; its entries are initialized as they are used.
Binary file /srvr/z5089358/postgresql-10.4/src/common/keywords_srv.o matches
/srvr/z5089358/postgresql-10.4/src/common/saslprep.c: * as arrays of codepoint ranges.  Each range is a pair of codepoints,
/srvr/z5089358/postgresql-10.4/src/common/saslprep.c:	 * Convert the input from UTF-8 to an array of Unicode codepoints.
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeValuesscan.c:		if (node->curr_idx < node->array_len)
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeValuesscan.c:		if (node->curr_idx < node->array_len)
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeValuesscan.c:	scanstate->array_len = list_length(node->values_lists);
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeValuesscan.c:	/* convert list of sublists into array of sublists for easy addressing */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeValuesscan.c:		palloc(scanstate->array_len * sizeof(List *));
/srvr/z5089358/postgresql-10.4/src/backend/executor/execTuples.c: *	  the type information for a tuple is an array of FormData_pg_attribute.
/srvr/z5089358/postgresql-10.4/src/backend/executor/execTuples.c:	 * Release any old descriptor.  Also release old Datum/isnull arrays if
/srvr/z5089358/postgresql-10.4/src/backend/executor/execTuples.c:	 * Allocate Datum/isnull arrays of the appropriate size.  These must have
/srvr/z5089358/postgresql-10.4/src/backend/executor/execTuples.c: *		* Store data into the Datum/isnull arrays.
/srvr/z5089358/postgresql-10.4/src/backend/executor/execTuples.c:	 * Otherwise we need to build a tuple from the Datum array.
/srvr/z5089358/postgresql-10.4/src/backend/executor/execTuples.c:	 * Otherwise we need to build a tuple from the Datum array.
/srvr/z5089358/postgresql-10.4/src/backend/executor/execTuples.c: * values is an array of C strings, one for each attribute of the return tuple.
Binary file /srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.o matches
/srvr/z5089358/postgresql-10.4/src/backend/executor/tstoreReceiver.c:	Datum	   *outvalues;		/* values array for result tuple */
/srvr/z5089358/postgresql-10.4/src/backend/executor/tstoreReceiver.c:	 * Fetch back any out-of-line datums.  We build the new datums array in
/srvr/z5089358/postgresql-10.4/src/backend/executor/tstoreReceiver.c:	 * myState->outvalues[] (but we can re-use the slot's isnull array). Also,
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeSamplescan.c:		 * We use a binary search over the known-sorted array.  Note: we could
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeSubplan.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeSubplan.c:	 * and form an array of the first column's values.  Note in particular
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeSubplan.c:	 * that we produce a zero-element array if no tuples are produced (this is
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeSubplan.c:		/* Silly little array of column numbers 1..n */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeSubplan.c:		 * We build the result array in query context so it won't disappear;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeGatherMerge.c: * Pending-tuple array for each worker.  This holds additional tuples that
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeGatherMerge.c:	HeapTuple  *tuple;			/* array of length MAX_TUPLE_STORE */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeGatherMerge.c:static void load_tuple_array(GatherMergeState *gm_state, int reader);
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeGatherMerge.c:				/* Make a working array showing the active readers */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeGatherMerge.c:	/* Flush local copy of reader array */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeGatherMerge.c: * In the gm_slots[] array, index 0 is for the leader, and indexes 1 to n
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeGatherMerge.c: * in gm_slots[].  The gm_tuple_buffers[] array, however, is indexed from
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeGatherMerge.c:	 * case the extra array entries go unused.
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeGatherMerge.c:	/* Allocate the tuple slot and tuple array for each worker */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeGatherMerge.c:		/* Allocate the tuple array with length MAX_TUPLE_STORE */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeGatherMerge.c:	/* Reset the tuple slot and tuple array for each worker */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeGatherMerge.c:		/* Reset tuple array to empty */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeGatherMerge.c:				load_tuple_array(gm_state, i);
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeGatherMerge.c: * array, until we have MAX_TUPLE_STORE of them or would have to block.
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeGatherMerge.c:load_tuple_array(GatherMergeState *gm_state, int reader)
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeGatherMerge.c:	/* If there's nothing in the array, reset the counters to zero. */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeGatherMerge.c:	/* Try to fill additional slots in the array. */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeGatherMerge.c:		 * pending-tuple array for the reader.
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeGatherMerge.c:		load_tuple_array(gm_state, reader);
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeGatherMerge.c: * We have one slot for each item in the heap array.  We use SlotNumber
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeHash.c:		 * allocate and initialize the file arrays in hashCxt
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeHash.c:	 * hashbucket array therein, and set each bucket "empty".
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeHash.c:	 * the pointer arrays we'll try to allocate do not exceed work_mem nor
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeHash.c:	 * can't have any temp files (and the arrays might not even exist if
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeHash.c:		/* we had no file arrays before */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeHash.c:		/* enlarge arrays and zero out added entries */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeHash.c:	 * Release the arrays since they aren't useful any more.
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeMergeAppend.c: * We have one slot for each item in the heap array.  We use SlotNumber
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeMergeAppend.c:	 * results into the array "mergeplans".
Binary file /srvr/z5089358/postgresql-10.4/src/backend/executor/tqueue.o matches
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeBitmapOr.c:	 * results into the array "bitmapplanstates".
/srvr/z5089358/postgresql-10.4/src/backend/executor/spi.c:		/* Double the size of the pointer array */
/srvr/z5089358/postgresql-10.4/src/backend/executor/spi.c: * Convert arrays of query parameters to form wanted by planner and executor
/srvr/z5089358/postgresql-10.4/src/backend/executor/execJunk.c:	 * The "map" is an array of "cleanLength" attribute numbers, i.e. one
/srvr/z5089358/postgresql-10.4/src/backend/executor/execJunk.c:	 * The "map" is an array of "cleanLength" attribute numbers, i.e. one
/srvr/z5089358/postgresql-10.4/src/backend/executor/execGrouping.c: * matchColIdx: array of attribute column numbers
/srvr/z5089358/postgresql-10.4/src/backend/executor/execGrouping.c: * eqFunctions: array of fmgr lookup info for the equality functions to use
/srvr/z5089358/postgresql-10.4/src/backend/executor/execGrouping.c: *		execTuplesUnequal, given an array of equality operator OIDs.
/srvr/z5089358/postgresql-10.4/src/backend/executor/execGrouping.c: * The result is a palloc'd array.
/srvr/z5089358/postgresql-10.4/src/backend/executor/execGrouping.c: * *hashFunctions receive the palloc'd result arrays.
/srvr/z5089358/postgresql-10.4/src/backend/executor/execGrouping.c: * The function arrays may be made with execTuplesHashPrepare().  Note they
/srvr/z5089358/postgresql-10.4/src/backend/executor/execIndexing.c:	 * allocate space for result arrays
/srvr/z5089358/postgresql-10.4/src/backend/executor/execIndexing.c:	 * XXX should free indexInfo array here too?  Currently we assume that
/srvr/z5089358/postgresql-10.4/src/backend/executor/execIndexing.c:						 values,	/* array of index Datums */
/srvr/z5089358/postgresql-10.4/src/backend/executor/tqueue.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/executor/tqueue.c: * may thus need remap processing.  We might need to look within arrays and
/srvr/z5089358/postgresql-10.4/src/backend/executor/tqueue.c:	TQUEUE_REMAP_ARRAY,			/* array */
/srvr/z5089358/postgresql-10.4/src/backend/executor/tqueue.c:	int16		typlen;			/* array element type's storage properties */
/srvr/z5089358/postgresql-10.4/src/backend/executor/tqueue.c:	TupleRemapInfo *element_remap;	/* array element type's remap info */
/srvr/z5089358/postgresql-10.4/src/backend/executor/tqueue.c: * Examine an array datum and send any necessary control messages for
/srvr/z5089358/postgresql-10.4/src/backend/executor/tqueue.c:	/* Deconstruct the array. */
/srvr/z5089358/postgresql-10.4/src/backend/executor/tqueue.c:	deconstruct_array(arr, typid, remapinfo->typlen,
/srvr/z5089358/postgresql-10.4/src/backend/executor/tqueue.c: * Process the given array datum and replace any transient record typmods
/srvr/z5089358/postgresql-10.4/src/backend/executor/tqueue.c:	/* Deconstruct the array. */
/srvr/z5089358/postgresql-10.4/src/backend/executor/tqueue.c:	deconstruct_array(arr, typid, remapinfo->typlen,
/srvr/z5089358/postgresql-10.4/src/backend/executor/tqueue.c:		/* Reconstruct and return the array.  */
/srvr/z5089358/postgresql-10.4/src/backend/executor/tqueue.c:		arr = construct_md_array(elem_values, elem_nulls,
/srvr/z5089358/postgresql-10.4/src/backend/executor/tqueue.c:	/* If it's a true array type, deal with it that way. */
/srvr/z5089358/postgresql-10.4/src/backend/executor/tqueue.c:	/* If not, the array doesn't either. */
/srvr/z5089358/postgresql-10.4/src/backend/executor/tqueue.c:	/* OK, set up to remap the array. */
/srvr/z5089358/postgresql-10.4/src/backend/executor/tqueue.c: * Returns an array of TupleRemapInfo pointers, or NULL if no field
Binary file /srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.o matches
/srvr/z5089358/postgresql-10.4/src/backend/executor/README:stored as a flat array in ExprState->steps[] (an array of ExprEvalStep,
/srvr/z5089358/postgresql-10.4/src/backend/executor/README:arg[] and argnull[] array elements in the FunctionCallInfoData struct that
/srvr/z5089358/postgresql-10.4/src/backend/executor/README:The last entry in a completed ExprState->steps array is always an
/srvr/z5089358/postgresql-10.4/src/backend/executor/README:EEOP_DONE step; this removes the need to test for end-of-array while
/srvr/z5089358/postgresql-10.4/src/backend/executor/README:array begins with EEOP_*_FETCHSOME steps that ensure that the relevant
/srvr/z5089358/postgresql-10.4/src/backend/executor/README:steps to be little more than an array lookup.
/srvr/z5089358/postgresql-10.4/src/backend/executor/README:ExecInitExprRec() pushes new operations into the ExprState->steps array
/srvr/z5089358/postgresql-10.4/src/backend/executor/README:array, ExprEvalPushStep() has to repalloc the entire array when there's
/srvr/z5089358/postgresql-10.4/src/backend/executor/README:palloc'd separately from the steps array.  For instance, the
/srvr/z5089358/postgresql-10.4/src/backend/executor/README:rather than being part of the ExprEvalStep array.  The overall result
/srvr/z5089358/postgresql-10.4/src/backend/executor/README:the integer index in the ExprState->steps array of the step to execute
/srvr/z5089358/postgresql-10.4/src/backend/executor/README:array, then recursively generate steps for the subexpression that might
/srvr/z5089358/postgresql-10.4/src/backend/executor/README:and tts_isnull[] array elements of the result slot.  There are special
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeModifyTable.c:		 * Build array of conversion maps from each child's TupleDesc to the
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeModifyTable.c:	 * value is to be used as an index into the arrays for the resultRelInfo
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeModifyTable.c:	 * results into the array "mt_plans".  This is also a convenient place to
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeBitmapAnd.c:	 * results into the array "bitmapplanstates".
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c: *		Evaluate any array key values, and set up to iterate through arrays.
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c: * Returns TRUE if there are array elements to consider; FALSE means there
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c: * is at least one null or empty array, so no match is possible.  On TRUE
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c: * result, the scankeys are initialized with the first elements of the arrays.
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:					   IndexArrayKeyInfo *arrayKeys, int numArrayKeys)
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:	/* We want to keep the arrays in per-tuple memory */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:		ScanKey		scan_key = arrayKeys[j].scan_key;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:		ExprState  *array_expr = arrayKeys[j].array_expr;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:		Datum		arraydatum;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:		ArrayType  *arrayval;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:		 * Compute and deconstruct the array expression. (Notes in
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:		arraydatum = ExecEvalExpr(array_expr,
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:		arrayval = DatumGetArrayTypeP(arraydatum);
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:		get_typlenbyvalalign(ARR_ELEMTYPE(arrayval),
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:		deconstruct_array(arrayval,
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:						  ARR_ELEMTYPE(arrayval),
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:		 * Note: we expect the previous array data, if any, to be
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:		arrayKeys[j].elem_values = elem_values;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:		arrayKeys[j].elem_nulls = elem_nulls;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:		arrayKeys[j].num_elems = num_elems;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:		arrayKeys[j].next_elem = 1;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c: *		Advance to the next set of array key values, if any.
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:ExecIndexAdvanceArrayKeys(IndexArrayKeyInfo *arrayKeys, int numArrayKeys)
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:	 * Note we advance the rightmost array key most quickly, since it will
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:		ScanKey		scan_key = arrayKeys[j].scan_key;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:		int			next_elem = arrayKeys[j].next_elem;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:		int			num_elems = arrayKeys[j].num_elems;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:		Datum	   *elem_values = arrayKeys[j].elem_values;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:		bool	   *elem_nulls = arrayKeys[j].elem_nulls;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:			found = false;		/* need to advance next array key */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:		arrayKeys[j].next_elem = next_elem + 1;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:		/* allocate arrays to hold the re-calculated distances */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c: * The index quals are passed to the index AM in the form of a ScanKey array.
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c: * For these, we create a header ScanKey plus a subsidiary ScanKey array,
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c: * 4. ScalarArrayOpExpr ("indexkey op ANY (array-expression)").  If the index
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c: * supports amsearcharray, we handle these the same as simple operators,
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c: * (Note that if we use an IndexArrayKeyInfo struct, the array expression is
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c: * *scanKeys: receives ptr to array of ScanKeys
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c: * *runtimeKeys: receives ptr to array of IndexRuntimeKeyInfos, or NULL if none
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c: * *arrayKeys: receives ptr to array of IndexArrayKeyInfos, or NULL if none
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c: * *numArrayKeys: receives number of array keys
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c: * Caller may pass NULL for arrayKeys and numArrayKeys to indicate that
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:					   IndexArrayKeyInfo **arrayKeys, int *numArrayKeys)
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:	IndexArrayKeyInfo *array_keys;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:	int			n_array_keys;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:	/* Allocate array for ScanKey structs: one per qual */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:	 * runtime_keys array is dynamically resized as needed.  We handle it this
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:	 * way so that the same runtime keys array can be shared between
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:	/* Allocate array_keys as large as it could possibly need to be */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:	array_keys = (IndexArrayKeyInfo *)
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:	n_array_keys = 0;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:			/* indexkey op ANY (array-expression) */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:			 * rightop is the constant or variable array value
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:			if (index->rd_amroutine->amsearcharray)
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:					 * op_righttype, but rather is an array of same; so
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:					 * assume that all array types are toastable.
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:				/* Executor has to expand the array value */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:				array_keys[n_array_keys].scan_key = this_scan_key;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:				array_keys[n_array_keys].array_expr =
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:				n_array_keys++;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:	/* Get rid of any unused arrays */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:	if (n_array_keys == 0)
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:		pfree(array_keys);
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:		array_keys = NULL;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:	if (arrayKeys)
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:		*arrayKeys = array_keys;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:		*numArrayKeys = n_array_keys;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeIndexscan.c:	else if (n_array_keys != 0)
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeAppend.c:	 * results into the array "appendplans".
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeAgg.c: *	  So we create an array, aggcontexts, with an ExprContext for each grouping
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeAgg.c:	/* deconstructed sorting information (arrays of length numSortCols) */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeAgg.c:	FmgrInfo   *equalfns;		/* array of length numDistinctCols */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeAgg.c: * In AGG_PLAIN and AGG_SORTED modes, we have a single array of these
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeAgg.c: * structs (pointed to by aggstate->pergroup); we re-use the array for
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeAgg.c: * hash table contains an array of these structs for each tuple group.
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeAgg.c: * representative tuple and an array of AggStatePerGroup structs for each
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeAgg.c: * then build an array of the columns included in the hashtable.  Note that
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeAgg.c: * the array is preserved over ExecReScanAgg, so we allocate it in the
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeAgg.c: * returning an array of pergroup pointers suitable for advance_aggregates.
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeAgg.c:		/* this is an array of pointers, not structures */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeAgg.c:		/* Mark Aggref state node with assigned index in the result array */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeAgg.c:	 * stick them into arrays.  We ignore ORDER BY for an ordered-set agg,
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c: *	using ExecInitExpr() et al.  This converts the tree into a flat array
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:				Expr	   *arrayarg;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:				arrayarg = (Expr *) lsecond(opexpr->args);
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:				 * Evaluate array argument into our return value.  There's no
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:				ExecInitExprRec(arrayarg, parent, state, resv, resnull);
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:				scratch.d.scalararrayop.element_type = InvalidOid;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:				scratch.d.scalararrayop.useOr = opexpr->useOr;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:				scratch.d.scalararrayop.finfo = finfo;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:				scratch.d.scalararrayop.fcinfo_data = fcinfo;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:				scratch.d.scalararrayop.fn_addr = finfo->fn_addr;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:							 errmsg("target type is not an array")));
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:				scratch.d.arraycoerce.coerceexpr = acoerce;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:				scratch.d.arraycoerce.resultelemtype = resultelemtype;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:					scratch.d.arraycoerce.elemfunc =
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:							  scratch.d.arraycoerce.elemfunc);
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:									   scratch.d.arraycoerce.elemfunc);
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:					/* Set up workspace for array_map */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:					scratch.d.arraycoerce.amstate =
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:					scratch.d.arraycoerce.elemfunc = NULL;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:					scratch.d.arraycoerce.amstate = NULL;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:				ArrayExpr  *arrayexpr = (ArrayExpr *) node;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:				int			nelems = list_length(arrayexpr->elements);
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:				 * array.  Elements are computed into scratch arrays
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:				scratch.d.arrayexpr.elemvalues =
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:				scratch.d.arrayexpr.elemnulls =
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:				scratch.d.arrayexpr.nelems = nelems;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:				scratch.d.arrayexpr.multidims = arrayexpr->multidims;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:				scratch.d.arrayexpr.elemtype = arrayexpr->element_typeid;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:				get_typlenbyvalalign(arrayexpr->element_typeid,
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:									 &scratch.d.arrayexpr.elemlength,
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:									 &scratch.d.arrayexpr.elembyval,
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:									 &scratch.d.arrayexpr.elemalign);
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:				foreach(lc, arrayexpr->elements)
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:									&scratch.d.arrayexpr.elemvalues[elemoff],
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:									&scratch.d.arrayexpr.elemnulls[elemoff]);
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:				/* and then collect all into an array */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:				 * workspace arrays are large enough and then initialize any
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c: * into that array may be used while the expression is still being built.
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:	arefstate->refattrlength = get_typlen(aref->refarraytype);
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:	 * Evaluate array input.  It's safe to do so into resv/resnull, because we
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:	 * implement this with just JUMP_IF_NULL, since we evaluated the array
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:				 errmsg("number of array dimensions (%d) exceeds the maximum allowed (%d)",
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:				 errmsg("number of array dimensions (%d) exceeds the maximum allowed (%d)",
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:		scratch->d.arrayref_subscript.state = arefstate;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:		scratch->d.arrayref_subscript.off = i;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:		scratch->d.arrayref_subscript.isupper = true;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:		scratch->d.arrayref_subscript.jumpdone = -1;	/* adjust later */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:		scratch->d.arrayref_subscript.state = arefstate;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:		scratch->d.arrayref_subscript.off = i;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:		scratch->d.arrayref_subscript.isupper = false;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:		scratch->d.arrayref_subscript.jumpdone = -1;	/* adjust later */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:		 * obtain and modify the previous value of the array element or slice
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:		 * array and pass it down via the CaseTestExpr mechanism.  It's safe
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:		 * here and where the value would be needed, and an array assignment
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:			scratch->d.arrayref.state = arefstate;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:		scratch->d.arrayref.state = arefstate;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:		/* array fetch is much simpler */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:		scratch->d.arrayref.state = arefstate;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:			Assert(as->d.arrayref_subscript.jumpdone == -1);
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:			as->d.arrayref_subscript.jumpdone = state->steps_len;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:		ArrayRef   *arrayRef = (ArrayRef *) expr;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.c:		if (arrayRef->refexpr && IsA(arrayRef->refexpr, CaseTestExpr))
/srvr/z5089358/postgresql-10.4/src/backend/executor/execMain.c: * we can just return a member of the es_result_relations array, the
/srvr/z5089358/postgresql-10.4/src/backend/executor/execMain.c: * es_root_result_relations array (if any), or the es_leaf_result_relations
/srvr/z5089358/postgresql-10.4/src/backend/executor/execMain.c:	 * The ResultRelInfo array management is trickier than it looks.  We
/srvr/z5089358/postgresql-10.4/src/backend/executor/execMain.c:	 * create a fresh array for the child but copy all the content from the
/srvr/z5089358/postgresql-10.4/src/backend/executor/execMain.c:	 * nested EPQ checks they should share es_epqTuple arrays.  This allows
/srvr/z5089358/postgresql-10.4/src/backend/executor/execMain.c: * 'pd' receives an array of PartitionDispatch objects with one entry for
/srvr/z5089358/postgresql-10.4/src/backend/executor/execMain.c: * 'partitions' receives an array of ResultRelInfo objects with one entry for
/srvr/z5089358/postgresql-10.4/src/backend/executor/execMain.c: * 'tup_conv_maps' receives an array of TupleConversionMap objects with one
/srvr/z5089358/postgresql-10.4/src/backend/executor/execMain.c: *		tree (= the number of entries in the 'pd' output array)
/srvr/z5089358/postgresql-10.4/src/backend/executor/execMain.c: *		output arrays
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeGather.c:				/* Make a working array showing the active readers */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeGather.c:		 * If this reader is done, remove it from our working array of active
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeGather.c:	/* Flush local copy of reader array */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execParallel.c: * the plan_node_id array.
/srvr/z5089358/postgresql-10.4/src/backend/executor/execParallel.c: * from parallel workers.  The length of this array is given by num_plan_nodes.
/srvr/z5089358/postgresql-10.4/src/backend/executor/execParallel.c:	/* array of num_plan_nodes * num_workers Instrumentation objects follows */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execParallel.c:	/* Add array of queues to shm_toc, so others can find it. */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execParallel.c:	/* Return array of handles. */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeWindowAgg.c:		/* Mark WindowFunc state node with assigned index in the result array */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeBitmapHeapscan.c: * builds an array indicating which tuples on the page are both potentially
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeMergejoin.c: * We build an array of MergeJoinClause structs containing the information
/srvr/z5089358/postgresql-10.4/src/backend/executor/functions.c:		/* Paranoia: ignore the result if too few array entries */
/srvr/z5089358/postgresql-10.4/src/backend/executor/functions.c:/* Build ParamListInfo array representing current arguments */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeTidscan.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeTidscan.c:	bool		isarray;		/* if true, it yields tid[] not just tid */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeTidscan.c:			tidexpr->isarray = false;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeTidscan.c:			tidexpr->isarray = true;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeTidscan.c: * (The result is actually an array, not a list.)
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeTidscan.c:	 * We initialize the array with enough slots for the case that all quals
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeTidscan.c:	 * ScalarArrayOpExprs, we may have to enlarge the array.
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeTidscan.c:		if (tidexpr->exprstate && !tidexpr->isarray)
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeTidscan.c:		else if (tidexpr->exprstate && tidexpr->isarray)
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeTidscan.c:			Datum		arraydatum;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeTidscan.c:			ArrayType  *itemarray;
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeTidscan.c:			arraydatum = ExecEvalExprSwitchContext(tidexpr->exprstate,
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeTidscan.c:			itemarray = DatumGetArrayTypeP(arraydatum);
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeTidscan.c:			deconstruct_array(itemarray,
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeTidscan.c:	 * Sort the array of TIDs into order, and eliminate duplicates.
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeLockRows.c:		/* safety check on size of lr_curtuples array */
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeBitmapIndexscan.c:	 * array key so we should do nothing.
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeBitmapIndexscan.c:	 * with biss_RuntimeKeysReady still false, then there is an empty array
/srvr/z5089358/postgresql-10.4/src/backend/executor/nodeBitmapIndexscan.c:	 * If we have runtime keys or array keys, we need an ExprContext to
Binary file /srvr/z5089358/postgresql-10.4/src/backend/executor/execExpr.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/executor/nodeTidscan.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/executor/nodeGatherMerge.o matches
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	 * This array has to be in the same order as enum ExprEvalOp.
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:			 * directly out of the slot's decomposed-data arrays.  But let's
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:			/* Process an array subscript */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:				EEO_JUMP(op->d.arrayref_subscript.jumpdone);
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:			 * Fetch the old value in an arrayref assignment, in case it's
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:		 * Fetch subset of an array.
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c: * ecxt_param_exec_vals array, and can be accessed by array index.
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c: * The individual array elements (or subarrays) have already been evaluated
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c: * into op->d.arrayexpr.elemvalues[]/elemnulls[].
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	Oid			element_type = op->d.arrayexpr.elemtype;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	int			nelems = op->d.arrayexpr.nelems;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	if (!op->d.arrayexpr.multidims)
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:		Datum	   *dvalues = op->d.arrayexpr.elemvalues;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:		bool	   *dnulls = op->d.arrayexpr.elemnulls;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:		/* Shouldn't happen here, but if length is 0, return empty array */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:				PointerGetDatum(construct_empty_array(element_type));
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:		/* setup for 1-D array of the given length */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:		result = construct_md_array(dvalues, dnulls, ndims, dims, lbs,
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:									op->d.arrayexpr.elemlength,
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:									op->d.arrayexpr.elembyval,
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:									op->d.arrayexpr.elemalign);
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:		/* Must be nested array expressions */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:			Datum		arraydatum;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:			ArrayType  *array;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:			arraydatum = op->d.arrayexpr.elemvalues[elemoff];
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:			eisnull = op->d.arrayexpr.elemnulls[elemoff];
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:			/* temporarily ignore null subarrays */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:			array = DatumGetArrayTypeP(arraydatum);
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:			if (element_type != ARR_ELEMTYPE(array))
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:						 errmsg("cannot merge incompatible arrays"),
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:								   format_type_be(ARR_ELEMTYPE(array)),
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:			this_ndims = ARR_NDIM(array);
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:			/* temporarily ignore zero-dimensional subarrays */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:				/* Get sub-array details from first member */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:							 errmsg("number of array dimensions (%d) exceeds " \
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:				memcpy(elem_dims, ARR_DIMS(array), elem_ndims * sizeof(int));
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:				memcpy(elem_lbs, ARR_LBOUND(array), elem_ndims * sizeof(int));
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:				/* Check other sub-arrays are compatible */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:					memcmp(elem_dims, ARR_DIMS(array),
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:					memcmp(elem_lbs, ARR_LBOUND(array),
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:							 errmsg("multidimensional arrays must have array "
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:			subdata[outer_nelems] = ARR_DATA_PTR(array);
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:			subbitmaps[outer_nelems] = ARR_NULLBITMAP(array);
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:			subbytes[outer_nelems] = ARR_SIZE(array) - ARR_DATA_OFFSET(array);
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:													 ARR_DIMS(array));
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:			havenulls |= ARR_HASNULL(array);
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:		 * If all items were null or empty arrays, return an empty array;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:		 * array formed from empty arrays.  It's not ideal...)
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:			if (ndims == 0)		/* didn't find any nonempty array */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:				*op->resvalue = PointerGetDatum(construct_empty_array(element_type));
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:					 errmsg("multidimensional arrays must have array "
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:		/* setup for multi-D array */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:				array_bitmap_copy(ARR_NULLBITMAP(result), iitem,
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c: * Source array is in step's result variable.
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	ArrayCoerceExpr *acoerce = op->d.arraycoerce.coerceexpr;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	Datum		arraydatum;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	/* NULL array -> NULL result */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	arraydatum = *op->resvalue;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	 * If it's binary-compatible, modify the element type in the array header,
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	 * but otherwise leave the array as we received it.
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:		/* Detoast input array if necessary, and copy in any case */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:		ArrayType  *array = DatumGetArrayTypePCopy(arraydatum);
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:		ARR_ELEMTYPE(array) = op->d.arraycoerce.resultelemtype;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:		*op->resvalue = PointerGetDatum(array);
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	 * Use array_map to apply the function to each array element.
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	InitFunctionCallInfoData(locfcinfo, op->d.arraycoerce.elemfunc, 3,
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	locfcinfo.arg[0] = arraydatum;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	*op->resvalue = array_map(&locfcinfo, op->d.arraycoerce.resultelemtype,
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:							  op->d.arraycoerce.amstate);
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c: * Deform source tuple, filling in the step's values/nulls arrays, before
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c: * arrays with the new field values, and then FIELDSTORE_FORM will build the
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	ArrayRefState *arefstate = op->d.arrayref_subscript.state;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:					 errmsg("array subscript in assignment must not be null")));
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	if (op->d.arrayref_subscript.isupper)
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	off = op->d.arrayref_subscript.off;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c: * Source array is in step's result variable.
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	ArrayRefState *arefstate = op->d.arrayref.state;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	/* Should not get here if source array (or any subscript) is null */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:		*op->resvalue = array_get_element(*op->resvalue,
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:		*op->resvalue = array_get_slice(*op->resvalue,
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c: * Compute old array element/slice value for an ArrayRef assignment
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	ArrayRefState *arefstate = op->d.arrayref.state;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:		/* whole array is null, so any element or slice is too */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:		arefstate->prevvalue = array_get_element(*op->resvalue,
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:		arefstate->prevvalue = array_get_slice(*op->resvalue,
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c: * Input array (possibly null) is in result area, replacement value is in
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	ArrayRefState *arefstate = op->d.arrayref.state;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	 * For an assignment to a fixed-length array type, both the original array
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	 * return the original array.
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	if (arefstate->refattrlength > 0)	/* fixed-length array? */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	 * For assignment to varlena arrays, we handle a NULL original array by
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	 * substituting an empty (zero-dimensional) array; insertion of the new
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	 * element will result in a singleton array value.  It does not matter
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:		*op->resvalue = PointerGetDatum(construct_empty_array(arefstate->refelemtype));
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:		*op->resvalue = array_set_element(*op->resvalue,
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:		*op->resvalue = array_set_slice(*op->resvalue,
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c: * Evaluate "scalar op ANY/ALL (array)".
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c: * Source array is in our result area, scalar arg is already evaluated into
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c: * array elements using OR and AND (for ANY and ALL respectively).  Of course
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	FunctionCallInfo fcinfo = op->d.scalararrayop.fcinfo_data;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	bool		useOr = op->d.scalararrayop.useOr;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	bool		strictfunc = op->d.scalararrayop.finfo->fn_strict;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	 * If the array is NULL then we return NULL --- it's not very meaningful
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	/* Else okay to fetch and detoast the array */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	 * If the array is empty, we return either FALSE or TRUE per the useOr
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	if (op->d.scalararrayop.element_type != ARR_ELEMTYPE(arr))
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:							 &op->d.scalararrayop.typlen,
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:							 &op->d.scalararrayop.typbyval,
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:							 &op->d.scalararrayop.typalign);
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:		op->d.scalararrayop.element_type = ARR_ELEMTYPE(arr);
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	typlen = op->d.scalararrayop.typlen;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	typbyval = op->d.scalararrayop.typbyval;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	typalign = op->d.scalararrayop.typalign;
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	/* Loop over the array elements */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:		/* Get array element, checking for NULL */
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:			thisresult = (op->d.scalararrayop.fn_addr) (fcinfo);
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c: * and/or argvalue/argnull arrays.
/srvr/z5089358/postgresql-10.4/src/backend/executor/execExprInterp.c:	 * Datum/isnull arrays.
/srvr/z5089358/postgresql-10.4/src/backend/tcop/postgres.c:	 * or when this function is called a second time with another array.
/srvr/z5089358/postgresql-10.4/src/backend/tcop/postgres.c: * by the postmaster, these are not the original argv array of the process.)
Binary file /srvr/z5089358/postgresql-10.4/src/backend/statistics/dependencies.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/statistics/extended_stats.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/statistics/mvdistinct.o matches
/srvr/z5089358/postgresql-10.4/src/backend/statistics/dependencies.c:	AttrNumber *dependencies;	/* array of pre-generated dependencies	*/
/srvr/z5089358/postgresql-10.4/src/backend/statistics/dependencies.c:	 * Transform the bms into an array, to make accessing i-th member easier.
/srvr/z5089358/postgresql-10.4/src/backend/statistics/dependencies.c:	/* prepare the sort function for the first dimension, and SortItem array */
/srvr/z5089358/postgresql-10.4/src/backend/statistics/dependencies.c:		/* accumulate all the data for both columns into an array and sort it */
/srvr/z5089358/postgresql-10.4/src/backend/statistics/dependencies.c:	 * Walk through the sorted array, split it into rows according to the
/srvr/z5089358/postgresql-10.4/src/backend/statistics/dependencies.c:	/* loop 1 beyond the end of the array so that we count the final group */
/srvr/z5089358/postgresql-10.4/src/backend/statistics/dependencies.c:	 * Transform the bms into an array, to make accessing i-th member easier.
/srvr/z5089358/postgresql-10.4/src/backend/statistics/dependencies.c:		AttrNumber *dependency; /* array with k elements */
/srvr/z5089358/postgresql-10.4/src/backend/statistics/dependencies.c:				 errmsg("invalid zero-length item array in MVDependencies")));
/srvr/z5089358/postgresql-10.4/src/backend/statistics/mvdistinct.c:	int			ncombinations;	/* number of combinations (size of array) */
/srvr/z5089358/postgresql-10.4/src/backend/statistics/mvdistinct.c:	int		   *combinations;	/* array of pre-built combinations */
/srvr/z5089358/postgresql-10.4/src/backend/statistics/mvdistinct.c:	/* must consume exactly the whole output array */
/srvr/z5089358/postgresql-10.4/src/backend/statistics/mvdistinct.c:				 errmsg("invalid zero-length item array in MVNDistinct")));
/srvr/z5089358/postgresql-10.4/src/backend/statistics/mvdistinct.c:	 * values[]/isnull[] arrays with all the data we have, then sort them
/srvr/z5089358/postgresql-10.4/src/backend/statistics/mvdistinct.c:		/* accumulate all the data for this dimension into the arrays */
/srvr/z5089358/postgresql-10.4/src/backend/statistics/mvdistinct.c:	/* We can sort the array now ... */
/srvr/z5089358/postgresql-10.4/src/backend/statistics/mvdistinct.c: * Returns a combination of K array indexes (0 .. N), as specified to
/srvr/z5089358/postgresql-10.4/src/backend/statistics/mvdistinct.c:		/* we got a valid combination, add it to the array */
/srvr/z5089358/postgresql-10.4/src/backend/statistics/extended_stats.c:		/* decode the stxkind char array into a list of chars */
/srvr/z5089358/postgresql-10.4/src/backend/statistics/extended_stats.c:			elog(ERROR, "stxkind is not a 1-D char array");
/srvr/z5089358/postgresql-10.4/src/backend/statistics/extended_stats.c: * VacAttrStats array which includes only the items corresponding to
/srvr/z5089358/postgresql-10.4/src/backend/rewrite/rewriteManip.c: * to the given mapping array (varattno n is replaced by attno_map[n-1]).
/srvr/z5089358/postgresql-10.4/src/backend/rewrite/rewriteManip.c: * A zero in the mapping array represents a dropped column, which should not
/srvr/z5089358/postgresql-10.4/src/backend/rewrite/rewriteManip.c:	const AttrNumber *attno_map;	/* map array for user attnos */
/srvr/z5089358/postgresql-10.4/src/backend/rewrite/rewriteHandler.c: * portions of an array or record field, for example
/srvr/z5089358/postgresql-10.4/src/backend/rewrite/rewriteHandler.c: *		foo = array_set_element(array_set_element(foo, 2, 42), 4, 43)
/srvr/z5089358/postgresql-10.4/src/backend/rewrite/rewriteHandler.c:	 * once and transferring TLEs into an array, then scanning the array to
/srvr/z5089358/postgresql-10.4/src/backend/rewrite/rewriteDefine.c:	 * Set up *nulls and *values arrays
/srvr/z5089358/postgresql-10.4/src/backend/lib/hyperloglog.c:	 * Initialize hashes array to zero, not negative infinity, per discussion
/srvr/z5089358/postgresql-10.4/src/backend/lib/binaryheap.c: * The heap is represented as an array of nodes, with the root node
/srvr/z5089358/postgresql-10.4/src/backend/lib/knapsack.c: * start of pass number i, the values[w] array contains the largest value
Binary file /srvr/z5089358/postgresql-10.4/src/backend/libpq/hba.o matches
/srvr/z5089358/postgresql-10.4/src/backend/libpq/hba.c: * The following character array represents the names of the authentication
/srvr/z5089358/postgresql-10.4/src/backend/libpq/hba.c: * Create a text array listing the options specified in the HBA line.
/srvr/z5089358/postgresql-10.4/src/backend/libpq/hba.c:		return construct_array(options, noptions, TEXTOID, -1, false, 'i');
/srvr/z5089358/postgresql-10.4/src/backend/libpq/hba.c:			 * on the grounds that it makes it harder to compare the array
/srvr/z5089358/postgresql-10.4/src/backend/libpq/hba.c:			values[index++] = PointerGetDatum(strlist_to_textarray(names));
/srvr/z5089358/postgresql-10.4/src/backend/libpq/hba.c:			values[index++] = PointerGetDatum(strlist_to_textarray(roles));
/srvr/z5089358/postgresql-10.4/src/backend/libpq/ifaddr.c: * standard way to iterate the struct ifreq returned in the array.
/srvr/z5089358/postgresql-10.4/src/backend/libpq/be-fsstubs.c: * LO "FD"s are indexes into the cookies array.
/srvr/z5089358/postgresql-10.4/src/backend/libpq/be-fsstubs.c: * LO private memory context "fscxt".  The cookies array itself is also
/srvr/z5089358/postgresql-10.4/src/backend/libpq/be-fsstubs.c:	 * Close LO fds and clear cookies array so that LO fds are no longer good.
/srvr/z5089358/postgresql-10.4/src/backend/libpq/be-fsstubs.c:	/* No free slot, so make the array bigger */
/srvr/z5089358/postgresql-10.4/src/backend/libpq/be-fsstubs.c:		/* First time through, arbitrarily make 64-element array */
/srvr/z5089358/postgresql-10.4/src/backend/libpq/be-fsstubs.c:		/* Double size of array */
/srvr/z5089358/postgresql-10.4/src/backend/libpq/pqcomm.c: * Successfully opened sockets are added to the ListenSocket[] array (of
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/geqo/geqo_recombination.c:	 * We must fill the tour[] array with a random permutation of the numbers
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/geqo/geqo_recombination.c:	 * each new value to the array and then swap it with a randomly-chosen
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/geqo/geqo_recombination.c:	 * array element (possibly including itself, else we fail to generate
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/geqo/geqo_recombination.c:		/* i != j check avoids fetching uninitialized array element */
Binary file /srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.o matches
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:				 * If the transition function is array_append(), it'll use an
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:				 * expanded array as transvalue, which will occupy at least
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:			 * array_agg() for instance.
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:		/* array assignment is nonstrict, but subscripting is strict */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:	 * the array level, regardless of elemfunc.
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:		/* ArrayCoerceExpr is strict at the array level */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:		/* ArrayCoerceExpr is strict at the array level */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c: * "foo op ALL array" is strict if the op is strict *and* we can prove
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c: * that the array input isn't an empty array.  We can check that
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c: * for the cases of an array constant and an ARRAY[] construct.
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c: * "foo op ANY array" is strict in the falseOK sense if the op is strict.
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c: * If not falseOK, the test is the same as for "foo op ALL array".
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:	/* Else, we have to see if the array is provably non-empty. */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:		Datum		arraydatum = ((Const *) rightop)->constvalue;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:		bool		arrayisnull = ((Const *) rightop)->constisnull;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:		ArrayType  *arrayval;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:		if (arrayisnull)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:		arrayval = DatumGetArrayTypeP(arraydatum);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:		nitems = ArrayGetNItems(ARR_NDIM(arrayval), ARR_DIMS(arrayval));
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:		ArrayExpr  *arrayexpr = (ArrayExpr *) rightop;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:		if (arrayexpr->elements != NIL && !arrayexpr->multidims)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:				ArrayExpr  *arrayexpr = (ArrayExpr *) node;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:				ArrayExpr  *newarray;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:				foreach(element, arrayexpr->elements)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:				newarray = makeNode(ArrayExpr);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:				newarray->array_typeid = arrayexpr->array_typeid;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:				newarray->array_collid = arrayexpr->array_collid;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:				newarray->element_typeid = arrayexpr->element_typeid;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:				newarray->elements = newelems;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:				newarray->multidims = arrayexpr->multidims;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:				newarray->location = arrayexpr->location;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:					return (Node *) evaluate_expr((Expr *) newarray,
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:												  newarray->array_typeid,
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:												  newarray->array_collid);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:				return (Node *) newarray;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:	Node	   *argarray[FUNC_MAX_ARGS];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:	MemSet(argarray, 0, pronargs * sizeof(Node *));
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:	/* Deconstruct the argument list into an array indexed by argnumber */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:			Assert(argarray[i] == NULL);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:			argarray[i++] = arg;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:			Assert(argarray[na->argnumber] == NULL);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:			argarray[na->argnumber] = (Node *) na->arg;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:	 * Fetch default expressions, if needed, and insert into array at proper
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:			if (argarray[i] == NULL)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:				argarray[i] = (Node *) lfirst(lc);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:		Assert(argarray[i] != NULL);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/clauses.c:		args = lappend(args, argarray[i]);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c: * Proof attempts involving large arrays in ScalarArrayOpExpr nodes are
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c: * So we set an arbitrary limit on the number of array elements that
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:static void arrayconst_startup_fn(Node *clause, PredIterInfo info);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:static Node *arrayconst_next_fn(PredIterInfo info);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:static void arrayconst_cleanup_fn(PredIterInfo info);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:static void arrayexpr_startup_fn(Node *clause, PredIterInfo info);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:static Node *arrayexpr_next_fn(PredIterInfo info);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:static void arrayexpr_cleanup_fn(PredIterInfo info);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c: * ScalarArrayOpExpr's array has too many elements, we just classify it as an
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:		Node	   *arraynode = (Node *) lsecond(saop->args);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:		 * know how to iterate through expressions for the array's elements.
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:		 * We can do that if the array operand is a non-null constant or a
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:		if (arraynode && IsA(arraynode, Const) &&
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:			!((Const *) arraynode)->constisnull)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:			ArrayType  *arrayval;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:			arrayval = DatumGetArrayTypeP(((Const *) arraynode)->constvalue);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:			nelems = ArrayGetNItems(ARR_NDIM(arrayval), ARR_DIMS(arrayval));
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:				info->startup_fn = arrayconst_startup_fn;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:				info->next_fn = arrayconst_next_fn;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:				info->cleanup_fn = arrayconst_cleanup_fn;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:		else if (arraynode && IsA(arraynode, ArrayExpr) &&
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:				 !((ArrayExpr *) arraynode)->multidims &&
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:				 list_length(((ArrayExpr *) arraynode)->elements) <= MAX_SAOP_ARRAY_SIZE)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:			info->startup_fn = arrayexpr_startup_fn;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:			info->next_fn = arrayexpr_next_fn;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:			info->cleanup_fn = arrayexpr_cleanup_fn;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c: * constant array operand.
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:arrayconst_startup_fn(Node *clause, PredIterInfo info)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:	Const	   *arrayconst;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:	ArrayType  *arrayval;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:	/* Deconstruct the array literal */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:	arrayconst = (Const *) lsecond(saop->args);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:	arrayval = DatumGetArrayTypeP(arrayconst->constvalue);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:	get_typlenbyvalalign(ARR_ELEMTYPE(arrayval),
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:	deconstruct_array(arrayval,
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:					  ARR_ELEMTYPE(arrayval),
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:	state->constexpr.consttype = ARR_ELEMTYPE(arrayval);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:	state->constexpr.constcollid = arrayconst->constcollid;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:arrayconst_next_fn(PredIterInfo info)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:arrayconst_cleanup_fn(PredIterInfo info)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c: * one-dimensional ArrayExpr array operand.
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:arrayexpr_startup_fn(Node *clause, PredIterInfo info)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:	ArrayExpr  *arrayexpr;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:	arrayexpr = (ArrayExpr *) lsecond(saop->args);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:	state->next = list_head(arrayexpr->elements);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:arrayexpr_next_fn(PredIterInfo info)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/predtest.c:arrayexpr_cleanup_fn(PredIterInfo info)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/tlist.c: * extract_grouping_ops - make an array of the equality operator OIDs
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/tlist.c: * extract_grouping_cols - make an array of the grouping column resnos
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/orclauses.c:	for (rti = 1; rti < root->simple_rel_array_size; rti++)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/orclauses.c:		RelOptInfo *rel = root->simple_rel_array[rti];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/orclauses.c:		Assert(rel->relid == rti);	/* sanity check on array */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/relnode.c: * setup_simple_rel_arrays
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/relnode.c: *	  Prepare the arrays we use for quickly accessing base relations.
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/relnode.c:setup_simple_rel_arrays(PlannerInfo *root)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/relnode.c:	root->simple_rel_array_size = list_length(root->parse->rtable) + 1;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/relnode.c:	/* simple_rel_array is initialized to all NULLs */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/relnode.c:	root->simple_rel_array = (RelOptInfo **)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/relnode.c:		palloc0(root->simple_rel_array_size * sizeof(RelOptInfo *));
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/relnode.c:	/* simple_rte_array is an array equivalent of the rtable list */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/relnode.c:	root->simple_rte_array = (RangeTblEntry **)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/relnode.c:		palloc0(root->simple_rel_array_size * sizeof(RangeTblEntry *));
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/relnode.c:		root->simple_rte_array[rti++] = rte;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/relnode.c:	Assert(relid > 0 && relid < root->simple_rel_array_size);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/relnode.c:	if (root->simple_rel_array[relid] != NULL)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/relnode.c:	rte = root->simple_rte_array[relid];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/relnode.c:			 * up attr range and arrays
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/relnode.c:	/* Save the finished struct in the query's simple_rel_array */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/relnode.c:	root->simple_rel_array[relid] = rel;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/relnode.c:	if (relid < root->simple_rel_array_size)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/relnode.c:		rel = root->simple_rel_array[relid];
Binary file /srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/relnode.o matches
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/plancat.c: * Also, initialize the attr_needed[] and attr_widths[] arrays.  In most
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/plancat.c: * If inhparent is true, all we need to do is set up the attr arrays:
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/plancat.c:			info->amsearcharray = amroutine->amsearcharray;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/util/plancat.c:		 * First, build the array of columns covered.  This is ultimately
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/indxpath.c:		/* Protect limited-size array in IndexClauseSets */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/indxpath.c:				if (!index->amsearcharray)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/indxpath.c:	PathClauseUsage **pathinfoarray;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/indxpath.c:	 * The surviving paths are put into an array for qsort'ing.
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/indxpath.c:	pathinfoarray = (PathClauseUsage **)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/indxpath.c:			if (bms_equal(pathinfo->clauseids, pathinfoarray[i]->clauseids))
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/indxpath.c:			cost_bitmap_tree_node(pathinfoarray[i]->path, &ocost, &oselec);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/indxpath.c:				pathinfoarray[i] = pathinfo;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/indxpath.c:			/* not duplicate clauseids, add to array */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/indxpath.c:			pathinfoarray[npaths++] = pathinfo;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/indxpath.c:		return pathinfoarray[0]->path;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/indxpath.c:	qsort(pathinfoarray, npaths, sizeof(PathClauseUsage *),
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/indxpath.c:		pathinfo = pathinfoarray[i];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/indxpath.c:			pathinfo = pathinfoarray[j];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/indxpath.c:		if (outer_relid >= root->simple_rel_array_size)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/indxpath.c:		outer_rel = root->simple_rel_array[outer_relid];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/indxpath.c:		Assert(outer_rel->relid == outer_relid);	/* sanity check on array */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/indxpath.c:		if (relid >= root->simple_rel_array_size)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/indxpath.c:		rel = root->simple_rel_array[relid];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/indxpath.c:		Assert(rel->relid == relid);	/* sanity check on array */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/indxpath.c: *	  the clause is of the form "indexkey op ANY (arrayconst)".
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/clausesel.c:		s1 = scalararraysel(root,
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/costsize.c:			/* Each element of the array yields 1 tuple */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/costsize.c:			Node	   *arraynode = (Node *) lsecond(saop->args);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/costsize.c:			ntuples += estimate_array_length(arraynode);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/costsize.c:		 * array elements before the answer is determined.
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/costsize.c:		Node	   *arraynode = (Node *) lsecond(saop->args);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/costsize.c:			cpu_operator_cost * estimate_array_length(arraynode) * 0.5;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/costsize.c:		Node	   *arraynode = (Node *) acoerce->arg;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/costsize.c:				cpu_operator_cost * estimate_array_length(arraynode);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/costsize.c:			if (var->varno < root->simple_rel_array_size)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/costsize.c:				RelOptInfo *rel = root->simple_rel_array[var->varno];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/pathkeys.c:	 * Make arrays of the ECs used by the mergeclauses (dropping any
Binary file /srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/clausesel.o matches
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/allpaths.c:	for (rti = 1; rti < root->simple_rel_array_size; rti++)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/allpaths.c:		RelOptInfo *brel = root->simple_rel_array[rti];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/allpaths.c:		Assert(brel->relid == rti); /* sanity check on array */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/allpaths.c:	for (rti = 1; rti < root->simple_rel_array_size; rti++)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/allpaths.c:		RelOptInfo *rel = root->simple_rel_array[rti];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/allpaths.c:		Assert(rel->relid == rti);	/* sanity check on array */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/allpaths.c:		rte = root->simple_rte_array[rti];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/allpaths.c:	for (rti = 1; rti < root->simple_rel_array_size; rti++)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/allpaths.c:		RelOptInfo *rel = root->simple_rel_array[rti];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/allpaths.c:		Assert(rel->relid == rti);	/* sanity check on array */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/allpaths.c:		set_rel_pathlist(root, rel, rti, root->simple_rte_array[rti]);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/allpaths.c:		childRTE = root->simple_rte_array[childRTindex];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/allpaths.c:		childRTE = root->simple_rte_array[childRTindex];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/allpaths.c:		childrel = root->simple_rel_array[childRTindex];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/allpaths.c:	for (rti = 1; rti < root->simple_rel_array_size; rti++)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/allpaths.c:		RelOptInfo *brel = root->simple_rel_array[rti];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/allpaths.c: * be referenced by some/all quals.  The unsafeColumns[] array will be
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/allpaths.c: * safetyInfo->unsafeColumns[] is the result array.
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/allpaths.c:		if (x < root->simple_rel_array_size &&
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/allpaths.c:			root->simple_rte_array[x])
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/allpaths.c:			printf("%s", root->simple_rte_array[x]->eref->aliasname);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/equivclass.c:	for (rti = 1; rti < root->simple_rel_array_size; rti++)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/equivclass.c:		RelOptInfo *brel = root->simple_rel_array[rti];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/equivclass.c:		palloc0(root->simple_rel_array_size * sizeof(EquivalenceMember *));
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/equivclass.c:		Assert(relid < root->simple_rel_array_size);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/tidpath.c: * conditions of the form CTID = ANY(pseudoconstant_array).  In particular
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/tidpath.c: *		CTID = ANY (pseudoconstant_array)
Binary file /srvr/z5089358/postgresql-10.4/src/backend/optimizer/path/costsize.o matches
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/subselect.c:		Oid			arraytype;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/subselect.c:		arraytype = get_promoted_array_type(exprType((Node *) te->expr));
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/subselect.c:		if (!OidIsValid(arraytype))
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/subselect.c:			elog(ERROR, "could not find array type for datatype %s",
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/subselect.c:								 arraytype,
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/subselect.c:		/* array_eq is strict, but must check input type to ensure hashable */
Binary file /srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planmain.o matches
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/createplan.c:	 * tlist.  First, identify max SortGroupRef in groupClause, for array
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/createplan.c: * We are given the target WindowClause and an array of the input column
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/createplan.c:		/* first, allocate what's certainly enough space for the arrays */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/createplan.c:	 * Compute the opfamily/collation/strategy/nullsfirst arrays needed by the
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/createplan.c:			rte = root->simple_rte_array[var->varno];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/createplan.c:	 * Collect the items and costs into an array.  This is to avoid repeated
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/createplan.c:		/* insert newitem into the already-sorted subarray */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/createplan.c:	 * convert SortGroupClause list into arrays of attr indexes and equality
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/createplan.c: * nullsFirst arrays already.
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/createplan.c: *	  'reqColIdx' is NULL or an array of required sort key column numbers
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/createplan.c: * We must convert the pathkey information into arrays of sort key column
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/createplan.c:		/* Add the column to the sort arrays */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/createplan.c:	/* Convert list-ish representation to arrays wanted by executor */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/createplan.c: * but presently we *must* use the grpColIdx[] array to locate sort columns,
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/createplan.c:	/* Convert list-ish representation to arrays wanted by executor */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/createplan.c:	 * convert SortGroupClause list into arrays of attr indexes and equality
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/createplan.c:	 * Convert pathkeys list into arrays of attr indexes and equality
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/createplan.c:	 * convert SortGroupClause list into arrays of attr indexes and equality
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/createplan.c:		if (rti < root->simple_rel_array_size &&
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/createplan.c:			root->simple_rel_array[rti] != NULL)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/createplan.c:			RelOptInfo *resultRel = root->simple_rel_array[rti];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planner.c:	int			save_rel_array_size = 0;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planner.c:	RelOptInfo **save_rel_array = NULL;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planner.c:		 * last child's simple_rel_array (previous ones are too short), so we
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planner.c:		Assert(subroot->simple_rel_array_size >= save_rel_array_size);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planner.c:		for (rti = 1; rti < save_rel_array_size; rti++)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planner.c:			RelOptInfo *brel = save_rel_array[rti];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planner.c:				subroot->simple_rel_array[rti] = brel;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planner.c:		save_rel_array_size = subroot->simple_rel_array_size;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planner.c:		save_rel_array = subroot->simple_rel_array;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planner.c:	root->simple_rel_array_size = save_rel_array_size;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planner.c:	root->simple_rel_array = save_rel_array;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planner.c:	/* Must reconstruct master's simple_rte_array, too */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planner.c:	root->simple_rte_array = (RangeTblEntry **)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planner.c:		root->simple_rte_array[rti++] = rte;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planner.c:	/* Allocate workspace array for remapping */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planner.c:	surplusvars = NULL;			/* don't allocate array unless required */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planner.c:			 * allocate the surplusvars[] array until we find something.
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planner.c:	 * adjacency[i] = array [n, v1, v2, ... vn] of adjacency indices
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planner.c:	/* Set up RTE/RelOptInfo arrays */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planner.c:	setup_simple_rel_arrays(root);
Binary file /srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planner.o matches
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/initsplan.c:	 * Examine all baserels (the rel array has been set up by now).
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/initsplan.c:	for (rti = 1; rti < root->simple_rel_array_size; rti++)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/initsplan.c:		RelOptInfo *brel = root->simple_rel_array[rti];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/initsplan.c:		Assert(brel->relid == rti); /* sanity check on array */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/initsplan.c:	RangeTblEntry *rte = root->simple_rte_array[rtindex];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/initsplan.c:	 * Examine all baserels (the rel array has been set up by now).
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/initsplan.c:	for (rti = 1; rti < root->simple_rel_array_size; rti++)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/initsplan.c:		RelOptInfo *brel = root->simple_rel_array[rti];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/initsplan.c:		Assert(brel->relid == rti); /* sanity check on array */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/initsplan.c:	for (rti = 1; rti < root->simple_rel_array_size; rti++)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/initsplan.c:		RelOptInfo *brel = root->simple_rel_array[rti];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/initsplan.c:		for (rti2 = 1; rti2 < root->simple_rel_array_size; rti2++)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/initsplan.c:			RelOptInfo *brel2 = root->simple_rel_array[rti2];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/initsplan.c:	for (rti = 1; rti < root->simple_rel_array_size; rti++)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/initsplan.c:		RelOptInfo *brel = root->simple_rel_array[rti];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/initsplan.c:			RelOptInfo *brel2 = root->simple_rel_array[rti2];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/initsplan.c:	for (rti = 1; rti < root->simple_rel_array_size; rti++)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/initsplan.c:		RelOptInfo *brel = root->simple_rel_array[rti];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/initsplan.c:		if (root->simple_rte_array[rti]->inh)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/initsplan.c:				childrel = root->simple_rel_array[appinfo->child_relid];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/initsplan.c:	RangeTblEntry *rte = root->simple_rte_array[rti];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/initsplan.c:		if (fkinfo->con_relid >= root->simple_rel_array_size ||
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/initsplan.c:			fkinfo->ref_relid >= root->simple_rel_array_size)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/initsplan.c:		con_rel = root->simple_rel_array[fkinfo->con_relid];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/initsplan.c:		ref_rel = root->simple_rel_array[fkinfo->ref_relid];
Binary file /srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/subselect.o matches
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/setrefs.c:			rti < root->simple_rel_array_size)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/setrefs.c:			RelOptInfo *rel = root->simple_rel_array[rti];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/setrefs.c:				Assert(rel->relid == rti);	/* sanity check on array */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/setrefs.c:	/* Find the Vars and fill in the index array */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/setrefs.c:	/* Find the desired Vars and fill in the index array */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planmain.c:	 * array for indexing base relations.
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planmain.c:	setup_simple_rel_arrays(root);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planmain.c:	for (rti = 1; rti < root->simple_rel_array_size; rti++)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planmain.c:		RelOptInfo *brel = root->simple_rel_array[rti];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/planmain.c:		Assert(brel->relid == rti); /* sanity check on array */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/analyzejoins.c:	 * (Removing it from the baserel array altogether seems too risky.)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/analyzejoins.c:	 * Remove references to the rel from other baserels' attr_needed arrays.
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/analyzejoins.c:	for (rti = 1; rti < root->simple_rel_array_size; rti++)
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/analyzejoins.c:		RelOptInfo *otherrel = root->simple_rel_array[rti];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/analyzejoins.c:		Assert(otherrel->relid == rti); /* sanity check on array */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/analyzejoins.c:		Query	   *subquery = root->simple_rte_array[rel->relid]->subquery;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/plan/analyzejoins.c:		Query	   *subquery = root->simple_rte_array[relid]->subquery;
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/prep/prepjointree.c:	/* initialize cache array with indexes 0 .. length(tlist) */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/prep/prepjointree.c:	/* initialize cache array with indexes 0 .. length(tlist) */
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/prep/prepunion.c:	 * arrays for that.
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/prep/prepunion.c:	setup_simple_rel_arrays(root);
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/prep/prepunion.c:	leftmostRTE = root->simple_rte_array[((RangeTblRef *) node)->rtindex];
/srvr/z5089358/postgresql-10.4/src/backend/optimizer/prep/prepunion.c:		RangeTblEntry *rte = root->simple_rte_array[rtr->rtindex];
Binary file /srvr/z5089358/postgresql-10.4/src/backend/optimizer/prep/prepunion.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.o matches
/srvr/z5089358/postgresql-10.4/src/backend/nodes/tidbitmap.c: * Holds array of pagetable entries.
/srvr/z5089358/postgresql-10.4/src/backend/nodes/tidbitmap.c:	TBM_NOT_ITERATING,			/* not yet converted to page and chunk array */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/tidbitmap.c:	TBM_ITERATING_PRIVATE,		/* converted to local page and chunk array */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/tidbitmap.c:	TBM_ITERATING_SHARED		/* converted to shared page and chunk array */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/tidbitmap.c:	dsa_pointer dsapagetable;	/* dsa_pointer to the element array */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/tidbitmap.c:	dsa_pointer dsapagetableold;	/* dsa_pointer to the old element array */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/tidbitmap.c:	dsa_pointer ptpages;		/* dsa_pointer to the page array */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/tidbitmap.c:	dsa_pointer ptchunks;		/* dsa_pointer to the chunk array */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/tidbitmap.c:	dsa_pointer spages;			/* dsa pointer to page array */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/tidbitmap.c:	dsa_pointer schunks;		/* dsa pointer to chunk array */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/tidbitmap.c: * pagetable iteration array.
/srvr/z5089358/postgresql-10.4/src/backend/nodes/tidbitmap.c:	int			index[FLEXIBLE_ARRAY_MEMBER];	/* index array */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/tidbitmap.c:	PTEntryArray *ptbase;		/* pagetable element array */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/tidbitmap.c:	 * for our purpose.  Also count an extra Pointer per entry for the arrays
/srvr/z5089358/postgresql-10.4/src/backend/nodes/tidbitmap.c: * Free shared iterator state, Also free shared pagetable and iterator arrays
/srvr/z5089358/postgresql-10.4/src/backend/nodes/tidbitmap.c:		/* safety check to ensure we don't overrun bit array bounds */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/tidbitmap.c: * This will convert the pagetable hash into page and chunk array of the index
/srvr/z5089358/postgresql-10.4/src/backend/nodes/tidbitmap.c: * into pagetable array.
/srvr/z5089358/postgresql-10.4/src/backend/nodes/tidbitmap.c:		 * Allocate the page and chunk array memory from the DSA to share
/srvr/z5089358/postgresql-10.4/src/backend/nodes/tidbitmap.c:		 * convert it to page and chunk arrays.  But if it's in the
/srvr/z5089358/postgresql-10.4/src/backend/nodes/tidbitmap.c:			 * page array.
/srvr/z5089358/postgresql-10.4/src/backend/nodes/tidbitmap.c:	 * For every shared iterator, referring to pagetable and iterator array,
/srvr/z5089358/postgresql-10.4/src/backend/nodes/tidbitmap.c:	 * don't free pagetable and iterator array until its refcount becomes 0.
/srvr/z5089358/postgresql-10.4/src/backend/nodes/tidbitmap.c:		/* In ONE_PAGE state, we don't allocate an spages[] array */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/tidbitmap.c: * As above, but this will get index into PagetableEntry array.  Therefore,
Binary file /srvr/z5089358/postgresql-10.4/src/backend/nodes/outfuncs.o matches
/srvr/z5089358/postgresql-10.4/src/backend/nodes/copyfuncs.c:	COPY_SCALAR_FIELD(refarraytype);
/srvr/z5089358/postgresql-10.4/src/backend/nodes/copyfuncs.c:	COPY_SCALAR_FIELD(array_typeid);
/srvr/z5089358/postgresql-10.4/src/backend/nodes/copyfuncs.c:	COPY_SCALAR_FIELD(array_collid);
/srvr/z5089358/postgresql-10.4/src/backend/nodes/copyfuncs.c:	COPY_NODE_FIELD(arrayBounds);
/srvr/z5089358/postgresql-10.4/src/backend/nodes/readfuncs.c:/* Read an attribute number array */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/readfuncs.c:/* Read an oid array */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/readfuncs.c:/* Read an int array */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/readfuncs.c:/* Read a bool array */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/readfuncs.c:	READ_OID_FIELD(refarraytype);
/srvr/z5089358/postgresql-10.4/src/backend/nodes/readfuncs.c:	READ_OID_FIELD(array_typeid);
/srvr/z5089358/postgresql-10.4/src/backend/nodes/readfuncs.c:	READ_OID_FIELD(array_collid);
/srvr/z5089358/postgresql-10.4/src/backend/nodes/outfuncs.c:	WRITE_OID_FIELD(refarraytype);
/srvr/z5089358/postgresql-10.4/src/backend/nodes/outfuncs.c:	WRITE_OID_FIELD(array_typeid);
/srvr/z5089358/postgresql-10.4/src/backend/nodes/outfuncs.c:	WRITE_OID_FIELD(array_collid);
/srvr/z5089358/postgresql-10.4/src/backend/nodes/outfuncs.c:	/* array fields aren't really worth the trouble to print */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/outfuncs.c:	WRITE_NODE_FIELD(arrayBounds);
/srvr/z5089358/postgresql-10.4/src/backend/nodes/equalfuncs.c:	COMPARE_SCALAR_FIELD(refarraytype);
/srvr/z5089358/postgresql-10.4/src/backend/nodes/equalfuncs.c:	COMPARE_SCALAR_FIELD(array_typeid);
/srvr/z5089358/postgresql-10.4/src/backend/nodes/equalfuncs.c:	COMPARE_SCALAR_FIELD(array_collid);
/srvr/z5089358/postgresql-10.4/src/backend/nodes/equalfuncs.c:	COMPARE_NODE_FIELD(arrayBounds);
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:				const ArrayRef *arrayref = (const ArrayRef *) expr;
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:				/* slice and/or store operations yield the array type */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:				if (arrayref->reflowerindexpr || arrayref->refassgnexpr)
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:					type = arrayref->refarraytype;
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:					type = arrayref->refelemtype;
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:						type = get_promoted_array_type(type);
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:									 errmsg("could not find array type for data type %s",
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:						type = get_promoted_array_type(type);
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:									 errmsg("could not find array type for data type %s",
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:			type = ((const ArrayExpr *) expr)->array_typeid;
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:			/* typmod is the same for array or element */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:					/* note we don't need to care if it's an array */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:					/* note we don't need to care if it's an array */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:				const ArrayExpr *arrayexpr = (const ArrayExpr *) expr;
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:				if (arrayexpr->elements == NIL)
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:				typmod = exprTypmod((Node *) linitial(arrayexpr->elements));
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:				if (arrayexpr->multidims)
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:					commontype = arrayexpr->array_typeid;
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:					commontype = arrayexpr->element_typeid;
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:				foreach(elem, arrayexpr->elements)
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:	 * Scalar-type length coercions are FuncExprs, array-type length coercions
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:					/* collation doesn't change if it's converted to array */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:					/* collation doesn't change if it's converted to array */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:			coll = ((const ArrayExpr *) expr)->array_collid;
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:			((ArrayExpr *) expr)->array_collid = collation;
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:			/* just use array argument's location */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:				/* recurse directly for upper/lower array index lists */
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:				ArrayRef   *arrayref = (ArrayRef *) node;
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:				FLATCOPY(newnode, arrayref, ArrayRef);
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:				MUTATE(newnode->refupperindexpr, arrayref->refupperindexpr,
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:				MUTATE(newnode->reflowerindexpr, arrayref->reflowerindexpr,
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:				MUTATE(newnode->refexpr, arrayref->refexpr,
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:				MUTATE(newnode->refassgnexpr, arrayref->refassgnexpr,
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:				ArrayExpr  *arrayexpr = (ArrayExpr *) node;
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:				FLATCOPY(newnode, arrayexpr, ArrayExpr);
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:				MUTATE(newnode->elements, arrayexpr->elements, List *);
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c:				if (walker(tn->arrayBounds, context))
/srvr/z5089358/postgresql-10.4/src/backend/nodes/nodeFuncs.c: * we need the list in order to determine the length of the PlanState array.
/srvr/z5089358/postgresql-10.4/src/backend/port/sysv_sema.c:	unsigned short *array;
/srvr/z5089358/postgresql-10.4/src/backend/port/sysv_sema.c:static PGSemaphore sharedSemas; /* array of PGSemaphoreData in shared memory */
/srvr/z5089358/postgresql-10.4/src/backend/port/sysv_sema.c:static int	maxSharedSemas;		/* allocated size of PGSemaphoreData array */
/srvr/z5089358/postgresql-10.4/src/backend/port/sysv_sema.c:static int	maxSemaSets;		/* allocated size of mySemaSets array */
/srvr/z5089358/postgresql-10.4/src/backend/port/sysv_sema.c: * maxSemas parameter is just used to size the arrays.  There is an array
/srvr/z5089358/postgresql-10.4/src/backend/port/sysv_sema.c: * of PGSemaphoreData structs in shared memory, and a postmaster-local array
/srvr/z5089358/postgresql-10.4/src/backend/port/win32_sema.c:static int	maxSems;			/* allocated size of mySemaSet array */
/srvr/z5089358/postgresql-10.4/src/backend/port/win32_sema.c: * maxSemas parameter is just used to size the array that keeps track of
/srvr/z5089358/postgresql-10.4/src/backend/port/win32/socket.c:			r = WSASend(writefds->fd_array[i], &buf, 1, &sent, 0, NULL, NULL);
/srvr/z5089358/postgresql-10.4/src/backend/port/win32/socket.c:				FD_SET(writefds->fd_array[i], &outwritefds);
/srvr/z5089358/postgresql-10.4/src/backend/port/win32/socket.c:			sockets[numevents] = readfds->fd_array[i];
/srvr/z5089358/postgresql-10.4/src/backend/port/win32/socket.c:				!FD_ISSET(writefds->fd_array[i], readfds))
/srvr/z5089358/postgresql-10.4/src/backend/port/win32/socket.c:				sockets[numevents] = writefds->fd_array[i];
/srvr/z5089358/postgresql-10.4/src/backend/port/win32/signal.c:/* Note that array elements 0 are unused since they correspond to signal 0 */
/srvr/z5089358/postgresql-10.4/src/backend/port/win32/signal.c:static pqsigfunc pg_signal_array[PG_SIGNAL_COUNT];
/srvr/z5089358/postgresql-10.4/src/backend/port/win32/signal.c:		pg_signal_array[i] = SIG_DFL;
/srvr/z5089358/postgresql-10.4/src/backend/port/win32/signal.c:				pqsigfunc	sig = pg_signal_array[i];
/srvr/z5089358/postgresql-10.4/src/backend/port/win32/signal.c:	prevfunc = pg_signal_array[signum];
/srvr/z5089358/postgresql-10.4/src/backend/port/win32/signal.c:	pg_signal_array[signum] = handler;
/srvr/z5089358/postgresql-10.4/src/backend/port/posix_sema.c: * With unnamed semaphores, the sem_t structs live in an array in shared
/srvr/z5089358/postgresql-10.4/src/backend/port/posix_sema.c:static PGSemaphore sharedSemas; /* array of PGSemaphoreData in shared memory */
/srvr/z5089358/postgresql-10.4/src/backend/port/posix_sema.c:static int	maxSems;			/* allocated size of above arrays */
/srvr/z5089358/postgresql-10.4/src/backend/port/posix_sema.c: * maxSemas parameter is just used to size the arrays.  For unnamed
/srvr/z5089358/postgresql-10.4/src/backend/port/posix_sema.c: * semaphores, there is an array of PGSemaphoreData structs in shared memory.
/srvr/z5089358/postgresql-10.4/src/backend/port/posix_sema.c: * For named semaphores, we keep a postmaster-local array of sem_t pointers,
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_collate.c:				/* collation doesn't change if it's converted to array */
Binary file /srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.o matches
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_utilcmd.c:		 * typeid, LookupTypeName won't notice arrayBounds.  We don't need any
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_utilcmd.c:		if (is_serial && column->typeName->arrayBounds != NIL)
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_utilcmd.c:					 errmsg("array of serial is not implemented"),
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_utilcmd.c:				deconstruct_array(DatumGetArrayTypeP(datum),
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_utilcmd.c:		elog(ERROR, "stxkind is not a 1-D char array");
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_func.c:	 * against array overruns, etc.  Of course, this may not be a function,
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_func.c:	 * into an array --- unless it's an "any" variadic.
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_func.c:		newa->array_typeid = get_array_type(newa->element_typeid);
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_func.c:		if (!OidIsValid(newa->array_typeid))
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_func.c:					 errmsg("could not find array type for data type %s",
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_func.c:		/* array_collid will be set by parse_collate.c */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_func.c:	 * that the variadic parameter be of some array type.
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_func.c:					 errmsg("VARIADIC argument must be an array"),
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_func.c: * of arguments) and an array of input datatype OIDs, produce a shortlist of
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_func.c: *		Given the input argtype array and more than one candidate
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_func.c:	/* protect local fixed-size arrays */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_func.c:	/* Deconstruct fargs into an array for ease of subscripting */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_func.c:	/* Reconstruct fargs from array */
/srvr/z5089358/postgresql-10.4/src/backend/parser/analyze.c: * symbol datatypes from context.  The passed-in paramTypes[] array can
/srvr/z5089358/postgresql-10.4/src/backend/parser/analyze.c:			 * off the resulting field/array assignment nodes, since we don't
/srvr/z5089358/postgresql-10.4/src/backend/parser/analyze.c: * strip_indirection: if true, remove any field/array assignment nodes
/srvr/z5089358/postgresql-10.4/src/backend/parser/analyze.c:			/* and allocate array for per-column lists */
Binary file /srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.o matches
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:static bool is_complex_array(Oid typid);
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		 * the argument must be an actual array, enum, or range type.  In
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		 * is, we just fall through; below, we'll call anyarray_in,
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		 * what we have is a domain over array, enum, or range, we have to
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		is_complex_array(targetTypeId))
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		/* Coerce record[] to a specific complex array type */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		is_complex_array(inputTypeId))
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		/* Coerce a specific complex array type to record[] */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		 * If input is record[] and target is a composite array type, assume
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			is_complex_array(targetTypeId))
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		 * If input is a composite array type and target is record[], accept
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			is_complex_array(inputTypeId))
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c: *	  which must be a varlena array type.
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c: *	  we add the extra condition that the ANYELEMENT type must not be an array.
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c: * Domains over arrays match ANYARRAY, and are immediately flattened to their
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c: * If an input is of type ANYARRAY (ie, we know it's an array, but not
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:	Oid			array_typeid = InvalidOid;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:	Oid			array_typelem;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:	bool		have_anynonarray = false;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:				have_anynonarray = true;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			if (OidIsValid(array_typeid) && actual_type != array_typeid)
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			array_typeid = actual_type;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:	/* Get the element type based on the array type, if we have one */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:	if (OidIsValid(array_typeid))
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		if (array_typeid == ANYARRAYOID)
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		array_typelem = get_element_type(array_typeid);
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		if (!OidIsValid(array_typelem))
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			return false;		/* should be an array, but isn't */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			elem_typeid = array_typelem;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		else if (array_typelem != elem_typeid)
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:	if (have_anynonarray)
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		/* require the element type to not be an array or domain over array */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		if (type_is_array_domain(elem_typeid))
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c: *	  function's return type, i.e. the element type's corresponding array
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c: *	  the function's return type, i.e. the array type's corresponding element
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c: *	  we add the extra condition that the ANYELEMENT type must not be an array.
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c: * Domains over arrays or ranges match ANYARRAY or ANYRANGE arguments,
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c: * columns shown as anyarray in the catalogs).  We allow this to match a
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:	Oid			array_typeid = InvalidOid;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:	Oid			array_typelem;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:	bool		have_anynonarray = (rettype == ANYNONARRAYOID);
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:				have_anynonarray = true;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			if (OidIsValid(array_typeid) && actual_type != array_typeid)
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:						 errmsg("arguments declared \"anyarray\" are not all alike"),
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:								   format_type_be(array_typeid),
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			array_typeid = actual_type;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:	/* Get the element type based on the array type, if we have one */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:	if (OidIsValid(array_typeid))
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		if (array_typeid == ANYARRAYOID && !have_anyelement)
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			array_typelem = ANYELEMENTOID;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			array_typelem = get_element_type(array_typeid);
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			if (!OidIsValid(array_typelem))
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:						 errmsg("argument declared %s is not an array but type %s",
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:								"anyarray", format_type_be(array_typeid))));
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			elem_typeid = array_typelem;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		else if (array_typelem != elem_typeid)
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:							"anyarray", "anyelement"),
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:							   format_type_be(array_typeid),
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			array_typeid = ANYARRAYOID;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:	if (have_anynonarray && elem_typeid != ANYELEMENTOID)
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		/* require the element type to not be an array or domain over array */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		if (type_is_array_domain(elem_typeid))
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:					 errmsg("type matched to anynonarray is an array type: %s",
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:				if (!OidIsValid(array_typeid))
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:					array_typeid = get_array_type(elem_typeid);
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:					if (!OidIsValid(array_typeid))
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:								 errmsg("could not find array type for data type %s",
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:				declared_arg_types[j] = array_typeid;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		if (!OidIsValid(array_typeid))
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			array_typeid = get_array_type(elem_typeid);
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			if (!OidIsValid(array_typeid))
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:						 errmsg("could not find array type for data type %s",
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		return array_typeid;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			 * Use actual type, but it must be an array; or if it's a domain
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			 * over array, use the base array type.
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			Oid			array_typelem = get_element_type(context_base_type);
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			if (!OidIsValid(array_typelem))
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:						 errmsg("argument declared %s is not an array but type %s",
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:								"anyarray", format_type_be(context_base_type))));
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			/* Use the array type corresponding to actual type */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			Oid			array_typeid = get_array_type(context_actual_type);
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			if (!OidIsValid(array_typeid))
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:						 errmsg("could not find array type for data type %s",
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			return array_typeid;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			Oid			array_typelem = get_element_type(context_base_type);
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			if (!OidIsValid(array_typelem))
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:						 errmsg("argument declared %s is not an array but type %s",
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:								"anyarray", format_type_be(context_base_type))));
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			return array_typelem;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:			/* Use the actual type; it doesn't matter if array or not */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:	/* Also accept any array type as coercible to ANYARRAY */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		if (type_is_array(srctype))
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:	/* Also accept any non-array type as coercible to ANYNONARRAY */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		if (!type_is_array(srctype))
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:	/* Also accept any composite array type as coercible to RECORD[] */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		if (is_complex_array(srctype))
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c: *				if the array elements are binary-compatible
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		 * array types.  If so, and if the element types have a suitable cast,
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		 * Note that the source type can be a domain over array, but not the
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		 * otherwise tend to capture coercions that should go to "real" array
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:		 * types.  We want those types to be considered "real" arrays for many
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c: * If the given type is a varlena array type, we do not look for a coercion
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c: * function associated directly with the array type, but instead look for
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:	/* Check for a varlena array type */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c: * is_complex_array
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c: *		Is this type an array of composite?
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.c:is_complex_array(Oid typid)
Binary file /srvr/z5089358/postgresql-10.4/src/backend/parser/parse_type.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/parser/parse_target.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/parser/parse_utilcmd.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/parser/parse_coerce.o matches
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:				   Oid array_type, Oid element_type, int32 typmod);
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:	return (Node *) make_scalar_array_op(pstate,
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:	return (Node *) make_scalar_array_op(pstate,
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:	 * possible if there is a suitable array type available.  If not, we fall
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:		Oid			array_type;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:		 * Try to select a common type for the array elements.  Note that
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:		 * Do we have an array type to use?  Aside from the case where there
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:			array_type = get_array_type(scalar_type);
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:			array_type = InvalidOid;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:		if (array_type != InvalidOid)
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:			newa->array_typeid = array_type;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:			/* array_collid will be set by parse_collate.c */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:			result = (Node *) make_scalar_array_op(pstate,
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c: * If the caller specifies the target type, the resulting array will
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:				   Oid array_type, Oid element_type, int32 typmod)
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:	 * Assume that the array is one-dimensional unless we find an array-type
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:									  array_type,
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:			/* we certainly have an array here */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:			Assert(array_type == InvalidOid || array_type == exprType(newe));
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:			 * Check for sub-array expressions, if we haven't already found
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:			if (!newa->multidims && type_is_array(exprType(newe)))
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:	 * If we haven't been given a target array type, we must try to deduce a
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:	if (OidIsValid(array_type))
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:		/* Caller must ensure array_type matches element_type */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:		coerce_type = (newa->multidims ? array_type : element_type);
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:		/* Can't handle an empty array without a target type */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:					 errmsg("cannot determine type of empty array"),
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:			array_type = coerce_type;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:			element_type = get_element_type(array_type);
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:								format_type_be(array_type)),
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:			array_type = get_array_type(element_type);
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:			if (!OidIsValid(array_type))
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:						 errmsg("could not find array type for data type %s",
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:	 * If the array has been explicitly cast, then the elements are in turn
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:	 * If the array's type was merely derived from the common type of its
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:	newa->array_typeid = array_type;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:	/* array_collid will be set by parse_collate.c */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:	 * type is an array type, we invoke transformArrayExpr() directly so that
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:		 * If target is a domain over array, work with the base array type
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_expr.c:		 * here.  Below, we'll cast the array type to the domain.  In the
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_oper.c: *		Given the input argtype array and one or more candidates
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_oper.c: * make_scalar_array_op()
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_oper.c: *		Build expression tree for "scalar op ANY/ALL (array)" construct.
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_oper.c:make_scalar_array_op(ParseState *pstate, List *opname,
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_oper.c:	 * array.  However, if we currently have just an untyped literal on the
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_oper.c:					 errmsg("op ANY/ALL (array) requires array on right side"),
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_oper.c:				 errmsg("op ANY/ALL (array) requires operator to yield boolean"),
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_oper.c:				 errmsg("op ANY/ALL (array) requires operator not to return a set"),
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_oper.c:	 * Now switch back to the array type on the right, arranging for any
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_oper.c:		/* assume the actual array type is OK */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_oper.c:		res_atypeId = get_array_type(declared_arg_types[1]);
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_oper.c:					 errmsg("could not find array type for data type %s",
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_oper.c:		if (fetch_search_path_array(key->search_path,
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_cte.c: * (i.e., self-referential).  It is convenient to do this with an array
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_cte.c:	CteItem    *items;			/* array of CTEs and extra data */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_cte.c:		 * eliminate forward references.  First, build a work array and set up
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_target.c:	 * reject trying to update a subfield or array element with DEFAULT, since
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_target.c:						 errmsg("cannot set an array element to DEFAULT"),
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_target.c:	 * If there is indirection on the target column, prepare an array or
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_target.c:					 errmsg("array assignment to \"%s\" requires type %s"
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_target.c: * helper for transformAssignmentIndirection: process array assignment
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_target.c:	Oid			arrayType;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_target.c:	int32		arrayTypMod;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_target.c:	/* Identify the actual array type and element type involved */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_target.c:	arrayType = targetTypeId;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_target.c:	arrayTypMod = targetTypMod;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_target.c:	elementTypeId = transformArrayType(&arrayType, &arrayTypMod);
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_target.c:	typeNeeded = isSlice ? arrayType : elementTypeId;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_target.c:	 * exception: we might be subscripting a domain over an array type. In
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_target.c:	if (arrayType == targetTypeId)
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_target.c:		collationNeeded = get_typcollation(arrayType);
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_target.c:	/* recurse to create appropriate RHS for array assign */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_target.c:										 arrayTypMod,
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_target.c:											   arrayType,
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_target.c:											   arrayTypMod,
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_target.c:	/* If target was a domain over array, need to coerce up to the domain */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_target.c:	if (arrayType != targetTypeId)
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_target.c:					*name = "array";
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_target.c:			*name = "array";
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_param.c:	Oid		   *paramTypes;		/* array of parameter type OIDs */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_param.c:	int			numParams;		/* number of array entries */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_param.c: * In the varparams case, the caller-supplied OID array (if any) can be
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_param.c: * re-palloc'd larger at need.  A zero array entry means that parameter number
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_param.c:	Oid		  **paramTypes;		/* array of parameter type OIDs */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_param.c:	int		   *numParams;		/* number of array entries */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_param.c: * The only difference here is we must enlarge the parameter type array
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_param.c:		/* Need to enlarge param array */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_param.c:	/* Locate param's slot in array */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c: * On entry, arrayType/arrayTypmod identify the type of the input value
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c: * if necessary to identify the actual array type and typmod, and the
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c: * array's element type is returned.  An error is thrown if the input isn't
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c: * an array type.
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:transformArrayType(Oid *arrayType, int32 *arrayTypmod)
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:	Oid			origArrayType = *arrayType;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:	HeapTuple	type_tuple_array;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:	Form_pg_type type_struct_array;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:	 * operation that necessarily works on the base array type, not the domain
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:	 * domain over an array type could hide its ability to be subscripted.)
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:	*arrayType = getBaseTypeAndTypmod(*arrayType, arrayTypmod);
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:	 * int2[] and oid[].  This is needed because array slicing could create an
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:	 * array that doesn't satisfy the dimensionality constraints of the
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:	if (*arrayType == INT2VECTOROID)
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:		*arrayType = INT2ARRAYOID;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:	else if (*arrayType == OIDVECTOROID)
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:		*arrayType = OIDARRAYOID;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:	/* Get the type tuple for the array */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:	type_tuple_array = SearchSysCache1(TYPEOID, ObjectIdGetDatum(*arrayType));
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:	if (!HeapTupleIsValid(type_tuple_array))
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:		elog(ERROR, "cache lookup failed for type %u", *arrayType);
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:	type_struct_array = (Form_pg_type) GETSTRUCT(type_tuple_array);
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:	elementType = type_struct_array->typelem;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:				 errmsg("cannot subscript type %s because it is not an array",
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:	ReleaseSysCache(type_tuple_array);
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c: *		Transform array subscripting.  This is used for both
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c: *		array fetch and array assignment.
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c: * In an array fetch, we are given a source array value and we produce an
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c: * expression that represents the result of extracting a single array element
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c: * or an array slice.
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c: * In an array assignment, we are given a destination array value plus a
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c: * that array.  We produce an expression that represents the new array value
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c: * with the source data inserted into the right part of the array.
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c: * For both cases, if the source array is of a domain-over-array type,
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c: * the result is of the base array type or its element type; essentially,
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c: * arrayBase	Already-transformed expression for the array as a whole
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c: * arrayType	OID of array's datatype (should match type of arrayBase,
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c: *				or be the base type of arrayBase's domain type)
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c: * elementType	OID of array's element type (fetch with transformArrayType,
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c: * arrayTypMod	typmod for the array (which is also typmod for the elements)
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c: * assignFrom	NULL for array fetch, else transformed expression for source.
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:						 Node *arrayBase,
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:						 Oid arrayType,
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:						 int32 arrayTypMod,
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:	 * that if the caller did do so, arrayType/arrayTypMod must be as modified
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:		elementType = transformArrayType(&arrayType, &arrayTypMod);
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:	 * A list containing only simple subscripts refers to a single array
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:	 * the subscript expression means an array slice operation.  In this case,
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:							 errmsg("array subscript must have type integer"),
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:						 errmsg("array subscript must have type integer"),
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:	 * If doing an array store, coerce the source value to the right type.
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:		Oid			typeneeded = isSlice ? arrayType : elementType;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:										typeneeded, arrayTypMod,
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:					 errmsg("array assignment requires type %s"
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:	aref->refarraytype = arrayType;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:	aref->reftypmod = arrayTypMod;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_node.c:	aref->refexpr = (Expr *) arrayBase;
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_type.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_type.c:			/* this construct should never have an array indicator */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_type.c:			Assert(typeName->arrayBounds == NIL);
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_type.c:		/* If an array reference, return the array type instead */
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_type.c:		if (typeName->arrayBounds != NIL)
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_type.c:			typoid = get_array_type(typoid);
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_type.c:	 * Convert the list of raw-grammar-output expressions to a cstring array.
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_type.c:	arrtypmod = construct_array(datums, n, CSTRINGOID,
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_type.c:	if (typeName->arrayBounds != NIL)
/srvr/z5089358/postgresql-10.4/src/backend/parser/scan.c: * integer for use as an array index.  If the signed char is negative,
/srvr/z5089358/postgresql-10.4/src/backend/parser/scan.c:    YY_BUFFER_STATE * yy_buffer_stack; /**< Stack as an array. */
/srvr/z5089358/postgresql-10.4/src/backend/parser/scan.c:		/* Extend the array by 50%, plus the number we really need. */
Binary file /srvr/z5089358/postgresql-10.4/src/backend/parser/parse_func.o matches
/srvr/z5089358/postgresql-10.4/src/backend/parser/parse_agg.c: * Datatypes are returned into inputTypes[], which must reference an array
Binary file /srvr/z5089358/postgresql-10.4/src/backend/parser/parse_oper.o matches
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.y:				name_list role_list from_clause from_list opt_array_bounds
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.y:				columnref in_expr having_clause func_table xmltable array_expr
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.y:%type <list>	row explicit_row implicit_row type_list array_expr_list
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.y:Typename:	SimpleTypename opt_array_bounds
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.y:					$$->arrayBounds = $2;
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.y:			| SETOF SimpleTypename opt_array_bounds
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.y:					$$->arrayBounds = $3;
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.y:					$$->arrayBounds = list_make1(makeInteger($4));
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.y:					$$->arrayBounds = list_make1(makeInteger($5));
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.y:					$$->arrayBounds = list_make1(makeInteger(-1));
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.y:					$$->arrayBounds = list_make1(makeInteger(-1));
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.y:opt_array_bounds:
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.y:			opt_array_bounds '[' ']'
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.y:			| opt_array_bounds '[' Iconst ']'
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.y:			| ARRAY array_expr
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.y:array_expr: '[' expr_list ']'
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.y:			| '[' array_expr_list ']'
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.y:array_expr_list: array_expr							{ $$ = list_make1($1); }
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.y:			| array_expr_list ',' array_expr		{ $$ = lappend($1, $3); }
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.c:/* The size of an array large to enough to hold all stacks, each with
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.c:  "xml_namespace_list", "xml_namespace_el", "Typename", "opt_array_bounds",
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.c:  "func_arg_list", "func_arg_expr", "type_list", "array_expr",
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.c:  "array_expr_list", "extract_list", "extract_arg", "overlay_list",
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.c:					(yyval.typnam)->arrayBounds = (yyvsp[0].list);
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.c:					(yyval.typnam)->arrayBounds = (yyvsp[0].list);
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.c:					(yyval.typnam)->arrayBounds = list_make1(makeInteger((yyvsp[-1].ival)));
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.c:					(yyval.typnam)->arrayBounds = list_make1(makeInteger((yyvsp[-1].ival)));
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.c:					(yyval.typnam)->arrayBounds = list_make1(makeInteger(-1));
/srvr/z5089358/postgresql-10.4/src/backend/parser/gram.c:					(yyval.typnam)->arrayBounds = list_make1(makeInteger(-1));
/srvr/z5089358/postgresql-10.4/src/backend/access/index/indexam.c: * To restart the scan without changing keys, pass NULL for the key arrays.
/srvr/z5089358/postgresql-10.4/src/backend/access/index/genam.c: * The passed-in values/nulls arrays are the "raw" input to the index AM,
Binary file /srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.o matches
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtpage.c: * Also, the given itemnos *must* appear in increasing order in the array.
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtpage.c:		 * The target-offsets array is not in the buffer, but pretend that it
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtpage.c:		 * is.  When XLogInsert stores the whole buffer, the offsets array
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtpage.c: * Also, the given itemnos *must* appear in increasing order in the array.
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtpage.c:		 * We need the target-offsets array whether or not we store the whole
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtsort.c: * slide an array of ItemIds back one slot (from P_FIRSTKEY to
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtsort.c: * that we have built an ItemId array in what has turned out to be a
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtsort.c: * page, we leave the items alone and slide the linp array over.
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtsort.c:		 * This is the rightmost page, so the ItemId array needs to be slid
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtsearch.c:	 * storing their addresses into the local startKeys[] array.
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtsearch.c:	 * scankeys[] array, using the keys identified by startKeys[].
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/README:insertion scankey uses the same array-of-ScanKey data structure, but the
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/README:The Postgres disk block data format (an array of items) doesn't fit
Binary file /srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.o matches
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c: * We reach this state once for every distinct combination of array keys.
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	int			btps_arrayKeyCount; /* count indicating number of array scan
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	amroutine->amsearcharray = true;
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	 * If we have any array keys, initialize them during first call for a
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:		/* punt if we have any unsatisfiable array keys */
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:		_bt_start_array_keys(scan, dir);
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	/* This loop handles advancing to the next array elements, if any */
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:		/* ... otherwise see if we have more array keys to deal with */
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	} while (so->numArrayKeys && _bt_advance_array_keys(scan, dir));
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	 * If we have any array keys, initialize them.
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:		/* punt if we have any unsatisfiable array keys */
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:		_bt_start_array_keys(scan, ForwardScanDirection);
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	/* This loop handles advancing to the next array elements, if any */
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:		/* Now see if we have more array keys to deal with */
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	} while (so->numArrayKeys && _bt_advance_array_keys(scan, ForwardScanDirection));
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	so->arrayKeyData = NULL;	/* assume no array keys for now */
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	so->arrayKeys = NULL;
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	so->arrayContext = NULL;
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	 * allocate the tuple workspace arrays until btrescan.  However, we set up
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	so->arrayKeyCount = 0;
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	 * Allocate tuple workspace arrays, if needed for an index-only scan and
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	 * currTuples array, a fetch of NAMEDATALEN bytes can at worst pull some
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	 * data out of the markTuples array --- running off the end of memory for
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	/* If any keys are SK_SEARCHARRAY type, set up array-key info */
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	_bt_preprocess_array_keys(scan);
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	/* so->arrayKeyData and so->arrayKeys are in arrayContext */
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	if (so->arrayContext != NULL)
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:		MemoryContextDelete(so->arrayContext);
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	/* Also record the current positions of any array keys */
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:		_bt_mark_array_keys(scan);
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	/* Restore the marked positions of any array keys */
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:		_bt_restore_array_keys(scan);
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	bt_target->btps_arrayKeyCount = 0;
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	btscan->btps_arrayKeyCount = 0;
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:		if (so->arrayKeyCount < btscan->btps_arrayKeyCount)
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	 * _bt_advance_array_keys.
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	if (so->arrayKeyCount >= btscan->btps_arrayKeyCount &&
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c: * _bt_parallel_advance_array_keys() -- Advances the parallel scan for array
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c: * Updates the count of array keys processed for both local and parallel
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:_bt_parallel_advance_array_keys(IndexScanDesc scan)
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	so->arrayKeyCount++;
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:		btscan->btps_arrayKeyCount++;
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtree.c:	 * space per recursion level (due to the deletable[] array). A failure is
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:static int _bt_sort_array_elements(IndexScanDesc scan, ScanKey skey,
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:static int	_bt_compare_array_elements(const void *a, const void *b, void *arg);
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c: *	_bt_preprocess_array_keys() -- Preprocess SK_SEARCHARRAY scan keys
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c: * If there are any SK_SEARCHARRAY scan keys, deconstruct the array(s) and
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c: * Prepare modified scan keys in so->arrayKeyData, which will hold the current
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c: * array elements during each primitive indexscan operation.  For inequality
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c: * array keys, it's sufficient to find the extreme element value and replace
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c: * the whole array with that scalar value.
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c: * Note: the reason we need so->arrayKeyData, rather than just scribbling
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:_bt_preprocess_array_keys(IndexScanDesc scan)
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:	/* Quick check to see if there are any array keys */
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:			/* If any arrays are null as a whole, we can quit right now. */
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:				so->arrayKeyData = NULL;
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		so->arrayKeyData = NULL;
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:	 * Make a scan-lifespan context to hold array-associated data, or reset it
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:	if (so->arrayContext == NULL)
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		so->arrayContext = AllocSetContextCreate(CurrentMemoryContext,
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:												 "BTree array context",
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		MemoryContextReset(so->arrayContext);
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:	oldContext = MemoryContextSwitchTo(so->arrayContext);
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:	so->arrayKeyData = (ScanKey) palloc(scan->numberOfKeys * sizeof(ScanKeyData));
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:	memcpy(so->arrayKeyData,
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:	/* Allocate space for per-array data in the workspace context */
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:	so->arrayKeys = (BTArrayKeyInfo *) palloc0(numArrayKeys * sizeof(BTArrayKeyInfo));
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:	/* Now process each array key */
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		ArrayType  *arrayval;
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		cur = &so->arrayKeyData[i];
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		 * First, deconstruct the array into elements.  Anything allocated
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		 * here (including a possibly detoasted array value) is in the
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		arrayval = DatumGetArrayTypeP(cur->sk_argument);
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		get_typlenbyvalalign(ARR_ELEMTYPE(arrayval),
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		deconstruct_array(arrayval,
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:						  ARR_ELEMTYPE(arrayval),
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		 * If the comparison operator is not equality, then the array qual
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		 * non-null array element, as appropriate.
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		num_elems = _bt_sort_array_elements(scan, cur,
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		so->arrayKeys[numArrayKeys].scan_key = i;
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		so->arrayKeys[numArrayKeys].num_elems = num_elems;
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		so->arrayKeys[numArrayKeys].elem_values = elem_values;
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c: * _bt_find_extreme_element() -- get least or greatest array element
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:	 * Determine the nominal datatype of the array elements.  We have to
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c: * _bt_sort_array_elements() -- sort and de-dup array elements
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c: * The array elements are sorted in-place, and the new number of elements
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:_bt_sort_array_elements(IndexScanDesc scan, ScanKey skey,
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:	 * Determine the nominal datatype of the array elements.  We have to
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:	/* Sort the array elements */
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:			  _bt_compare_array_elements, (void *) &cxt);
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c: * qsort_arg comparator for sorting array elements
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:_bt_compare_array_elements(const void *a, const void *b, void *arg)
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c: * _bt_start_array_keys() -- Initialize array keys at start of a scan
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c: * each array scankey.  We can't do this until we know the scan direction.
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:_bt_start_array_keys(IndexScanDesc scan, ScanDirection dir)
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		BTArrayKeyInfo *curArrayKey = &so->arrayKeys[i];
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		ScanKey		skey = &so->arrayKeyData[curArrayKey->scan_key];
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c: * _bt_advance_array_keys() -- Advance to next set of array elements
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:_bt_advance_array_keys(IndexScanDesc scan, ScanDirection dir)
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:	 * We must advance the last array key most quickly, since it will
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:	 * when there are multiple array keys.
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		BTArrayKeyInfo *curArrayKey = &so->arrayKeys[i];
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		ScanKey		skey = &so->arrayKeyData[curArrayKey->scan_key];
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:				found = false;	/* need to advance next array key */
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:				found = false;	/* need to advance next array key */
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		_bt_parallel_advance_array_keys(scan);
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c: * _bt_mark_array_keys() -- Handle array keys during btmarkpos
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c: * Save the current state of the array keys as the "mark" position.
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:_bt_mark_array_keys(IndexScanDesc scan)
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		BTArrayKeyInfo *curArrayKey = &so->arrayKeys[i];
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c: * _bt_restore_array_keys() -- Handle array keys during btrestrpos
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c: * Restore the array keys to where they were when the mark was set.
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:_bt_restore_array_keys(IndexScanDesc scan)
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:	/* Restore each array key to its position when the mark was set */
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		BTArrayKeyInfo *curArrayKey = &so->arrayKeys[i];
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		ScanKey		skey = &so->arrayKeyData[curArrayKey->scan_key];
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c: * The given search-type keys (in scan->keyData[] or so->arrayKeyData[])
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c: * operator strategy, the second one is just pushed into the output array
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c: * (In this case we do not bother completing the output key array!)
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c: * we just transfer them into the preprocessed array without any
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c: * storage is that we are modifying the array based on comparisons of the
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c: * new elements of array keys.  Therefore we can't overwrite the source data.
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:	 * Read so->arrayKeyData if array keys are present, else scan->keyData
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:	if (so->arrayKeyData != NULL)
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		inkeys = so->arrayKeyData;
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:			 * Emit the cleaned-up keys into the outkeys[] array, and then
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:		/* if row comparison, push it directly to the output array */
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:				 * output array.
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:	int			max_vacuums;	/* allocated length of vacuums[] array */
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c: * _bt_end_vacuum, else we'll permanently leak an array slot.  To ensure
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtutils.c:	/* Find the array entry */
/srvr/z5089358/postgresql-10.4/src/backend/access/nbtree/nbtxlog.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/access/objfiles.txt:src/backend/access/gin/ginutil.o src/backend/access/gin/gininsert.o src/backend/access/gin/ginxlog.o src/backend/access/gin/ginentrypage.o src/backend/access/gin/gindatapage.o src/backend/access/gin/ginbtree.o src/backend/access/gin/ginscan.o src/backend/access/gin/ginget.o src/backend/access/gin/ginvacuum.o src/backend/access/gin/ginarrayproc.o src/backend/access/gin/ginbulk.o src/backend/access/gin/ginfast.o src/backend/access/gin/ginpostinglist.o src/backend/access/gin/ginlogic.o src/backend/access/gin/ginvalidate.o
/srvr/z5089358/postgresql-10.4/src/backend/access/spgist/spgtextproc.c: * Binary search an array of int16 datums for a match to c
/srvr/z5089358/postgresql-10.4/src/backend/access/spgist/spgtextproc.c:	/* Look up nodeChar in the node label array */
/srvr/z5089358/postgresql-10.4/src/backend/access/spgist/spgtextproc.c:	 * the output arrays.
/srvr/z5089358/postgresql-10.4/src/backend/access/spgist/spgutils.c:	amroutine->amsearcharray = false;
/srvr/z5089358/postgresql-10.4/src/backend/access/spgist/spgutils.c: * Construct an inner tuple containing the given prefix and node array
/srvr/z5089358/postgresql-10.4/src/backend/access/spgist/spgdoinsert.c: * the specified label datum, inserted at offset "offset" in the node array.
/srvr/z5089358/postgresql-10.4/src/backend/access/spgist/spgdoinsert.c:	 * array.  (This also greatly simplifies the math for reinserting the
/srvr/z5089358/postgresql-10.4/src/backend/access/spgist/spgdoinsert.c:	 * array, so we have to make a copy.
/srvr/z5089358/postgresql-10.4/src/backend/access/spgist/spgdoinsert.c:	 * Allocate per-leaf-tuple work arrays with max possible size
/srvr/z5089358/postgresql-10.4/src/backend/access/spgist/spgdoinsert.c:	 * Allocate per-node work arrays.  Since checkAllTheSame could replace
/srvr/z5089358/postgresql-10.4/src/backend/access/spgist/spgdoinsert.c:	 * page, we can't allocate these arrays before here.
/srvr/z5089358/postgresql-10.4/src/backend/access/spgist/spgdoinsert.c:	 * Update nodes[] array to point into the newly formed innerTuple, so that
/srvr/z5089358/postgresql-10.4/src/backend/access/spgist/spgvacuum.c:	 * the same thing.  The output of this step consists of six arrays
/srvr/z5089358/postgresql-10.4/src/backend/access/spgist/spgvacuum.c:		 * We do not store this array to rdata because it's easy to recreate.
/srvr/z5089358/postgresql-10.4/src/backend/access/spgist/spgvacuum.c:		/* The array is surely sorted, so can use PageIndexMultiDelete */
/srvr/z5089358/postgresql-10.4/src/backend/access/spgist/README:As we can see, the original tuple's node array moves to postfix tuple without
/srvr/z5089358/postgresql-10.4/src/backend/access/spgist/README:it can easily figure that out by constructing a predecessor array that's
/srvr/z5089358/postgresql-10.4/src/backend/access/spgist/spgxlog.c:			/* The array is sorted, so can use PageIndexMultiDelete */
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginget.c:		 * hope (and only hope, for intersection operation of array our
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginget.c: * Note that we copy the page into GinScanEntry->list array and unlock it, but
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginget.c:	 * entry array, but they aren't relevant yet.
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginget.c:	 * Prepare entryRes array to be passed to consistentFn.
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginget.c: * datum[]/category[]/datumExtracted[] arrays are used to cache the results
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginget.c: * Set up the entryRes array for each key by looking at
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginget.c:		 * Check entries in tuple and set up entryRes array.
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginpostinglist.c: * Decode a compressed posting list into an array of item pointers.
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginpostinglist.c: * Decode multiple posting list segments into an array of item pointers.
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginpostinglist.c:	 * Guess an initial size of the array.
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginpostinglist.c:		/* enlarge output array if needed */
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginpostinglist.c:			/* enlarge output array if needed */
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginpostinglist.c: * Merge two ordered arrays of itempointers, eliminating any duplicates.
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginpostinglist.c: * Returns a palloc'd array, and *nmerged is set to the number of items in
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginpostinglist.c:	 * If the argument arrays don't overlap, we can just append them to each
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/Makefile:	ginbtree.o ginscan.o ginget.o ginvacuum.o ginarrayproc.o \
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c: * ginarrayproc.c
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c: *	  support functions for GIN's indexing of any array
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c: *	  src/backend/access/gin/ginarrayproc.c
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:ginarrayextract(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:	/* Make copy of array input to ensure it doesn't disappear while in use */
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:	ArrayType  *array = PG_GETARG_ARRAYTYPE_P_COPY(0);
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:	get_typlenbyvalalign(ARR_ELEMTYPE(array),
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:	deconstruct_array(array,
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:					  ARR_ELEMTYPE(array),
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:	/* we should not free array, elems[i] points into it */
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c: * Formerly, ginarrayextract had only two arguments.  Now it has three,
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c: * pre-9.1 contrib/intarray opclass declarations.  This compatibility
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:ginarrayextract_2args(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:		elog(ERROR, "ginarrayextract requires three arguments");
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:	return ginarrayextract(fcinfo);
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:ginqueryarrayextract(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:	/* Make copy of array input to ensure it doesn't disappear while in use */
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:	ArrayType  *array = PG_GETARG_ARRAYTYPE_P_COPY(0);
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:	get_typlenbyvalalign(ARR_ELEMTYPE(array),
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:	deconstruct_array(array,
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:					  ARR_ELEMTYPE(array),
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:			elog(ERROR, "ginqueryarrayextract: unknown strategy number: %d",
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:	/* we should not free array, elems[i] points into it */
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:ginarrayconsistent(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:			 * against nulls here.  This is because array_contain_compare and
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:			 * array_eq handle nulls differently ...
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:			elog(ERROR, "ginarrayconsistent: unknown strategy number: %d",
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:ginarraytriconsistent(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:			 * against nulls here.  This is because array_contain_compare and
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:			 * array_eq handle nulls differently ...
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.c:			elog(ERROR, "ginarrayconsistent: unknown strategy number: %d",
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/gindatapage.c:	 * not NULL, it contains a palloc'd array of the itemsin this segment. If
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/gindatapage.c: * Read TIDs from leaf data page to single uncompressed array. The TIDs are
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/gindatapage.c: * Get pointer to the uncompressed array of items on a pre-9.4 format
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/gindatapage.c: * uncompressed leaf page. The number of items in the array is returned in
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/gindatapage.c:		 * items into an array below. In the best case, every new item fits in
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/gindatapage.c:		 * segment, with an array of items.
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/gindatapage.c: * Inserts array of item pointers, may execute several tree scan (very rare)
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/gininsert.c: * Adds array of item pointers to tuple's posting list, or
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/objfiles.txt:src/backend/access/gin/ginutil.o src/backend/access/gin/gininsert.o src/backend/access/gin/ginxlog.o src/backend/access/gin/ginentrypage.o src/backend/access/gin/gindatapage.o src/backend/access/gin/ginbtree.o src/backend/access/gin/ginscan.o src/backend/access/gin/ginget.o src/backend/access/gin/ginvacuum.o src/backend/access/gin/ginarrayproc.o src/backend/access/gin/ginbulk.o src/backend/access/gin/ginfast.o src/backend/access/gin/ginpostinglist.o src/backend/access/gin/ginlogic.o src/backend/access/gin/ginvalidate.o
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginvacuum.c: * a new palloc'd array with the remaining items. The number of remaining
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginvacuum.c:	 * Iterate over TIDs array
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginfast.c:	Datum	   *keys;			/* expansible array */
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginfast.c:	GinNullCategory *categories;	/* another expansible array */
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginfast.c:	int32		maxvalues;		/* allocated size of arrays */
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginfast.c: * Build a pending-list page from the given array of tuples, and write it out.
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginfast.c:	/* workspace could be a local array; we use palloc for alignment */
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginfast.c: * for the heap tuple specified by ht_ctid), and append them to the array
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginfast.c:	 * Build an index tuple for each key value, and add to array.  In pending
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginlogic.c: * with the check-array as is, and map the GIN_TRUE, GIN_FALSE, GIN_MAYBE
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginlogic.c: * NB: This function modifies the key->entryRes array!
Binary file /srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginarrayproc.o matches
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginentrypage.c: * Returns a palloc'd array of ItemPointers. The number of items is returned
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/README:where each key is an element of some indexed items (element of array, lexeme
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/README:Core PostgreSQL includes built-in Gin support for one-dimensional arrays
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/README:  * contains: value_array @> query_array
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/README:  * overlaps: value_array && query_array
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/README:  * is contained by: value_array <@ query_array
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/README:zero or more "keys".  For example, an item might be an integer array, and
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/README:  format. Otherwise it is just an array of ItemPointers. New tuples are always
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/README:the contents of the page is an array of PostingItem structs. Each PostingItem
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/README:after the page header, before the PostingItem array.
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginscan.c:	/* Add it to so's array */
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginscan.c:	/* initialize expansible array of GinScanEntry pointers */
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginscan.c:		 * If the extractQueryFn didn't create a nullFlags array, create one,
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginscan.c:		 * array and make sure each value is exactly 0 or 1; this ensures
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginbulk.c: * We do this as follows.  First, we imagine that we have an array whose size
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginbulk.c: * is the smallest power of two greater than or equal to the actual array
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginbulk.c: * size.  Second, we insert the middle entry of our virtual array into the
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginbulk.c: * tree; then, we insert the middles of each half of our virtual array, then
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginbulk.c: * This consists of a single key datum and a list (array) of one or more
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginutil.c:	amroutine->amsearcharray = false;
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginutil.c:	 * If the extractValueFn didn't create a nullFlags array, create one,
/srvr/z5089358/postgresql-10.4/src/backend/access/gin/ginutil.c:	 * assuming that everything's non-null.  Otherwise, run through the array
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/README.tuplock:locking data; it comprises an array of Xids plus some flags bits for each one.
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/README.HOT:case, and to keep various work arrays as well as the bitmaps in bitmap
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/pruneheap.c:	int			nredirected;	/* numbers of entries in arrays below */
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/pruneheap.c:	/* arrays that accumulate indexes of items to be changed */
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/pruneheap.c:	/* marked[i] is TRUE if item i is entered in one of the above arrays */
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/pruneheap.c: * caused by HeapTupleSatisfiesVacuum.  We just add entries to the arrays in
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/pruneheap.c: * to the redirected[] array (two entries per redirection); items to be set to
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/pruneheap.c: * The passed-in root_offsets array must have MaxHeapTuplesPerPage entries.
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/tuptoaster.c: *	We have a general rule that Datums of container types (rows, arrays,
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/tuptoaster.c:	 * We can pass the caller's isnull array directly to heap_form_tuple, but
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/tuptoaster.c:	 * we potentially need to modify the values array.
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/tuptoaster.c: *	Get an array of the indexes associated to the given toast relation
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/tuptoaster.c: *	relation in this array. It is the responsibility of the caller of this
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/tuptoaster.c: *	Close an array of indexes for a toast relation and free it. This should
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/heapam.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/heapam.c:				--lpp;			/* move back in this page's ItemId array */
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/heapam.c:				++lpp;			/* move forward in this page's ItemId array */
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/heapam.c:			 * Allocate offsets array. Unless we're reinitializing the page,
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/heapam.c:	 * need to walk the whole members array to figure out what to do, if
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/heapam.c:			 * in an assert-enabled build, walk the whole array to ensure
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/heapam.c: * Note: prior to Postgres 8.3, the entries in the nowunused[] array were
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/heapam.c:	 * The OffsetNumber arrays are not actually in the buffer, but we pretend
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/heapam.c:	 * arrays need not be stored too.  Note that even if all three arrays are
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/heapam.c:	 * The freeze plan array is not actually in the buffer, but pretend that
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/heapam.c:			 * order from FirstOffsetNumber. Otherwise there's an array of
/srvr/z5089358/postgresql-10.4/src/backend/access/heap/rewriteheap.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/access/common/indextuple.c: * Convert an index tuple into Datum/isnull arrays.
/srvr/z5089358/postgresql-10.4/src/backend/access/common/indextuple.c: * The caller must allocate sufficient storage for the output arrays.
/srvr/z5089358/postgresql-10.4/src/backend/access/common/indextuple.c:	/* Assert to protect callers who allocate fixed-size arrays */
/srvr/z5089358/postgresql-10.4/src/backend/access/common/printtup.c: * array pointer might be NULL (if we are doing Describe on a prepared stmt);
/srvr/z5089358/postgresql-10.4/src/backend/access/common/heaptuple.c: *		Load data portion of a tuple from values/isnull arrays
/srvr/z5089358/postgresql-10.4/src/backend/access/common/heaptuple.c: *		construct a tuple from the given values[] and isnull[] arrays,
/srvr/z5089358/postgresql-10.4/src/backend/access/common/heaptuple.c: * The replValues, replIsnull, and doReplace arrays must be of the length
/srvr/z5089358/postgresql-10.4/src/backend/access/common/heaptuple.c:	 * allocate and fill values and isnull arrays from either the tuple or the
/srvr/z5089358/postgresql-10.4/src/backend/access/common/heaptuple.c:	 * create a new tuple from the values and isnull arrays
/srvr/z5089358/postgresql-10.4/src/backend/access/common/heaptuple.c: * column(s) to replace by a boolean map, an array of target column numbers
/srvr/z5089358/postgresql-10.4/src/backend/access/common/heaptuple.c: * are to be replaced.  The replCols, replValues, and replIsnull arrays must
/srvr/z5089358/postgresql-10.4/src/backend/access/common/heaptuple.c:	 * allocate and fill values and isnull arrays from the tuple, then replace
/srvr/z5089358/postgresql-10.4/src/backend/access/common/heaptuple.c:	 * selected columns from the input arrays.
/srvr/z5089358/postgresql-10.4/src/backend/access/common/heaptuple.c:	 * create a new tuple from the values and isnull arrays
/srvr/z5089358/postgresql-10.4/src/backend/access/common/heaptuple.c: *		Given a tuple, extract data into values/isnull arrays; this is
/srvr/z5089358/postgresql-10.4/src/backend/access/common/heaptuple.c: *		Storage for the values/isnull arrays is provided by the caller;
/srvr/z5089358/postgresql-10.4/src/backend/access/common/heaptuple.c:	 * the caller's arrays.
/srvr/z5089358/postgresql-10.4/src/backend/access/common/heaptuple.c: *		into its Datum/isnull arrays.  Data is extracted up through the
/srvr/z5089358/postgresql-10.4/src/backend/access/common/heaptuple.c:	 * The result is acquired from tts_values array.
/srvr/z5089358/postgresql-10.4/src/backend/access/common/heaptuple.c: *		arrays to be valid.  The caller may then extract data directly
/srvr/z5089358/postgresql-10.4/src/backend/access/common/heaptuple.c: *		from those arrays instead of using slot_getattr.
/srvr/z5089358/postgresql-10.4/src/backend/access/common/heaptuple.c: *		arrays to be valid at least up through the attnum'th entry.
/srvr/z5089358/postgresql-10.4/src/backend/access/common/heaptuple.c: *		construct a MinimalTuple from the given values[] and isnull[] arrays,
/srvr/z5089358/postgresql-10.4/src/backend/access/common/reloptions.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/access/common/reloptions.c: * Initialize the relOpts array and fill each variable's type and name length.
/srvr/z5089358/postgresql-10.4/src/backend/access/common/reloptions.c: * Transform a relation options list (list of DefElem) into the text array
/srvr/z5089358/postgresql-10.4/src/backend/access/common/reloptions.c: * Both oldOptions and the result are text arrays (or NULL for "default"),
/srvr/z5089358/postgresql-10.4/src/backend/access/common/reloptions.c: * but we declare them as Datums to avoid including array.h in reloptions.h.
/srvr/z5089358/postgresql-10.4/src/backend/access/common/reloptions.c:	/* We build new array using accumArrayResult */
/srvr/z5089358/postgresql-10.4/src/backend/access/common/reloptions.c:		ArrayType  *array = DatumGetArrayTypeP(oldOptions);
/srvr/z5089358/postgresql-10.4/src/backend/access/common/reloptions.c:		deconstruct_array(array, TEXTOID, -1, false, 'i',
/srvr/z5089358/postgresql-10.4/src/backend/access/common/reloptions.c:	 * If CREATE/SET, add new options to array; if RESET, just check that the
/srvr/z5089358/postgresql-10.4/src/backend/access/common/reloptions.c: * Convert the text-array format of reloptions into a List of DefElem.
/srvr/z5089358/postgresql-10.4/src/backend/access/common/reloptions.c:	ArrayType  *array;
/srvr/z5089358/postgresql-10.4/src/backend/access/common/reloptions.c:	array = DatumGetArrayTypeP(options);
/srvr/z5089358/postgresql-10.4/src/backend/access/common/reloptions.c:	deconstruct_array(array, TEXTOID, -1, false, 'i',
/srvr/z5089358/postgresql-10.4/src/backend/access/common/reloptions.c: * Interpret reloptions that are given in text-array format.
/srvr/z5089358/postgresql-10.4/src/backend/access/common/reloptions.c: * options is a reloption text array as constructed by transformRelOptions.
/srvr/z5089358/postgresql-10.4/src/backend/access/common/reloptions.c: * The return value is a relopt_value * array on which the options actually
/srvr/z5089358/postgresql-10.4/src/backend/access/common/reloptions.c: * set in the options array are marked with isset=true.  The length of this
/srvr/z5089358/postgresql-10.4/src/backend/access/common/reloptions.c: * array is returned in *numrelopts.  Options not set are also present in the
/srvr/z5089358/postgresql-10.4/src/backend/access/common/reloptions.c: * array; this is so that the caller can easily locate the default values.
/srvr/z5089358/postgresql-10.4/src/backend/access/common/reloptions.c: * returned array.  Values of type string are allocated separately and must
/srvr/z5089358/postgresql-10.4/src/backend/access/common/reloptions.c:		ArrayType  *array = DatumGetArrayTypeP(options);
/srvr/z5089358/postgresql-10.4/src/backend/access/common/reloptions.c:		deconstruct_array(array, TEXTOID, -1, false, 'i',
/srvr/z5089358/postgresql-10.4/src/backend/access/common/reloptions.c:		if (((void *) array) != DatumGetPointer(options))
/srvr/z5089358/postgresql-10.4/src/backend/access/common/reloptions.c:			pfree(array);
/srvr/z5089358/postgresql-10.4/src/backend/access/common/tupconvert.c: * The key component of a TupleConversionMap is an attrMap[] array with
/srvr/z5089358/postgresql-10.4/src/backend/access/common/tupconvert.c: * arrays.
/srvr/z5089358/postgresql-10.4/src/backend/access/common/tupconvert.c:	/* preallocate workspace for Datum arrays */
/srvr/z5089358/postgresql-10.4/src/backend/access/common/tupconvert.c:	/* preallocate workspace for Datum arrays */
/srvr/z5089358/postgresql-10.4/src/backend/access/common/tupconvert.c:	 * Extract all the values of the old tuple, offsetting the arrays so that
/srvr/z5089358/postgresql-10.4/src/backend/access/common/tupdesc.c:	 * alignment padding between the struct and the array of attribute row
/srvr/z5089358/postgresql-10.4/src/backend/access/common/tupdesc.c: *		Form_pg_attribute array.
/srvr/z5089358/postgresql-10.4/src/backend/access/common/tupdesc.c: * Note: if the TupleDesc is ever freed, the Form_pg_attribute array
/srvr/z5089358/postgresql-10.4/src/backend/access/common/tupdesc.c:		 * array in the first place).  It might look like we could dispense
/srvr/z5089358/postgresql-10.4/src/backend/access/common/tupdesc.c:		attdim = list_length(entry->typeName->arrayBounds);
Binary file /srvr/z5089358/postgresql-10.4/src/backend/access/common/reloptions.o matches
/srvr/z5089358/postgresql-10.4/src/backend/access/hash/hashpage.c:	/* find largest bitmap array size that will fit in page size */
/srvr/z5089358/postgresql-10.4/src/backend/access/hash/hashpage.c:	 * array and hashm_ovflpoint so that future overflow pages will be created
/srvr/z5089358/postgresql-10.4/src/backend/access/hash/hashfunc.c: *		k		: the key (the unaligned variable-length array of bytes)
/srvr/z5089358/postgresql-10.4/src/backend/access/hash/hashutil.c: * Inputs: values and isnull arrays for the user data column(s)
/srvr/z5089358/postgresql-10.4/src/backend/access/hash/hashutil.c: * Outputs: values and isnull arrays for the index tuple, suitable for
/srvr/z5089358/postgresql-10.4/src/backend/access/hash/hashutil.c: * Note: callers know that the index-column arrays are always of length 1.
/srvr/z5089358/postgresql-10.4/src/backend/access/hash/README:is an array stored in the metapage) with given bucket number to compute its
/srvr/z5089358/postgresql-10.4/src/backend/access/hash/README:When S splitpoints exist altogether, the array entries hashm_spares[0]
/srvr/z5089358/postgresql-10.4/src/backend/access/hash/hash.c:	amroutine->amsearcharray = false;
/srvr/z5089358/postgresql-10.4/src/backend/access/hash/hash_xlog.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/access/hash/hashinsert.c: * Returns the offset number array at which the tuples were inserted.
/srvr/z5089358/postgresql-10.4/src/backend/access/hash/hashinsert.c:			 * We need the target-offsets array whether or not we store the
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/varsup.c:		 * nxids before filling the array entry.  Note we are assuming that
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/transam.c: * but now lives in procarray.c.
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/transam.c: * "xid" is a toplevel transaction commit, and the xids array contains its
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/transam.c: * "xid" is a toplevel transaction commit, and the xids array contains its
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/transam.c:	 * In practice it is highly likely that the xids[] array is sorted, and so
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/transam.c:	 * array back-to-front to avoid useless assignments.
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xlog.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xlog.c: * All the WAL insertion locks are allocated as an array in shared memory. We
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xlog.c: * force the array stride to be a power of 2, which saves a few cycles in
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xlog.c: * array start address is suitably aligned.)
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xlog.c:	/* xlblocks array */
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xlog.c:			/* Tell procarray about the range of xids it has to deal with */
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xlog.c:			 * not included in the enum option array, and therefore will never
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xlog.c:			/* can't happen (unless we are out of sync with option array) */
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xact.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xact.c:	 * the XIDs in this array are sorted numerically rather than according to
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xact.c:		/* As the childXids array is ordered, we can use binary search */
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xact.c:	 * in the procarray and continue to hold locks.
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xact.c:	 * The parent childXids array will need to hold my XID and all my
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xact.c:	/* Allocate or enlarge the parent array if necessary */
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xact.c:		 * We keep the child-XID arrays in TopTransactionContext; this avoids
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xact.c:	 * Copy all my XIDs to parent's array.
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xact.c:	 * XIDs of its children, we ensure that the array stays ordered. Likewise,
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xact.c:	 * all XIDs already in the array belong to subtransactions started and
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xact.c:	/* Release child's array to avoid leakage */
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xact.c:	 * subxacts, because we already have the child XID array at hand.  For
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xact.c:	 * We keep the child-XID arrays in TopTransactionContext (see
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xact.c:	 * AtSubCommit_childXids).  This means we'd better free the array
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xact.c:	 * We could prune the unreportedXids array here. But we don't bother. That
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xact.c:	 * Lock the virtual transaction id before we announce it in the proc array
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xact.c:	 * Advertise it in the proc array.  We assume assignment of
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xact.c: * array of TransactionIds.  The array is allocated in TopTransactionContext;
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/multixact.c: * The pg_multixact manager is a pg_xact-like manager that stores an array of
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/multixact.c: * and retrieve the arrays.
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/multixact.c: * store variable length arrays of TransactionIds.  (We could alternatively
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/multixact.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/multixact.c: * Note that the "offset" macros work with byte offset, not array indexes, so
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/multixact.c:	 * Per-backend data starts here.  We have two arrays stored in the area
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/multixact.c:	 * In both arrays, there's a slot for all normal backends (1..MaxBackends)
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/multixact.c:	 * BackendIds start from 1; element zero of each array is never used.
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/multixact.c: * Last element of OldestMemberMXactID and OldestVisibleMXactId arrays.
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/multixact.c:	 * This could be made faster by having another entry point in procarray.c,
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/multixact.c:	 * walking the PGPROC array only once for all the members.  But in most
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/multixact.c:		 * must be sure to store a valid value in our array entry.
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/multixact.c:		 * must be sure to store a valid value in our array entry.
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/multixact.c: * NB: the passed members[] array will be sorted in-place.
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/multixact.c: * and *members is set to a newly palloc'ed array of members.  It's the
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/multixact.c:	 * read a zero from the members array, just ignore it.
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/multixact.c: * NB: the passed members array will be sorted in-place.
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/multixact.c:	/* sort the array so comparison is easy */
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/multixact.c: * struct and the per-backend MultiXactId arrays (two of those, too).
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/multixact.c:	 * Set up array pointers.  Note that perBackendXactIds[0] is wasted space
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/multixact.c:	 * since we only use indexes 1..MaxOldestSlot in each array.
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/commit_ts.c: * subxids is an array of xids of length nsubxids, representing subtransactions
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xloginsert.c: * An array of XLogRecData structs, to hold registered data.
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xloginsert.c:	 * consistently even if the arrays happen to be large enough already.
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/slru.c:	/* Register SLRU tranche in the main tranches array */
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/slru.c:		 * page_lru_count array after the loop finishes.  This ensures that
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xlogreader.c:	 * making a static array, for two reasons: (1) no need to waste the
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/xlogreader.c:	 * storage in most instantiations of the backend; (2) a static char array
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/README:room for them in the subxid array; instead we guarantee that they are
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/README:subxid array) without taking ProcArrayLock.  This was once necessary to
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/README:cache has been overflowed.  See storage/ipc/procarray.c for the gory details.
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/README:in the array until it commits. Further details are given in comments in
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/README:procarray.c.
Binary file /srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.o matches
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/parallel.c:	/* Free the worker array itself. */
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/parallel.c: * and consult the InternalParallelWorkers array.  External functions are
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/parallel.c:	 * InternalParallelWorkers array.
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/generic_xlog.c:	/* Search array for existing entry or first unused slot */
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/generic_xlog.c:	/* Protect limited size of buffers[] array */
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c: *		We keep all active global transactions in a shared memory array.
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c: *		reserved for the transaction in the array. This is done before
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c: * the TwoPhaseState->prepXacts array with the correct GID and valid = false,
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c: * from the ProcArray and the TwoPhaseState->prepXacts array and return it to
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c:	bool		valid;			/* TRUE if PGPROC entry is in proc array */
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c:	/* There are max_prepared_xacts items in this array */
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c:	/* Need the fixed struct, the array of pointers, and the GTD structs */
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c:			 * allows you to allocate an array of size (MaxBackends +
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c:	/* And insert it into the active array */
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c: * This uses a gxact struct and puts it into the active array.
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c: *		Remove the prepared transaction from the shared memory array.
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c:			/* remove from the active array */
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c:	elog(ERROR, "failed to find %p in GlobalTransaction array", gxact);
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c: * Returns an array of all prepared transactions for the user-level
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c: * The returned array and all its elements are copies of internal data
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c: * The returned array is palloc'd.
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c:	GlobalTransaction array;
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c:	array = (GlobalTransaction) palloc(sizeof(GlobalTransactionData) * num);
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c:	*gxacts = array;
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c:		memcpy(array + i, TwoPhaseState->prepXacts[i],
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c:	GlobalTransaction array;
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c:		status->ngxacts = GetPreparedTransactionList(&status->array);
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c:	while (status->array != NULL && status->currIdx < status->ngxacts)
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c:		GlobalTransaction gxact = &status->array[status->currIdx++];
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c:	 * running in the procarray (twice!) and continue to hold locks.
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c: * If xids_p and nxids_p are not NULL, pointer to a palloc'd array of all
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c: * top-level xids is stored in *xids_p. The number of entries in the array
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c:	 * in the procarray and continue to hold locks.
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c:	 * in the procarray and continue to hold locks.
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c:	 * This creates a gxact struct and puts it into the active array.
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/twophase.c:	/* And insert it into the active array */
/srvr/z5089358/postgresql-10.4/src/backend/access/transam/clog.c: * subxids is an array of xids of length nsubxids, representing subtransactions
/srvr/z5089358/postgresql-10.4/src/backend/access/tablesample/system.c:	 * We compute the hash by applying hash_any to an array of 2 uint32's
/srvr/z5089358/postgresql-10.4/src/backend/access/tablesample/bernoulli.c:	 * We compute the hash by applying hash_any to an array of 3 uint32's
/srvr/z5089358/postgresql-10.4/src/backend/access/brin/brin_inclusion.c: * Subtract this from procnum to obtain index in InclusionOpaque arrays
/srvr/z5089358/postgresql-10.4/src/backend/access/brin/brin_inclusion.c: * The values stored in the bv_values arrays correspond to:
/srvr/z5089358/postgresql-10.4/src/backend/access/brin/brin_inclusion.c:	 * All members of opaque are initialized lazily; both procinfo arrays
/srvr/z5089358/postgresql-10.4/src/backend/access/brin/brin_tuple.c: * datum array.
/srvr/z5089358/postgresql-10.4/src/backend/access/brin/brin_tuple.c:	 * Set up the values/nulls arrays for heap_fill_tuple
/srvr/z5089358/postgresql-10.4/src/backend/access/brin/brin_tuple.c:	/* Assert we did not overrun temp arrays */
/srvr/z5089358/postgresql-10.4/src/backend/access/brin/brin_tuple.c:	 * values array of each column.  The copies occur in the tuple's context.
/srvr/z5089358/postgresql-10.4/src/backend/access/brin/brin_tuple.c: *	values		output values, array of size brdesc->bd_totalstored
/srvr/z5089358/postgresql-10.4/src/backend/access/brin/brin_tuple.c: * Output arrays must have been allocated by caller.
/srvr/z5089358/postgresql-10.4/src/backend/access/brin/brin.c: *		* ScalarArrayOpExpr (amsearcharray -> SK_SEARCHARRAY)
/srvr/z5089358/postgresql-10.4/src/backend/access/brin/brin.c:	amroutine->amsearcharray = false;
/srvr/z5089358/postgresql-10.4/src/backend/access/brin/brin_revmap.c:	/* the rm_tids array is initialized to all invalid by PageInit */
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gistbuildbuffers.c:		 * buffersOnLevels array if needed.
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gistbuildbuffers.c: * Add specified buffer into loadedBuffers array.
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gistbuildbuffers.c:	/* Never add a temporary buffer to the array */
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gistbuildbuffers.c:	/* Enlarge the array if needed */
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gistbuildbuffers.c:	/* Enlarge freeBlocks array if full. */
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gistbuildbuffers.c:	/* Add blocknum to array */
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gistutil.c: * Union Datums are returned into the attr/isnull arrays.
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gistutil.c:			/* Make union and store in attr array */
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gistsplit.c: * spl->spl_dontcare[] to "true".  Caller must have initialized that array
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gistsplit.c: * Remove tuples that are marked don't-cares from the tuple index array a[]
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gistsplit.c: * arrays.
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gistsplit.c:	/* emit union datums computed by PickSplit back to v arrays */
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gistsplit.c: * itup: array of IndexTuples to be processed
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gistsplit.c: * Outside caller must initialize v->spl_lisnull and v->spl_risnull arrays
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gistsplit.c:	/* generate the item array, and identify tuples with null keys */
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gistsplit.c:				 * Form an array of just the don't-care tuples to pass to a
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gistproc.c:	/* Index of entry in the initial array */
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gistproc.c:	/* Allocate arrays for intervals along axes */
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gistproc.c:		 * Make two arrays of intervals: one sorted by lower bound and another
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gistproc.c:	 * Allocate an array for "common entries" - entries which can be placed to
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gistxlog.c: * Returns an array of index pointers.
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gistxlog.c: * Note that both the todelete array and the tuples are marked as belonging
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gistget.c: * myDistances: distances array associated with pageItem, or NULL at the root
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gist.c:	amroutine->amsearcharray = false;
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gist.c:	 * one-element todelete array; in the split case, it's handled implicitly
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gist.c:	/* safety check to protect fixed-size arrays in GISTSTATE */
/srvr/z5089358/postgresql-10.4/src/backend/access/gist/gistbuild.c:		/* Create an array of all the downlink tuples */
/srvr/z5089358/postgresql-10.4/src/backend/bootstrap/bootparse.c:/* The size of an array large to enough to hold all stacks, each with
/srvr/z5089358/postgresql-10.4/src/backend/bootstrap/bootstrap.c:		/* if an array type, assume 1-dimensional attribute */
/srvr/z5089358/postgresql-10.4/src/backend/bootstrap/bootstrap.c:		/* if an array type, assume 1-dimensional attribute */
/srvr/z5089358/postgresql-10.4/src/backend/bootstrap/bootstrap.c: * TypInfo[].  At that point it will read and cache pg_type in the Typ array,
/srvr/z5089358/postgresql-10.4/src/backend/bootstrap/bootstrap.c: * the binary I/O routines.  It is exported so that array_in and array_out
/srvr/z5089358/postgresql-10.4/src/backend/bootstrap/bootstrap.c:		/* We don't have pg_type yet, so use the hard-wired TypInfo array */
/srvr/z5089358/postgresql-10.4/src/backend/bootstrap/bootstrap.c: * Given a type name, produce the corresponding array type name by prepending
/srvr/z5089358/postgresql-10.4/src/backend/bootstrap/bootscanner.c: * integer for use as an array index.  If the signed char is negative,
/srvr/z5089358/postgresql-10.4/src/backend/bootstrap/bootscanner.c:static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
/srvr/z5089358/postgresql-10.4/src/backend/bootstrap/bootscanner.c:		/* Extend the array by 50%, plus the number we really need. */
/srvr/z5089358/postgresql-10.4/src/backend/bootstrap/bootscanner.l:arrayid [A-Za-z0-9_]+\[{D}*\]
/srvr/z5089358/postgresql-10.4/src/backend/bootstrap/bootscanner.l:{arrayid}		{
/srvr/z5089358/postgresql-10.4/src/backend/utils/mmgr/dsa.c: * defined by the following array.  Larger size classes are spaced more widely
/srvr/z5089358/postgresql-10.4/src/backend/utils/mmgr/dsa.c: * index into this array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/mmgr/dsa.c:	 * This backend's array of segment maps, ordered by segment index
/srvr/z5089358/postgresql-10.4/src/backend/utils/mmgr/dsa.c:		 * array slot without holding a lock; it won't change underneath us.
/srvr/z5089358/postgresql-10.4/src/backend/utils/errcodes.txt:# SQL99's actual definition of "array element error" is subscript error
/srvr/z5089358/postgresql-10.4/src/backend/utils/errcodes.txt:2202E    E    ERRCODE_ARRAY_SUBSCRIPT_ERROR                                  array_subscript_error
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c: * We manage small sets of resource IDs by keeping them in a simple array:
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c: * items present; if it would exceed maxitems, we enlarge the array and
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c:	uint32		nitems;			/* how many items are stored in items array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c: * we'll use (arraysize - 1) as mask for hashing.
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c: * When to switch to hashing vs. simple array logic in a ResourceArray.
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c: * How many items may be stored in a resource array of given capacity.
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c: * Make sure there is room for at least one more resource in an array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c:	/* Double the capacity of the array (capacity must stay a power of 2!) */
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c:		 * Transfer any pre-existing entries into the new array; they don't
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c:		 * best way.  Note that if we were managing the set as a simple array,
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c:		/* And release old array. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c:		/* Append to linear array. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c: * Returns true if we found an element, or false if the array is empty.
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c:		/* Linear array: just return the first element. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c:		 * buffer entry from our array, so we just have to iterate till there
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c:		 * the catref entry from our array, so we just have to iterate till
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c: * buffer array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c: * ResourceOwnerForgetLock doesn't need to scan through a large array to find
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c: * catcache reference array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c: * catcache-list reference array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c: * relcache reference array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c: * plancache reference array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c: * tupdesc reference array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c: * snapshot reference array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c: * files reference array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/resowner/resowner.c: * dynamic shmem segment reference array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/objfiles.txt:src/backend/utils/adt/acl.o src/backend/utils/adt/amutils.o src/backend/utils/adt/arrayfuncs.o src/backend/utils/adt/array_expanded.o src/backend/utils/adt/array_selfuncs.o src/backend/utils/adt/array_typanalyze.o src/backend/utils/adt/array_userfuncs.o src/backend/utils/adt/arrayutils.o src/backend/utils/adt/ascii.o src/backend/utils/adt/bool.o src/backend/utils/adt/cash.o src/backend/utils/adt/char.o src/backend/utils/adt/date.o src/backend/utils/adt/datetime.o src/backend/utils/adt/datum.o src/backend/utils/adt/dbsize.o src/backend/utils/adt/domains.o src/backend/utils/adt/encode.o src/backend/utils/adt/enum.o src/backend/utils/adt/expandeddatum.o src/backend/utils/adt/float.o src/backend/utils/adt/format_type.o src/backend/utils/adt/formatting.o src/backend/utils/adt/genfile.o src/backend/utils/adt/geo_ops.o src/backend/utils/adt/geo_selfuncs.o src/backend/utils/adt/geo_spgist.o src/backend/utils/adt/inet_cidr_ntop.o src/backend/utils/adt/inet_net_pton.o src/backend/utils/adt/int.o src/backend/utils/adt/int8.o src/backend/utils/adt/json.o src/backend/utils/adt/jsonb.o src/backend/utils/adt/jsonb_gin.o src/backend/utils/adt/jsonb_op.o src/backend/utils/adt/jsonb_util.o src/backend/utils/adt/jsonfuncs.o src/backend/utils/adt/like.o src/backend/utils/adt/lockfuncs.o src/backend/utils/adt/mac.o src/backend/utils/adt/mac8.o src/backend/utils/adt/misc.o src/backend/utils/adt/nabstime.o src/backend/utils/adt/name.o src/backend/utils/adt/network.o src/backend/utils/adt/network_gist.o src/backend/utils/adt/network_selfuncs.o src/backend/utils/adt/network_spgist.o src/backend/utils/adt/numeric.o src/backend/utils/adt/numutils.o src/backend/utils/adt/oid.o src/backend/utils/adt/oracle_compat.o src/backend/utils/adt/orderedsetaggs.o src/backend/utils/adt/pg_locale.o src/backend/utils/adt/pg_lsn.o src/backend/utils/adt/pg_upgrade_support.o src/backend/utils/adt/pgstatfuncs.o src/backend/utils/adt/pseudotypes.o src/backend/utils/adt/quote.o src/backend/utils/adt/rangetypes.o src/backend/utils/adt/rangetypes_gist.o src/backend/utils/adt/rangetypes_selfuncs.o src/backend/utils/adt/rangetypes_spgist.o src/backend/utils/adt/rangetypes_typanalyze.o src/backend/utils/adt/regexp.o src/backend/utils/adt/regproc.o src/backend/utils/adt/ri_triggers.o src/backend/utils/adt/rowtypes.o src/backend/utils/adt/ruleutils.o src/backend/utils/adt/selfuncs.o src/backend/utils/adt/tid.o src/backend/utils/adt/timestamp.o src/backend/utils/adt/trigfuncs.o src/backend/utils/adt/tsginidx.o src/backend/utils/adt/tsgistidx.o src/backend/utils/adt/tsquery.o src/backend/utils/adt/tsquery_cleanup.o src/backend/utils/adt/tsquery_gist.o src/backend/utils/adt/tsquery_op.o src/backend/utils/adt/tsquery_rewrite.o src/backend/utils/adt/tsquery_util.o src/backend/utils/adt/tsrank.o src/backend/utils/adt/tsvector.o src/backend/utils/adt/tsvector_op.o src/backend/utils/adt/tsvector_parser.o src/backend/utils/adt/txid.o src/backend/utils/adt/uuid.o src/backend/utils/adt/varbit.o src/backend/utils/adt/varchar.o src/backend/utils/adt/varlena.o src/backend/utils/adt/version.o src/backend/utils/adt/windowfuncs.o src/backend/utils/adt/xid.o src/backend/utils/adt/xml.o
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/help_config.c:	/* Initialize the guc_variables[] array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c:static int addToArray(tzEntry **base, int *arraysize, int n,
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c:			tzEntry **base, int *arraysize, int n);
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c: * Insert entry into sorted array
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c: * *base: base address of array (changeable if must enlarge array)
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c: * *arraysize: allocated length of array (changeable if must enlarge array)
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c: * n: current number of valid elements in array
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c: * Returns the new array length (new value for n), or -1 if error
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c:addToArray(tzEntry **base, int *arraysize, int n,
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c:	tzEntry    *arrayptr;
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c:	 * Search the array for a duplicate; as a useful side effect, the array is
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c:	arrayptr = *base;
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c:		tzEntry    *midptr = arrayptr + mid;
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c:				/* return unchanged array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c:	if (n >= *arraysize)
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c:		*arraysize *= 2;
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c:		*base = (tzEntry *) repalloc(*base, *arraysize * sizeof(tzEntry));
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c:	arrayptr = *base + low;
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c:	memmove(arrayptr + 1, arrayptr, (n - low) * sizeof(tzEntry));
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c:	memcpy(arrayptr, entry, sizeof(tzEntry));
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c: * *base: array for results (changeable if must enlarge array)
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c: * *arraysize: allocated length of array (changeable if must enlarge array)
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c: * n: current number of valid elements in array
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c: * Returns the new array length (new value for n), or -1 if error
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c:			tzEntry **base, int *arraysize, int n)
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c:							base, arraysize, n);
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c:		n = addToArray(base, arraysize, n, &tzentry, override);
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c:	tzEntry    *array;
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c:	int			arraysize;
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c:	/* Initialize array at a reasonable size */
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c:	arraysize = 128;
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c:	array = (tzEntry *) palloc(arraysize * sizeof(tzEntry));
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c:	n = ParseTzFile(filename, 0, &array, &arraysize, 0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/tzparser.c:		result = ConvertTimeZoneAbbrevs(array, n);
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/ps_status.c: * If needed, we make a copy of the original argv[] array to preserve it
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/ps_status.c:	 * into the argv array, and will get horribly confused when it is
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/ps_status.c: * values.  At this point, the original argv[] array may be overwritten.
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/postgresql.conf.sample:#array_nulls = on
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc-file.l:	 * Read the directory and put the filenames in an array, so we can sort
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc-file.l:				/* Add file to array, increasing its size in blocks of 32 */
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:	/* help_config wants this array to be null-terminated */
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:		{"array_nulls", PGC_USERSET, COMPAT_OPTIONS_PREVIOUS,
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:			gettext_noop("Enable input of NULL elements in arrays."),
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:			gettext_noop("When turned on, unquoted NULL in an array input "
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:			gettext_noop("For RAID arrays, this should be approximately the number of drive spindles in the array.")
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:		 * it's not worth having a separate options array for this.
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c: * Actual lookup of variables is done through this single, sorted array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:static bool validate_option_array_item(const char *name, const char *value,
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c: * Fetch the sorted array pointer (exported for help_config.c's use ONLY)
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c: * Build the sorted array.  This is split out so that it could be
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c: * comparator for qsorting and bsearching guc_variables array
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:	 * array ordering has to remain stable across setlocale() calls. So, build
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:	 * Build sorted array of all GUC variables.
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c: * variable into the GUC variable array, replacing any placeholder.
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:		/* assign to the values array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c: * The array parameter must be an array of TEXT (it must not be NULL).
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:ProcessGUCArray(ArrayType *array,
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:	Assert(array != NULL);
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:	Assert(ARR_ELEMTYPE(array) == TEXTOID);
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:	Assert(ARR_NDIM(array) == 1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:	Assert(ARR_LBOUND(array)[0] == 1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:	for (i = 1; i <= ARR_DIMS(array)[0]; i++)
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:		d = array_ref(array, 1, &i,
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:					  -1 /* varlenarray */ ,
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c: * Add an entry to an option array.  The array parameter may be NULL
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:GUCArrayAdd(ArrayType *array, const char *name, const char *value)
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:	(void) validate_option_array_item(name, value, false);
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:	/* build new item for array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:	if (array)
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:		Assert(ARR_ELEMTYPE(array) == TEXTOID);
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:		Assert(ARR_NDIM(array) == 1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:		Assert(ARR_LBOUND(array)[0] == 1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:		index = ARR_DIMS(array)[0] + 1; /* add after end */
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:		for (i = 1; i <= ARR_DIMS(array)[0]; i++)
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:			d = array_ref(array, 1, &i,
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:						  -1 /* varlenarray */ ,
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:		a = array_set(array, 1, &index,
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:					  -1 /* varlena array */ ,
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:		a = construct_array(&datum, 1,
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c: * Delete an entry from an option array.  The array parameter may be NULL
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:GUCArrayDelete(ArrayType *array, const char *name)
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:	ArrayType  *newarray;
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:	(void) validate_option_array_item(name, NULL, false);
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:	/* if array is currently null, then surely nothing to delete */
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:	if (!array)
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:	newarray = NULL;
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:	for (i = 1; i <= ARR_DIMS(array)[0]; i++)
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:		d = array_ref(array, 1, &i,
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:					  -1 /* varlenarray */ ,
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:		/* else add it to the output array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:		if (newarray)
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:			newarray = array_set(newarray, 1, &index,
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:								 -1 /* varlenarray */ ,
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:			newarray = construct_array(&d, 1,
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:	return newarray;
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c: * Given a GUC array, delete all settings from it that our permission
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:GUCArrayReset(ArrayType *array)
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:	ArrayType  *newarray;
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:	/* if array is currently null, nothing to do */
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:	if (!array)
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:	newarray = NULL;
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:	for (i = 1; i <= ARR_DIMS(array)[0]; i++)
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:		d = array_ref(array, 1, &i,
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:					  -1 /* varlenarray */ ,
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:		if (validate_option_array_item(val, NULL, true))
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:		/* else add it to the output array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:		if (newarray)
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:			newarray = array_set(newarray, 1, &index,
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:								 -1 /* varlenarray */ ,
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:			newarray = construct_array(&d, 1,
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:	return newarray;
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:validate_option_array_item(const char *name, const char *value,
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc.c:	/* Initialize the array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/timeout.c: * Find the index of a given timeout reason in the active array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/pg_controldata.c:	/* Populate the values and null arrays */
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc-file.c: * integer for use as an array index.  If the signed char is negative,
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc-file.c:static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc-file.c:		/* Extend the array by 50%, plus the number we really need. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc-file.c:	 * Read the directory and put the filenames in an array, so we can sort
/srvr/z5089358/postgresql-10.4/src/backend/utils/misc/guc-file.c:				/* Add file to array, increasing its size in blocks of 32 */
/srvr/z5089358/postgresql-10.4/src/backend/utils/Gen_fmgrtab.pl:     comma after the last field in an array initializer) */
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/cache/relcache.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/relmapper.c: * Entries in the mappings[] array are in no particular order.  We could
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/plancache.c: * param_types: array of fixed parameter type OIDs, or NULL if none
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/inval.c: * array).  All request types can be stored as SharedInvalidationMessage
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/inval.c:	int			maxitems;		/* size of allocated array in this chunk */
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/inval.c: * array; it'd be easy to improve that if needed.
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/inval.c: * As above, but the code fragment can handle an array of messages.
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/inval.c: * As above, but the function is able to process an array of messages
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/inval.c: * Collect invalidation messages into SharedInvalidMessagesArray array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/inval.c:	 * Initialise array first time through in each commit
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/inval.c:	 * Append the next chunk onto the array
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/inval.c:	 * single contiguous array of invalidation messages. It must be contiguous
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/relcache.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/relcache.c: * cleanup work.  The array expands as needed; there is no hashtable because
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/relcache.c:	 * allocate an array to hold the rewrite rules (the array is extended if
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/relcache.c:		 * no partitions were added or removed to the relation, the oids array
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/relcache.c:	 * Allocate arrays to hold data
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/relcache.c:	 * Fill the support procedure OID array, as well as the info about
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/relcache.c: * which are arrays allocated by the caller.
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/relcache.c: * indicate the size of the arrays it has allocated --- but in practice these
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/relcache.c:	 * initialize relation id from info in att array (my, this is ugly)
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/relcache.c:		 * the array fields are allowed to change, though.
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/relcache.c:			elog(ERROR, "conkey is not a 1-D smallint array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/relcache.c:			elog(ERROR, "confkey is not a 1-D smallint array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/relcache.c:			elog(ERROR, "conpfeqop is not a 1-D OID array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/relcache.c: * associated exclusion constraint.  It returns arrays (palloc'd in caller's
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/relcache.c:			elog(ERROR, "conexclop is not a 1-D Oid array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/relcache.c: * startup sequence gets into the sinval array before trying to load the init
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c: * In some cases (currently only array_eq and record_eq), mergejoinability
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:	 * For array_eq or record_eq, we can sort if the element or field types
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c: * In some cases (currently only array_eq), hashjoinability depends on the
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c: * The arguments are returned as a palloc'd array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:	 * use array_in and array_out during bootstrap.
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c: *		Given the type OID, get the typelem (InvalidOid if not an array type).
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c: * NB: this only considers varlena arrays to be true arrays; InvalidOid is
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c: * returned if the input is a fixed-length array type.
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c: * get_array_type
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c: *		Given the type OID, get the corresponding "true" array type.
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c: *		Returns InvalidOid if no array type can be found.
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:get_array_type(Oid typid)
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:		result = ((Form_pg_type) GETSTRUCT(tp))->typarray;
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c: * get_promoted_array_type
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c: *		construct, that is, either the corresponding "true" array type
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c: *		if the input is a scalar type that has such an array type,
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c: *		or the same type if the input is already a "true" array type.
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:get_promoted_array_type(Oid typid)
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:	Oid			array_type = get_array_type(typid);
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:	if (OidIsValid(array_type))
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:		return array_type;
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c: *		to its underlying array type.
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c: * about the typmod of the array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c: * values: receives pointer to an array of the slot's stavalues.
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c: * numbers: receives pointer to an array of the slot's stanumbers (as float4).
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:	ArrayType  *statarray;
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:	Oid			arrayelemtype;
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:	int			narrayelem;
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:		 * Detoast the array if needed, and in any case make a copy that's
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:		statarray = DatumGetArrayTypePCopy(val);
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:		 * Extract the actual array element type, and pass it back in case the
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:		sslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:		typeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:			elog(ERROR, "cache lookup failed for type %u", arrayelemtype);
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:		/* Deconstruct array into Datum elements; NULLs not expected */
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:		deconstruct_array(statarray,
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:						  arrayelemtype,
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:		 * Datums that are pointers into the statarray, so we need to keep
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:		 * sslot->values[], so we can free the array object immediately.
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:			sslot->values_arr = statarray;
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:			pfree(statarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:		 * Detoast the array if needed, and in any case make a copy that's
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:		statarray = DatumGetArrayTypePCopy(val);
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:		 * We expect the array to be a 1-D float4 array; verify that. We don't
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:		 * need to use deconstruct_array() since the array data is just going
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:		 * to look like a C array of float4 values.
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:		narrayelem = ARR_DIMS(statarray)[0];
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:		if (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:			ARR_HASNULL(statarray) ||
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:			ARR_ELEMTYPE(statarray) != FLOAT4OID)
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:			elog(ERROR, "stanumbers is not a 1-D float4 array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:		/* Give caller a pointer directly into the statarray */
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:		sslot->numbers = (float4 *) ARR_DATA_PTR(statarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:		sslot->nnumbers = narrayelem;
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:		/* We'll free the statarray in free_attstatsslot */
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:		sslot->numbers_arr = statarray;
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:	/* The values[] array was separately palloc'd by deconstruct_array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:	/* The numbers[] array points into numbers_arr, do not pfree it */
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.c:	/* Free the detoasted array objects, if any */
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c: * cache by generic array and record handling routines, such as array_eq(),
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c: * record_cmp(), and hash_array().  Because those routines are used as index
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c: * Stored record types are remembered in a linear array of TupleDescs,
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c:static int32 RecordCacheArrayLen = 0;	/* allocated length of array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c:static bool array_element_has_equality(TypeCacheEntry *typentry);
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c:static bool array_element_has_compare(TypeCacheEntry *typentry);
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c:static bool array_element_has_hashing(TypeCacheEntry *typentry);
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c:static void cache_array_element_properties(TypeCacheEntry *typentry);
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c:		 * If the proposed equality operator is array_eq or record_eq, check
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c:		 * not, array_eq or record_eq would fail at runtime, so we don't want
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c:			!array_element_has_equality(typentry))
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c:		/* As above, make sure array_cmp or record_cmp will succeed */
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c:			!array_element_has_compare(typentry))
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c:		/* As above, make sure array_cmp or record_cmp will succeed */
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c:			!array_element_has_compare(typentry))
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c:		/* As above, make sure array_cmp or record_cmp will succeed */
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c:			!array_element_has_compare(typentry))
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c:		 * As above, make sure hash_array will succeed.  We don't currently
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c:			!array_element_has_hashing(typentry))
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c:	 * for the temp sorting array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c:			/* Accumulate constraints in an array, for sorting below */
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c: * array_element_has_equality and friends are helper routines to check
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c: * whether we should believe that array_eq and related functions will work
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c: * on the given array type or composite type.
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c:array_element_has_equality(TypeCacheEntry *typentry)
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c:		cache_array_element_properties(typentry);
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c:array_element_has_compare(TypeCacheEntry *typentry)
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c:		cache_array_element_properties(typentry);
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c:array_element_has_hashing(TypeCacheEntry *typentry)
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c:		cache_array_element_properties(typentry);
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c:cache_array_element_properties(TypeCacheEntry *typentry)
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.c: * We can borrow the flag bits for array element properties to use for range
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/evtcache.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/evtcache.c:static int	DecodeTextArrayToCString(Datum array, char ***cstringp);
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/evtcache.c:		/* Decode and sort tags array. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/evtcache.c: * Decode text[] to an array of C strings.
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/evtcache.c: * of the logic from deconstruct_array, but it doesn't seem worth the code
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/evtcache.c:DecodeTextArrayToCString(Datum array, char ***cstringp)
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/evtcache.c:	ArrayType  *arr = DatumGetArrayTypeP(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/evtcache.c:		elog(ERROR, "expected 1-D text array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/evtcache.c:	deconstruct_array(arr, TEXTOID, -1, false, 'i', &elems, NULL, &nelems);
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/catcache.c:	/* Switch to the new array. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/catcache.c:	 * If the hash table has become too full, enlarge the buckets array. Quite
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/cache/lsyscache.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/cache/typcache.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/syscache.c:	Add your entry to the cacheinfo[] array below. All cache lists are
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/syscache.c:/* Sorted array of OIDs of tables that have caches on them */
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/syscache.c:/* Sorted array of OIDs of tables and indexes used by caches */
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/syscache.c:					 "SysCacheSize does not match syscache.c's array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/cache/syscache.c:	/* Sort and de-dup OID arrays, so we can use binary search. */
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/cache/evtcache.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 376, "text_to_array_null", 3, false, false, text_to_array_null },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 378, "array_append", 2, false, false, array_append },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 379, "array_prepend", 2, false, false, array_prepend },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 382, "btarraycmp", 2, true, false, btarraycmp },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 383, "array_cat", 2, false, false, array_cat },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 384, "array_to_text_null", 3, false, false, array_to_text_null },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 390, "array_ne", 2, true, false, array_ne },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 391, "array_lt", 2, true, false, array_lt },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 392, "array_gt", 2, true, false, array_gt },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 393, "array_le", 2, true, false, array_le },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 394, "text_to_array", 2, false, false, text_to_array },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 395, "array_to_text", 2, true, false, array_to_text },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 396, "array_ge", 2, true, false, array_ge },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 515, "array_larger", 2, true, false, array_larger },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 516, "array_smaller", 2, true, false, array_smaller },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 626, "hash_array", 1, true, false, hash_array },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 744, "array_eq", 2, true, false, array_eq },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 747, "array_dims", 1, true, false, array_dims },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 748, "array_ndims", 1, true, false, array_ndims },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 750, "array_in", 3, true, false, array_in },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 751, "array_out", 1, true, false, array_out },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 1193, "array_fill", 2, false, false, array_fill },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 1286, "array_fill_with_lower_bounds", 3, false, false, array_fill_with_lower_bounds },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 2091, "array_lower", 2, true, false, array_lower },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 2092, "array_upper", 2, true, false, array_upper },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 2176, "array_length", 2, true, false, array_length },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 2296, "anyarray_in", 1, true, false, anyarray_in },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 2297, "anyarray_out", 1, true, false, anyarray_out },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 2331, "array_unnest", 1, true, true, array_unnest },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 2333, "array_agg_transfn", 2, false, false, array_agg_transfn },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 2334, "array_agg_finalfn", 2, false, false, array_agg_finalfn },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 2400, "array_recv", 3, true, false, array_recv },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 2401, "array_send", 1, true, false, array_send },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 2502, "anyarray_recv", 1, true, false, anyarray_recv },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 2503, "anyarray_send", 1, true, false, anyarray_send },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 2743, "ginarrayextract", 3, true, false, ginarrayextract },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 2744, "ginarrayconsistent", 8, true, false, ginarrayconsistent },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 2747, "arrayoverlap", 2, true, false, arrayoverlap },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 2748, "arraycontains", 2, true, false, arraycontains },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 2749, "arraycontained", 2, true, false, arraycontained },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 2767, "regexp_split_to_array_no_flags", 2, true, false, regexp_split_to_array_no_flags },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 2768, "regexp_split_to_array", 3, true, false, regexp_split_to_array },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 2774, "ginqueryarrayextract", 7, true, false, ginqueryarrayextract },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 2777, "anynonarray_in", 1, true, false, anynonarray_in },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 2778, "anynonarray_out", 1, true, false, anynonarray_out },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3076, "ginarrayextract_2args", 2, true, false, ginarrayextract_2args },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3153, "array_to_json", 1, true, false, array_to_json },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3154, "array_to_json_pretty", 2, true, false, array_to_json_pretty },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3167, "array_remove", 2, false, false, array_remove },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3168, "array_replace", 3, false, false, array_replace },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3179, "array_cardinality", 1, true, false, array_cardinality },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3198, "json_build_array", 1, false, false, json_build_array },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3199, "json_build_array_noargs", 0, false, false, json_build_array_noargs },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3207, "jsonb_array_length", 1, true, false, jsonb_array_length },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3215, "jsonb_array_element", 2, true, false, jsonb_array_element },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3216, "jsonb_array_element_text", 2, true, false, jsonb_array_element_text },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3218, "width_bucket_array", 2, true, false, width_bucket_array },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3219, "jsonb_array_elements", 1, true, true, jsonb_array_elements },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3271, "jsonb_build_array", 1, false, false, jsonb_build_array },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3272, "jsonb_build_array_noargs", 0, false, false, jsonb_build_array_noargs },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3277, "array_position", 2, false, false, array_position },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3278, "array_position_start", 3, false, false, array_position_start },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3279, "array_positions", 2, false, false, array_positions },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3326, "tsvector_to_array", 1, true, false, tsvector_to_array },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3327, "array_to_tsvector", 1, true, false, array_to_tsvector },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3343, "jsonb_delete_array", 2, true, false, jsonb_delete_array },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3465, "jsonb_array_elements_text", 1, true, true, jsonb_array_elements_text },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3584, "binary_upgrade_set_next_array_pg_type_oid", 1, true, false, binary_upgrade_set_next_array_pg_type_oid },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3816, "array_typanalyze", 1, true, false, array_typanalyze },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3817, "arraycontsel", 4, true, false, arraycontsel },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3818, "arraycontjoinsel", 5, true, false, arraycontjoinsel },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3920, "ginarraytriconsistent", 7, true, false, ginarraytriconsistent },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3949, "json_array_element", 2, true, false, json_array_element },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3950, "json_array_element_text", 2, true, false, json_array_element_text },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3955, "json_array_elements", 1, true, true, json_array_elements },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3956, "json_array_length", 1, true, false, json_array_length },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 3969, "json_array_elements_text", 1, true, true, json_array_elements_text },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 4051, "array_agg_array_transfn", 2, false, false, array_agg_array_transfn },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:  { 4052, "array_agg_array_finalfn", 2, false, false, array_agg_array_finalfn },
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.c:     comma after the last field in an array initializer) */
/srvr/z5089358/postgresql-10.4/src/backend/utils/init/postinit.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/init/postinit.c: * pg_split_opts -- split a string of options and append it to an argv array
/srvr/z5089358/postgresql-10.4/src/backend/utils/init/postinit.c: * The caller is responsible for ensuring the argv array is large enough.  The
/srvr/z5089358/postgresql-10.4/src/backend/utils/init/postinit.c:	 * Initialize my entry in the shared-invalidation manager's array of
/srvr/z5089358/postgresql-10.4/src/backend/utils/init/postinit.c:		/* report this backend in the PgBackendStatus array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/init/postinit.c:		/* report this backend in the PgBackendStatus array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/init/postinit.c:	 * see us in the array once they have the lock.  Ordering is important for
/srvr/z5089358/postgresql-10.4/src/backend/utils/init/postinit.c:	/* report this backend in the PgBackendStatus array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/init/miscinit.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/snapmgr.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/snapmgr.c:	 * CurrentSnapshotData's XID arrays have been allocated, and (2) to update
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/snapmgr.c:	 * atomically. So let procarray.c do it.
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/snapmgr.c:	/* We allocate any XID arrays needed in the same palloc block. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/snapmgr.c:	/* setup XID array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/snapmgr.c:	 * Setup subXID array. Don't bother to copy it if it had overflowed,
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/snapmgr.c:	 * don't trouble to check the array elements, just the most critical
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/snapmgr.c:	/* We allocate any XID arrays needed in the same palloc block. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/snapmgr.c:	 * Ignore the SubXID array if it has overflowed, unless the snapshot was
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/snapmgr.c:	/* Copy XID array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/snapmgr.c:	 * Copy SubXID array. Don't bother to copy it if it had overflowed,
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/snapmgr.c:	/* We allocate any XID arrays needed in the same palloc block. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/combocid.c: * real cmin and cmax using a backend-private array, which is managed by
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/combocid.c: * The array and hash table are kept in TopTransactionContext, and are
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/combocid.c: * An array of cmin,cmax pairs, indexed by combo command id.
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/combocid.c: * To convert a combo cid to cmin and cmax, you do a simple array lookup.
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/combocid.c:static int	sizeComboCids = 0;	/* allocated size of array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/combocid.c:/* Initial size of the array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/combocid.c:	 * Create the hash table and array the first time we need to use combo
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/combocid.c:		/* Make array first; existence of hash table asserts array exists */
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/combocid.c:	 * Grow the array if there's not at least one free slot.  We must do this
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/combocid.c:	/* We have to create a new combo cid; we already made room in the array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/tqual.c: * TransactionIdIsInProgress (which looks in the PGXACT array)
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/tqual.c: * MyPgXact->xid in the PGXACT array.  That fixes that problem, but it
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/tqual.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/tqual.c: * and more contention on the PGXACT array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/tqual.c:	 * xip arrays.  Note that this is OK even if we convert a subxact XID to
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/tqual.c:			 * so recheck to avoid an array scan.  No point in rechecking
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/tqual.c:		 * In recovery we store all xids in the subxact array because it is by
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/tqual.c:		 * far the bigger array, and we mostly don't know which xids are
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/tqual.c:		 * top-level and which are subxacts. The xip array is empty.
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/tqual.c:			 * so recheck to avoid an array scan.  No point in rechecking
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/tqual.c: * check whether the transaction id 'xid' is in the pre-sorted array 'xip'.
/srvr/z5089358/postgresql-10.4/src/backend/utils/time/tqual.c:	/* xmax is between [xmin, xmax), check known committed array */
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrtab.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_gin.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/enum.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/enum.c:	/* and build the result array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/enum.c:	result = construct_array(elems, cnt, enumtypoid, sizeof(Oid), true, 'i');
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/date.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c:	deconstruct_array(lexemes, TEXTOID, -1, false, 'i',
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c:	 * Assuming that lexemes array is significantly shorter than tsvector we
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c:					 errmsg("lexeme array may not contain nulls")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c: * Returns lexeme position in TSVector's entry array or -1 if lexeme wasn't
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c: * Internal routine to delete lexemes from TSVector by array of offsets.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c: * int *indices_to_delete -- array of lexeme offsets to delete (modified here!)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c: * int indices_count -- size of that array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c:	 * Sort the filter array to simplify membership checks below.  Also, get
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c: * Delete given array of lexemes from tsvector.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c:	deconstruct_array(lexemes, TEXTOID, -1, false, 'i',
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c:	 * In typical use case array of lexemes to delete is relatively small. So
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c:					 errmsg("lexeme array may not contain nulls")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c: *	   positions: integer array of lexeme positions
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c: *	   weights: char array of weights corresponding to positions
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c:			 * that in two separate arrays.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c:										construct_array(positions, posv->npos, INT2OID, 2, true, 's'));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c:										construct_array(weights, posv->npos, TEXTOID, -1, false, 'i'));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c: * Convert tsvector to array of lexemes.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c:tsvector_to_array(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c:	ArrayType  *array;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c:	array = construct_array(elements, tsin->size, TEXTOID, -1, false, 'i');
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c:	PG_RETURN_POINTER(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c: * Build tsvector from array of lexemes.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c:array_to_tsvector(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c:	deconstruct_array(v, TEXTOID, -1, false, 'i', &dlexemes, &nulls, &nitems);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c:					 errmsg("lexeme array may not contain nulls")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c:	deconstruct_array(weights, CHAROID, 1, true, 'c',
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c:					 errmsg("weight array may not contain nulls")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c:	 * and collapse out any unused array entries.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c: * tsvector.c because array might be longer than MAXENTRYPOS
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c: * is there value 'val' in array or not ?
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c:			/* Sort and make unique array of found positions */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c: * max_npos: maximum possible required size of output position array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c:			/* L array exhausted, so we're done if R_ONLY isn't set */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c:			/* R array exhausted, so we're done if L_ONLY isn't set */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c:				/* Store position, first allocating output array if needed */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c:		/* Let's assert we didn't overrun the array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.c: * negative positions, which wouldn't fit into the WordEntryPos arrays.)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsrank.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsrank.c: * Returns a pointer to a WordEntry's array corresponding to 'item' from
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsrank.c: * Returns a sorted, de-duplicated array of QueryOperands in a query.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsrank.c: * Length of the returned array is stored in *size
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsrank.c:	/* A dummy WordEntryPos array to use when haspos is false */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsrank.c:	/* A dummy WordEntryPos array to use when haspos is false */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsrank.c:				 errmsg("array of weight must be one-dimensional")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsrank.c:				 errmsg("array of weight is too short")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsrank.c:	if (array_contains_nulls(win))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsrank.c:				 errmsg("array of weight must not contain nulls")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/acl.c: * This will not detect equality if the two arrays contain the same items
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/acl.c: * Verify that an ACL array is acceptable (one-dimensional and has no nulls)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/acl.c:				 errmsg("ACL array contains wrong data type")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/acl.c:				 errmsg("ACL arrays must be one-dimensional")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/acl.c:				 errmsg("ACL arrays must not contain null values")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/acl.c: * them, as because we want array equality to work on aclitem arrays, and
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/acl.c: * Update an ACL array to add or remove specified privileges.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/acl.c: *	old_acl: the input ACL array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/acl.c:		/* Adjust array size to be 'num - 1' items */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/acl.c: * Update an ACL array to reflect a change of owner to the parent object
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/acl.c: *	old_acl: the input ACL array (must not be NULL)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/acl.c:	 * the array but set their privilege masks to zero; when we reach such an
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/acl.c:		/* Adjust array size to be 'dst' items */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/acl.c: * *roleids is set to point to a palloc'd array containing distinct OIDs
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/acl.c: * in sorted order.  The length of the array is the function result.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/acl.c:	/* Sort the array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/acl.c:	/* Remove duplicates from the array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/acl.c:	 * We could repalloc the array down to minimum size, but it's hardly worth
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/acl.c: * The allowed privilege names are given as an array of priv_map structs,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/acl.c:		idx[0] = 0;				/* ACL array item index */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/Makefile:OBJS = acl.o amutils.o arrayfuncs.o array_expanded.o array_selfuncs.o \
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/Makefile:	array_typanalyze.o array_userfuncs.o arrayutils.o ascii.o \
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c: * The transition datatype for all these aggregates is a 3-element array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:check_float8_array(ArrayType *transarray, const char *caller, int n)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	 * We expect the input to be an N-element float array; verify that. We
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	 * don't need to use deconstruct_array() since the array data is just
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	 * going to look like a C array of N float8 values.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	if (ARR_NDIM(transarray) != 1 ||
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:		ARR_DIMS(transarray)[0] != n ||
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:		ARR_HASNULL(transarray) ||
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:		ARR_ELEMTYPE(transarray) != FLOAT8OID)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:		elog(ERROR, "%s: expected %d-element float8 array", caller, n);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	return (float8 *) ARR_DATA_PTR(transarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	ArrayType  *transarray1 = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	ArrayType  *transarray2 = PG_GETARG_ARRAYTYPE_P(1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	transvalues1 = check_float8_array(transarray1, "float8_combine", 3);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	transvalues2 = check_float8_array(transarray2, "float8_combine", 3);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	PG_RETURN_ARRAYTYPE_P(transarray1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	ArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	transvalues = check_float8_array(transarray, "float8_accum", 3);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	 * new array with the updated transition data and return it.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:		PG_RETURN_ARRAYTYPE_P(transarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:		result = construct_array(transdatums, 3,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	ArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	transvalues = check_float8_array(transarray, "float4_accum", 3);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	 * new array with the updated transition data and return it.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:		PG_RETURN_ARRAYTYPE_P(transarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:		result = construct_array(transdatums, 3,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	ArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	transvalues = check_float8_array(transarray, "float8_avg", 3);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	ArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	transvalues = check_float8_array(transarray, "float8_var_pop", 3);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	ArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	transvalues = check_float8_array(transarray, "float8_var_samp", 3);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	ArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	transvalues = check_float8_array(transarray, "float8_stddev_pop", 3);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	ArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	transvalues = check_float8_array(transarray, "float8_stddev_samp", 3);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c: * The transition datatype for all these aggregates is a 6-element array of
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	ArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	transvalues = check_float8_array(transarray, "float8_regr_accum", 6);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	 * new array with the updated transition data and return it.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:		PG_RETURN_ARRAYTYPE_P(transarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:		result = construct_array(transdatums, 6,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	ArrayType  *transarray1 = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	ArrayType  *transarray2 = PG_GETARG_ARRAYTYPE_P(1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	transvalues1 = check_float8_array(transarray1, "float8_regr_combine", 6);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	transvalues2 = check_float8_array(transarray2, "float8_regr_combine", 6);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	PG_RETURN_ARRAYTYPE_P(transarray1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	ArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	transvalues = check_float8_array(transarray, "float8_regr_sxx", 6);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	ArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	transvalues = check_float8_array(transarray, "float8_regr_syy", 6);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	ArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	transvalues = check_float8_array(transarray, "float8_regr_sxy", 6);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	ArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	transvalues = check_float8_array(transarray, "float8_regr_avgx", 6);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	ArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	transvalues = check_float8_array(transarray, "float8_regr_avgy", 6);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	ArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	transvalues = check_float8_array(transarray, "float8_covar_pop", 6);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	ArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	transvalues = check_float8_array(transarray, "float8_covar_samp", 6);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	ArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	transvalues = check_float8_array(transarray, "float8_corr", 6);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	ArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	transvalues = check_float8_array(transarray, "float8_regr_r2", 6);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	ArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	transvalues = check_float8_array(transarray, "float8_regr_slope", 6);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	ArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.c:	transvalues = check_float8_array(transarray, "float8_regr_intercept", 6);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/rangetypes.c:		 * object, for the same reasons that arrays and records can't contain
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/rangetypes.c:		 * whole range object if necessary.  But, unlike arrays, we do allow
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/datetime.c: * field[] - pointers to field strings are returned in this array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/datetime.c: * ftype[] - field type indicators are returned in this array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/datetime.c: * maxfields - dimensions of the above two arrays
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/datetime.c: * to create the final array of timezone tokens.  The argument array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/datetime.c:	/* Space for fixed fields and datetkn array */
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/enum.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:	JSONBTYPE_ARRAY,			/* array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:static void jsonb_in_array_start(void *pstate);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:static void jsonb_in_array_end(void *pstate);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:static void array_to_jsonb_internal(Datum array, JsonbInState *result);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:		result = "array";
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:		 * A root scalar is stored as an array of one element, so we get the
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:		 * array and then its first (and only) member.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:	sem.array_start = jsonb_in_array_start;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:	sem.array_end = jsonb_in_array_end;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:jsonb_in_array_start(void *pstate)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:jsonb_in_array_end(void *pstate)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:		va.val.array.rawScalar = true;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:		va.val.array.nElems = 1;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:				if (!v.val.array.rawScalar)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:	 * timestamp types, booleans, array and composite types, json and jsonb,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:			/* Check for arrays and composites */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:				 errmsg("key value must be scalar, not array, composite, or json")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:				array_to_jsonb_internal(val, result);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:					sem.array_start = jsonb_in_array_start;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:					sem.array_end = jsonb_in_array_end;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:		va.val.array.rawScalar = true;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:		va.val.array.nElems = 1;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c: * Process a single dimension of an array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims, Datum *vals,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:			array_dim_to_jsonb(result, dim + 1, ndims, dims, vals, nulls,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c: * Turn an array into JSON.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:array_to_jsonb_internal(Datum array, JsonbInState *result)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:	ArrayType  *v = DatumGetArrayTypeP(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:	deconstruct_array(v, element_type, typlen, typbyval,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:	array_dim_to_jsonb(result, 0, ndim, dim, elements, nulls, &count, tcategory,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c: * SQL function jsonb_build_array(variadic "any")
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:jsonb_build_array(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:	/* build argument values to build the array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c: * degenerate case of jsonb_build_array where it gets 0 arguments.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:jsonb_build_array_noargs(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c: * take a one or two dimensional array of text as name value pairs
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:	ArrayType  *in_array = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:	int			ndims = ARR_NDIM(in_array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:			if ((ARR_DIMS(in_array)[0]) % 2)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:						 errmsg("array must have even number of elements")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:			if ((ARR_DIMS(in_array)[1]) != 2)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:						 errmsg("array must have two columns")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:					 errmsg("wrong number of array subscripts")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:	deconstruct_array(in_array,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c: * take separate name and value arrays of text to construct a jsonb object
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:	ArrayType  *key_array = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:	ArrayType  *val_array = PG_GETARG_ARRAYTYPE_P(1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:	int			nkdims = ARR_NDIM(key_array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:	int			nvdims = ARR_NDIM(val_array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:				 errmsg("wrong number of array subscripts")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:	deconstruct_array(key_array,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:	deconstruct_array(val_array,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:				 errmsg("mismatched array dimensions")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:				if (v.val.array.rawScalar)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:	 * values, just add the final array end marker.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:				if (!v.val.array.rawScalar)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.c:				if (v.val.array.rawScalar)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/levenshtein.c: * the entire array in memory at once, we'll just use two arrays of size
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/levenshtein.c: * m+1 for storing accumulated values. At each step one array represents
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/levenshtein.c: * array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/levenshtein.c:	 * multi-byte characters, we still build the array, so that the fast-path
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/levenshtein.c:	 * needn't deal with the case where the array hasn't been initialized.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/levenshtein.c:	/* Previous and current rows of notional array. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/levenshtein.c:	/* Loop through rows of the notional array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/levenshtein.c:		 * of the array.  The inner loop will read prev[stop_column], so we
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_op.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * array_selfuncs.c
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: *	  Functions for selectivity estimation of array operators
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: *	  src/backend/utils/adt/array_selfuncs.c
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:static Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:static Selectivity mcelem_array_selec(ArrayType *array,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:static Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:								   Datum *array_data, int nitems,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:static Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:							 Datum *array_data, int nitems,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * scalararraysel_containment
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: *		Estimate selectivity of ScalarArrayOpExpr via array containment.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * If we have const =/<> ANY/ALL (array_var) then we can estimate the
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * selectivity as though this were an array containment operator,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * array_var op ARRAY[const].
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * scalararraysel() has already verified that the ScalarArrayOpExpr's operator
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * is the array element type's default equality or inequality operator, and
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:scalararraysel_containment(PlannerInfo *root,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:	/* Get array element stats for var, if available */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:		/* MCELEM will be an array of same type as element */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:				selec = mcelem_array_contain_overlap_selec(sslot.values,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:				selec = mcelem_array_contained_selec(sslot.values,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:				selec = mcelem_array_contain_overlap_selec(NULL, 0,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:				selec = mcelem_array_contained_selec(NULL, 0,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:			selec = mcelem_array_contain_overlap_selec(NULL, 0,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:			selec = mcelem_array_contained_selec(NULL, 0,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * arraycontsel -- restriction selectivity for array @>, &&, <@ operators
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:arraycontsel(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:	 * Const to be an array with same element type as column, else we can't do
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:		selec = calc_arraycontsel(&vardata, ((Const *) other)->constvalue,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * arraycontjoinsel -- join selectivity for array @>, &&, <@ operators
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:arraycontjoinsel(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * Calculate selectivity for "arraycolumn @> const", "arraycolumn && const"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * or "arraycolumn <@ const" based on the statistics
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * to be used; we then pass the problem on to mcelem_array_selec().
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:calc_arraycontsel(VariableStatData *vardata, Datum constval,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:	ArrayType  *array;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:	 * The caller made sure the const is an array with same element type, so
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:	array = DatumGetArrayTypeP(constval);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:		/* MCELEM will be an array of same type as column */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:			 * For "array <@ const" case we also need histogram of distinct
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:			/* Use the most-common-elements slot for the array Var. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:			selec = mcelem_array_selec(array, typentry,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:			selec = mcelem_array_selec(array, typentry,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:		selec = mcelem_array_selec(array, typentry,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:	if (PointerGetDatum(array) != constval)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:		pfree(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * This function just deconstructs and sorts the array constant's contents,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * and then passes the problem on to mcelem_array_contain_overlap_selec or
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * mcelem_array_contained_selec depending on the operator.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:mcelem_array_selec(ArrayType *array, TypeCacheEntry *typentry,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:	 * Prepare constant array data for sorting.  Sorting lets us find unique
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:	 * elements and efficiently merge with the MCELEM array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:	deconstruct_array(array,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:		selec = mcelem_array_contain_overlap_selec(mcelem, nmcelem,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:		selec = mcelem_array_contained_selec(mcelem, nmcelem,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:		elog(ERROR, "arraycontsel called for unrecognized operator %u",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * the array column's MCELEM statistics slot, or are NULL/0 if stats are
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * not available.  array_data (of length nitems) is the constant's elements.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * Both the mcelem and array_data arrays are assumed presorted according
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * fraction of nonempty arrays in the column.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:								   Datum *array_data, int nitems,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:		 * be decreased with each element of constant array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:		 * be increased with each element of constant array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:	/* Scan mcelem and array in parallel. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:		/* Ignore any duplicates in the array data. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:			element_compare(&array_data[i - 1], &array_data[i], cmpfunc) == 0)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:		/* Find the smallest MCELEM >= this array item. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:			match = find_next_mcelem(mcelem, nmcelem, array_data[i],
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:												  &array_data[i],
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:			/* MCELEM matches the array item; use its frequency. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * the array column's MCELEM statistics slot, or are NULL/0 if stats are
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * not available.  array_data (of length nitems) is the constant's elements.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * hist (of length nhist) is from the array column's DECHIST statistics slot,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * Both the mcelem and array_data arrays are assumed presorted according
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * that assumption.  For example, in a set of 11-element integer arrays having
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * the array distinct element count distribution here.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: *	  probabilities to be equal to frequencies of array elements.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:mcelem_array_contained_selec(Datum *mcelem, int nmcelem,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:							 Datum *array_data, int nitems,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:	 * Grab some of the summary statistics that compute_array_stats() stores:
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:	 * elem_selec is array of estimated frequencies for elements in the
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:	/* Scan mcelem and array in parallel. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:		/* Ignore any duplicates in the array data. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:			element_compare(&array_data[i - 1], &array_data[i], cmpfunc) == 0)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:											  &array_data[i],
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:			/* MCELEM matches the array item. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:	 * array, finish walking it to complete calculation of "rest" and "mult".
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:	 * only the most-common elements of the constant array.  To make the
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c:	 * up with the elements of array_data[], but we don't care.)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * Returns a palloc'd array of n+1 entries, with array[k] being the
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * Returns a palloc'd array of size m+1.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.c: * find_next_mcelem binary-searches a most common elements array, starting
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_selfuncs.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/name.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/name.c:	ArrayType  *array;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/name.c:	array = construct_array(names, i,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/name.c:	PG_RETURN_POINTER(array);
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ri_triggers.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	JSON_PARSE_ARRAY_NEXT,		/* saw array element, expecting ',' or ']' */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	JSONTYPE_ARRAY,				/* array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:static void parse_array_element(JsonLexContext *lex, JsonSemAction *sem);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:static void parse_array(JsonLexContext *lex, JsonSemAction *sem);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:static void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:static void array_to_json_internal(Datum array, StringInfo result,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:			parse_array(lex, sem);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c: * json_count_array_elements
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c: * Returns number of array elements in lex context at start of array token
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c: * until end of array token at same nesting level.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c: * Designed to be called from array_start routines.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:json_count_array_elements(JsonLexContext *lex)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:			parse_array_element(&copylex, &nullSemAction);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c: *	  - array  ( [ ] )
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c: *	  - array element
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	 * object or array.  Note: in user-facing docs and error messages, we
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:			parse_array(lex, sem);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:parse_array_element(JsonLexContext *lex, JsonSemAction *sem)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	json_aelem_action astart = sem->array_element_start;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	json_aelem_action aend = sem->array_element_end;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	/* an array element is any object, array or scalar */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:			parse_array(lex, sem);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:parse_array(JsonLexContext *lex, JsonSemAction *sem)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	 * an array is a possibly empty sequence of array elements, separated by
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	json_struct_action astart = sem->array_start;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	json_struct_action aend = sem->array_end;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	 * Data inside an array is at a higher nesting level than the array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	 * for the array start and restore it before we call the routine for the
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	 * array end.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:		parse_array_element(lex, sem);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:			parse_array_element(lex, sem);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:						 errdetail("Expected array element or \"]\", but found \"%s\".",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	 * timestamp types, array and composite types, booleans, and non-builtin
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:			/* Check for arrays and composites */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:				 errmsg("key value must be scalar, not array, composite, or json")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:			array_to_json_internal(val, result, false);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c: * Process a single dimension of an array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:array_dim_to_json(StringInfo result, int dim, int ndims, int *dims, Datum *vals,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:			 * Do we want line feeds on inner dimensions of arrays? For now
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:			array_dim_to_json(result, dim + 1, ndims, dims, vals, nulls,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c: * Turn an array into JSON.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:array_to_json_internal(Datum array, StringInfo result, bool use_line_feeds)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	ArrayType  *v = DatumGetArrayTypeP(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	deconstruct_array(v, element_type, typlen, typbyval,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	array_dim_to_json(result, 0, ndim, dim, elements, nulls, &count, tcategory,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c: * SQL function array_to_json(row)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:array_to_json(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	Datum		array = PG_GETARG_DATUM(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	array_to_json_internal(array, result, false);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c: * SQL function array_to_json(row, prettybool)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:array_to_json_pretty(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	Datum		array = PG_GETARG_DATUM(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	array_to_json_internal(array, result, use_line_feeds);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	Datum		array = PG_GETARG_DATUM(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	composite_to_json(array, result, false);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	Datum		array = PG_GETARG_DATUM(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	composite_to_json(array, result, use_line_feeds);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c: * aggregate input column as a json array value.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	 * The transition type for array_agg() is declared to be "internal", which
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	/* Else return state with appropriate array terminator added */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c: * SQL function json_build_array(variadic "any")
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:json_build_array(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	/* fetch argument values to build the array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c: * degenerate case of json_build_array where it gets 0 arguments.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:json_build_array_noargs(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c: * take a one or two dimensional array of text as key/value pairs
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	ArrayType  *in_array = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	int			ndims = ARR_NDIM(in_array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:			if ((ARR_DIMS(in_array)[0]) % 2)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:						 errmsg("array must have even number of elements")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:			if ((ARR_DIMS(in_array)[1]) != 2)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:						 errmsg("array must have two columns")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:					 errmsg("wrong number of array subscripts")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	deconstruct_array(in_array,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c: * take separate key and value arrays of text to construct a json object
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	ArrayType  *key_array = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	ArrayType  *val_array = PG_GETARG_ARRAYTYPE_P(1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	int			nkdims = ARR_NDIM(key_array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	int			nvdims = ARR_NDIM(val_array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:				 errmsg("wrong number of array subscripts")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	deconstruct_array(key_array,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:	deconstruct_array(val_array,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:				 errmsg("mismatched array dimensions")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c: * "object", "array", "string", "number", "boolean", and "null".
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.c:			type = "array";
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsquery_op.c:	/* Extract the query terms into arrays */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsquery_op.c:	/* Sort and remove duplicates from both arrays */
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/float.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/amutils.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/objfiles.txt:src/backend/utils/adt/acl.o src/backend/utils/adt/amutils.o src/backend/utils/adt/arrayfuncs.o src/backend/utils/adt/array_expanded.o src/backend/utils/adt/array_selfuncs.o src/backend/utils/adt/array_typanalyze.o src/backend/utils/adt/array_userfuncs.o src/backend/utils/adt/arrayutils.o src/backend/utils/adt/ascii.o src/backend/utils/adt/bool.o src/backend/utils/adt/cash.o src/backend/utils/adt/char.o src/backend/utils/adt/date.o src/backend/utils/adt/datetime.o src/backend/utils/adt/datum.o src/backend/utils/adt/dbsize.o src/backend/utils/adt/domains.o src/backend/utils/adt/encode.o src/backend/utils/adt/enum.o src/backend/utils/adt/expandeddatum.o src/backend/utils/adt/float.o src/backend/utils/adt/format_type.o src/backend/utils/adt/formatting.o src/backend/utils/adt/genfile.o src/backend/utils/adt/geo_ops.o src/backend/utils/adt/geo_selfuncs.o src/backend/utils/adt/geo_spgist.o src/backend/utils/adt/inet_cidr_ntop.o src/backend/utils/adt/inet_net_pton.o src/backend/utils/adt/int.o src/backend/utils/adt/int8.o src/backend/utils/adt/json.o src/backend/utils/adt/jsonb.o src/backend/utils/adt/jsonb_gin.o src/backend/utils/adt/jsonb_op.o src/backend/utils/adt/jsonb_util.o src/backend/utils/adt/jsonfuncs.o src/backend/utils/adt/like.o src/backend/utils/adt/lockfuncs.o src/backend/utils/adt/mac.o src/backend/utils/adt/mac8.o src/backend/utils/adt/misc.o src/backend/utils/adt/nabstime.o src/backend/utils/adt/name.o src/backend/utils/adt/network.o src/backend/utils/adt/network_gist.o src/backend/utils/adt/network_selfuncs.o src/backend/utils/adt/network_spgist.o src/backend/utils/adt/numeric.o src/backend/utils/adt/numutils.o src/backend/utils/adt/oid.o src/backend/utils/adt/oracle_compat.o src/backend/utils/adt/orderedsetaggs.o src/backend/utils/adt/pg_locale.o src/backend/utils/adt/pg_lsn.o src/backend/utils/adt/pg_upgrade_support.o src/backend/utils/adt/pgstatfuncs.o src/backend/utils/adt/pseudotypes.o src/backend/utils/adt/quote.o src/backend/utils/adt/rangetypes.o src/backend/utils/adt/rangetypes_gist.o src/backend/utils/adt/rangetypes_selfuncs.o src/backend/utils/adt/rangetypes_spgist.o src/backend/utils/adt/rangetypes_typanalyze.o src/backend/utils/adt/regexp.o src/backend/utils/adt/regproc.o src/backend/utils/adt/ri_triggers.o src/backend/utils/adt/rowtypes.o src/backend/utils/adt/ruleutils.o src/backend/utils/adt/selfuncs.o src/backend/utils/adt/tid.o src/backend/utils/adt/timestamp.o src/backend/utils/adt/trigfuncs.o src/backend/utils/adt/tsginidx.o src/backend/utils/adt/tsgistidx.o src/backend/utils/adt/tsquery.o src/backend/utils/adt/tsquery_cleanup.o src/backend/utils/adt/tsquery_gist.o src/backend/utils/adt/tsquery_op.o src/backend/utils/adt/tsquery_rewrite.o src/backend/utils/adt/tsquery_util.o src/backend/utils/adt/tsrank.o src/backend/utils/adt/tsvector.o src/backend/utils/adt/tsvector_op.o src/backend/utils/adt/tsvector_parser.o src/backend/utils/adt/txid.o src/backend/utils/adt/uuid.o src/backend/utils/adt/varbit.o src/backend/utils/adt/varchar.o src/backend/utils/adt/varlena.o src/backend/utils/adt/version.o src/backend/utils/adt/windowfuncs.o src/backend/utils/adt/xid.o src/backend/utils/adt/xml.o
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsrank.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/int.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/rangetypes_selfuncs.c: * Binary search on an array of range bounds. Returns greatest index of range
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/rangetypes_selfuncs.c: * bound in array which is less(less or equal) than given range bound. If all
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/rangetypes_selfuncs.c: * range bounds in array are greater or equal(greater) than given range bound,
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/name.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayutils.c: * arrayutils.c
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayutils.c: *	  This file contains some support routines required for array functions.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayutils.c: *	  src/backend/utils/adt/arrayutils.c
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayutils.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayutils.c: * Same, but subscripts are assumed 0-based, and use a scale array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayutils.c: * instead of raw dimension data (see mda_get_prod to create scale array)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayutils.c: * Convert array dimensions into number of elements
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayutils.c: * We limit array sizes to at most about a quarter billion elements,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayutils.c: * places --- for instance when palloc'ing Datum arrays.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayutils.c:					 errmsg("array size exceeds the maximum allowed (%d)",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayutils.c:					 errmsg("array size exceeds the maximum allowed (%d)",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayutils.c:				 errmsg("array size exceeds the maximum allowed (%d)",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayutils.c: * Compute ranges (sub-array dimensions) for an array slice
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayutils.c: * Compute products of array dimensions, ie, scale factors for subscripts
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayutils.c: * From products of whole-array dimensions and spans of a sub-array,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayutils.c: * compute offset distances needed to step through subarray within array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayutils.c: * ArrayGetIntegerTypmods: verify that argument is a 1-D cstring array,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayutils.c: * and get the contents converted to integers.  Returns a palloc'd array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayutils.c:				 errmsg("typmod array must be type cstring[]")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayutils.c:				 errmsg("typmod array must be one-dimensional")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayutils.c:	if (array_contains_nulls(arr))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayutils.c:				 errmsg("typmod array must not contain nulls")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayutils.c:	deconstruct_array(arr, CSTRINGOID,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_op.c:	 * string elements in arrays.  In particular, we do not match non-string
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_op.c:	deconstruct_array(keys, TEXTOID, -1, false, 'i', &key_datums, &key_nulls,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_op.c:	deconstruct_array(keys, TEXTOID, -1, false, 'i', &key_datums, &key_nulls,
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayutils.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/orderedsetaggs.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/orderedsetaggs.c: * Support code for handling arrays of percentiles
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/orderedsetaggs.c:	int			idx;			/* index of this item in original array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/orderedsetaggs.c: * Construct array showing which rows to sample for percentiles.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/orderedsetaggs.c:			/* dummy entry for any NULL in array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/orderedsetaggs.c:	 * The parameter array wasn't necessarily in sorted order, but we need to
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/orderedsetaggs.c:	/* Deconstruct the percentile-array input */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/orderedsetaggs.c:	deconstruct_array(param, FLOAT8OID,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/orderedsetaggs.c:		PG_RETURN_POINTER(construct_empty_array(osastate->qstate->sortColType));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/orderedsetaggs.c:	 * Start by dealing with any nulls in the param array - those are sorted
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/orderedsetaggs.c:	 * We could clean up the tuplesort object after forming the array, but
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/orderedsetaggs.c:	/* We make the output array the same shape as the input */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/orderedsetaggs.c:	PG_RETURN_POINTER(construct_md_array(result_datum, result_isnull,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/orderedsetaggs.c:	/* Deconstruct the percentile-array input */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/orderedsetaggs.c:	deconstruct_array(param, FLOAT8OID,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/orderedsetaggs.c:		PG_RETURN_POINTER(construct_empty_array(osastate->qstate->sortColType));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/orderedsetaggs.c:	 * Start by dealing with any nulls in the param array - those are sorted
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/orderedsetaggs.c:	 * We could clean up the tuplesort object after forming the array, but
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/orderedsetaggs.c:	/* We make the output array the same shape as the input */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/orderedsetaggs.c:	PG_RETURN_POINTER(construct_md_array(result_datum, result_isnull,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_parser.c: * *pos_ptr		pointer to a palloc'd array of positions and weights
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_parser.c: *				the caller is responsible for pfreeing the array.
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector_op.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pseudotypes.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pseudotypes.c: * anyarray_in		- input routine for pseudo-type ANYARRAY.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pseudotypes.c:anyarray_in(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pseudotypes.c:			 errmsg("cannot accept a value of type %s", "anyarray")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pseudotypes.c: * anyarray_out		- output routine for pseudo-type ANYARRAY.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pseudotypes.c: * We may as well allow this, since array_out will in fact work.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pseudotypes.c:anyarray_out(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pseudotypes.c:	return array_out(fcinfo);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pseudotypes.c: * anyarray_recv		- binary input routine for pseudo-type ANYARRAY.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pseudotypes.c: * XXX this could actually be made to work, since the incoming array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pseudotypes.c:anyarray_recv(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pseudotypes.c:			 errmsg("cannot accept a value of type %s", "anyarray")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pseudotypes.c: * anyarray_send		- binary output routine for pseudo-type ANYARRAY.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pseudotypes.c: * We may as well allow this, since array_send will in fact work.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pseudotypes.c:anyarray_send(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pseudotypes.c:	return array_send(fcinfo);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pseudotypes.c:PSEUDOTYPE_DUMMY_IO_FUNCS(anynonarray);
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/lockfuncs.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/rangetypes_typanalyze.c: * single array of ranges. This has the same shape as the histogram that
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/rangetypes_typanalyze.c: * in the array is a valid range, even though the lower and upper bounds
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/rangetypes_typanalyze.c:			 * Even when we don't create the histogram, store an empty array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/network_selfuncs.c: * and histogram arrays.  To keep the runtime from getting out of hand when
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/network_selfuncs.c: * values considered to 1024 (MAX_CONSIDERED_ELEMS).  For the MCV arrays, this
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/network_selfuncs.c: * For the histogram arrays, we decimate; that is consider only every k'th
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/network_selfuncs.c: * iterate over the histogram arrays.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/oracle_compat.c:			 * In the multibyte-encoding case, build arrays of pointers to
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pg_locale.c:				 errmsg_internal("strxfrm(), in locale \"%s\", writes past the specified array length",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/oid.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/oid.c: * construct oidvector given a raw array of Oids
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/oid.c:	 * Attach standard array header.  For historical reasons, we set the index
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/oid.c:	 * Normally one would call array_recv() using DirectFunctionCall3, but
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/oid.c:	 * that does not work since array_recv wants to cache some data using
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/oid.c:	result = (oidvector *) DatumGetPointer(array_recv(&locfcinfo));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/oid.c:	return array_send(fcinfo);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/lockfuncs.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/lockfuncs.c: * pg_blocking_pids - produce an array of the PIDs blocking given PID
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/lockfuncs.c:	Datum	   *arrayelems;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/lockfuncs.c:	int			narrayelems;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/lockfuncs.c:	arrayelems = (Datum *) palloc(lockData->nlocks * sizeof(Datum));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/lockfuncs.c:	narrayelems = 0;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/lockfuncs.c:		 * Locate the blocked proc's own entry in the LockInstanceData array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/lockfuncs.c:			arrayelems[narrayelems++] = Int32GetDatum(instance->leaderPid);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/lockfuncs.c:	/* Assert we didn't overrun arrayelems[] */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/lockfuncs.c:	Assert(narrayelems <= lockData->nlocks);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/lockfuncs.c:	/* Construct array, using hardwired knowledge about int4 type */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/lockfuncs.c:	PG_RETURN_ARRAYTYPE_P(construct_array(arrayelems, narrayelems,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/lockfuncs.c: * pg_safe_snapshot_blocking_pids - produce an array of the PIDs blocking
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/lockfuncs.c:	/* Convert int array to Datum array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/lockfuncs.c:	/* Construct array, using hardwired knowledge about int4 type */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/lockfuncs.c:	PG_RETURN_ARRAYTYPE_P(construct_array(blocker_datums, num_blockers,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/lockfuncs.c:	/* Validate the passed-in array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/lockfuncs.c:	if (array_contains_nulls(interesting_pids_a))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/lockfuncs.c:		elog(ERROR, "array must not contain nulls");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/lockfuncs.c:	Assert(!array_contains_nulls(blocking_pids_a));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/lockfuncs.c:	 * "arrayoverlaps" here, because it would lead to cache lookups and one of
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/lockfuncs.c:	 * theory check the resulting array of blocker PIDs against the
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/timestamp.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/timestamp.c: * The transition datatype for this aggregate is a 2-element array of
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/timestamp.c:	ArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/timestamp.c:	deconstruct_array(transarray,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/timestamp.c:		elog(ERROR, "expected 2-element interval array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/timestamp.c:	result = construct_array(transdatums, 2,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/timestamp.c:	ArrayType  *transarray1 = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/timestamp.c:	ArrayType  *transarray2 = PG_GETARG_ARRAYTYPE_P(1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/timestamp.c:	deconstruct_array(transarray1,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/timestamp.c:		elog(ERROR, "expected 2-element interval array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/timestamp.c:	deconstruct_array(transarray2,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/timestamp.c:		elog(ERROR, "expected 2-element interval array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/timestamp.c:	result = construct_array(transdatums1, 2,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/timestamp.c:	ArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/timestamp.c:	deconstruct_array(transarray,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/timestamp.c:		elog(ERROR, "expected 2-element interval array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/timestamp.c:	result = construct_array(transdatums, 2,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/timestamp.c:	ArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/timestamp.c:	deconstruct_array(transarray,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/timestamp.c:		elog(ERROR, "expected 2-element interval array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varchar.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c: * JOIN, so we need a separate new_colnames[] array for printing purposes.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	 * colnames is an array containing column aliases to use for columns that
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	 * This array can be directly indexed by varattno to get a Var's name.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	 * of the child's colnames array.  So at that stage, NULL entries in this
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	 * array just mean that no name has been preassigned, not necessarily that
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	int			num_cols;		/* length of colnames[] array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	char	  **colnames;		/* array of C strings and NULLs */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	 * new_colnames is an array containing column aliases to use for columns
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	 * alias list for the RTE.  This array does not include dropped columns,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	 * RTE, we never actually print this array, but we must compute it anyway
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	 * parallel array is_new_col marks which of these columns are new since
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	int			num_new_cols;	/* length of new_colnames[] array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	char	  **new_colnames;	/* array of C strings */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	bool	   *is_new_col;		/* array of bool flags */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	 * leftattnos and rightattnos are arrays with one entry per existing
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:static void decompile_column_index_array(Datum column_index_array, Oid relId,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:static void expand_colnames_array_to(deparse_columns *colinfo, int n);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c: * NULL then it points to an array of exclusion operator OIDs.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:		elog(ERROR, "stxkind is not a 1-D char array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:				decompile_column_index_array(val, conForm->conrelid, &buf);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:				decompile_column_index_array(val, conForm->confrelid, &buf);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:				decompile_column_index_array(val, conForm->conrelid, &buf);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:				deconstruct_array(DatumGetArrayTypeP(val),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:decompile_column_index_array(Datum column_index_array, Oid relId,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	/* Extract data from array of int16 */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	deconstruct_array(DatumGetArrayTypeP(column_index_array),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:			d = array_ref(a, 1, &i,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:						  -1 /* varlenarray */ ,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:				 * into the proconfig array; we mustn't re-quote them or we'll
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:					expand_colnames_array_to(leftcolinfo, leftattnos[i]);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:					expand_colnames_array_to(rightcolinfo, rightattnos[i]);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:			expand_colnames_array_to(colinfo, list_length(j->usingClause));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:					expand_colnames_array_to(leftcolinfo, leftattnos[i]);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:					expand_colnames_array_to(rightcolinfo, rightattnos[i]);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	 * columns.  We put NULL into the array for a dropped column.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	expand_colnames_array_to(colinfo, ncolumns);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	 * Make sufficiently large new_colnames and is_new_col arrays, too.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	 * colname_is_unique will not consult that array, which is fine because it
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	 * colinfo->colnames and colinfo->new_colnames.  The former array has NULL
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	 * Set correct length for new_colnames[] array.  (Note: if columns have
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	expand_colnames_array_to(colinfo, noldcolumns);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	 * now, and create storage for the new_colnames and is_new_col arrays.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	 * Generating the new_colnames array is a bit tricky since any new columns
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	 * the leftattnos and rightattnos arrays plus the input is_new_col arrays.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	 * If we're building a new_colnames array, check that too (this will be
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c: * expand_colnames_array_to: make colinfo->colnames at least n items long
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c: * Any added array entries are initialized to zero.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:expand_colnames_array_to(deparse_columns *colinfo, int n)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	/* Initialize result arrays with zeroes */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:				 * FieldStore, ie, we are assigning to an element of an array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:				 * format "array[subscripts] := refassgnexpr".  This is not
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:					/* Just an ordinary array fetch, so print subscripts */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:				 * be meant as a scalar sub-SELECT yielding an array value to
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:				ArrayExpr  *arrayexpr = (ArrayExpr *) node;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:				get_rule_expr((Node *) arrayexpr->elements, context, true);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:				 * If the array isn't empty, we assume its elements are
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:				 * need an explicit coercion to the array type.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:				if (arrayexpr->elements == NIL)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:									 format_type_with_typemod(arrayexpr->array_typeid, -1));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c: * processIndirection - take care of array and subfield assignment
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	 * be a FieldStore or array assignment, back up to the CoerceToDomain.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	 * variadic-array argument.  Note that this is always the case for
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	 * In principle, if VARIADIC wasn't originally specified and the array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:	 * actual argument is deconstructable, we could print the array elements
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:		deconstruct_array(DatumGetArrayTypeP(reloptions),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ruleutils.c:			 * Each array element should have the form name=value.  If the "="
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pseudotypes.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c: * array_userfuncs.c
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c: *	  Misc user-visible array support functions
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c: *	  src/backend/utils/adt/array_userfuncs.c
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:static Datum array_position_common(FunctionCallInfo fcinfo);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c: * fetch_array_arg_replace_nulls
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c: * Fetch an array-valued argument in expanded form; if it's null, construct an
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c: * empty array value of the proper data type.  Also cache basic element type
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c: * they cannot leave the array in a corrupt state.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c: * expanded array is allocated in the aggregate state context, so as to save
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:fetch_array_arg_replace_nulls(FunctionCallInfo fcinfo, int argno)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	/* Now collect the array value */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:		/* We have to look up the array type and element type */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:					 errmsg("input data type is not an array")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:		eah = construct_empty_expanded_array(element_type,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c: * array_append :
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c: *		push an element onto the end of a one-dimensional array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:array_append(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	eah = fetch_array_arg_replace_nulls(fcinfo, 0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:				 errmsg("argument must be empty or one-dimensional array")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	result = array_set_element(EOHPGetRWDatum(&eah->hdr),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c: * array_prepend :
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c: *		push an element onto the front of a one-dimensional array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:array_prepend(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	eah = fetch_array_arg_replace_nulls(fcinfo, 1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:				 errmsg("argument must be empty or one-dimensional array")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	result = array_set_element(EOHPGetRWDatum(&eah->hdr),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c: * array_cat :
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c: *		concatenate two nD arrays to form an nD array, or
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c: *		push an (n-1)D array onto the end of an nD array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:array_cat(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	/* Concatenating a null array is a no-op, just return the other input */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:				 errmsg("cannot concatenate incompatible arrays"),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	 * 1) one empty array, and one non-empty array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	 * 2) both arrays empty
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	 * 3) two arrays with ndims1 == ndims2
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	 * short circuit - if one input array is empty, and the other is not, we
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:				 errmsg("cannot concatenate incompatible arrays"),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	/* get argument array details */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:		 * resulting array is made up of the elements (possibly arrays
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:		 * themselves) of the input argument arrays
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:						 errmsg("cannot concatenate incompatible arrays"),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:		 * resulting array has the second argument as the outer array, with
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:		/* increment number of elements in outer array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:						 errmsg("cannot concatenate incompatible arrays"),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:		 * resulting array has the first argument as the outer array, with the
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:		/* increment number of elements in outer array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:						 errmsg("cannot concatenate incompatible arrays"),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	/* build the result array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:		array_bitmap_copy(ARR_NULLBITMAP(result), 0,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:		array_bitmap_copy(ARR_NULLBITMAP(result), nitems1,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c: * ARRAY_AGG(anynonarray) aggregate function
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:array_agg_transfn(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	 * valid array element type, because the parser would have verified that
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:		elog(ERROR, "array_agg_transfn called in non-aggregate context");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	 * The transition type for array_agg() is declared to be "internal", which
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:array_agg_finalfn(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c: * ARRAY_AGG(anyarray) aggregate function
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:array_agg_array_transfn(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	 * valid array type, because the parser would have verified that while
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:		elog(ERROR, "array_agg_array_transfn called in non-aggregate context");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	 * The transition type for array_agg() is declared to be "internal", which
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:array_agg_array_finalfn(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c: * array_position, array_position_start :
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c: *			return the offset of a value in an array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:array_position(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	return array_position_common(fcinfo);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:array_position_start(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	return array_position_common(fcinfo);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c: * array_position_common
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c: *		Common code for array_position and array_position_start
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:array_position_common(FunctionCallInfo fcinfo)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	ArrayType  *array;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	ArrayIterator array_iterator;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	array = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	element_type = ARR_ELEMTYPE(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	 * We refuse to search for elements in multi-dimensional arrays, since we
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	 * have no good way to report the element's location in the array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	if (ARR_NDIM(array) > 1)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:				 errmsg("searching for elements in multidimensional arrays is not supported")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:		/* fast return when the array doesn't have nulls */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:		if (!array_contains_nulls(array))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	position = (ARR_LBOUND(array))[0] - 1;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:		position_min = (ARR_LBOUND(array))[0];
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	 * We arrange to look up type info for array_create_iterator only once per
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	/* Examine each array element until we find a match. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	array_iterator = array_create_iterator(array, 0, my_extra);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	while (array_iterate(array_iterator, &value, &isnull))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:		 * Can't look at the array element's value if it's null; but if we
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	array_free_iterator(array_iterator);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	PG_FREE_IF_COPY(array, 0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c: * array_positions :
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c: *			return an array of positions of a value in an array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c: * the input array is NULL.  When the value is not found in the array, returns
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c: * an empty array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:array_positions(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	ArrayType  *array;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	ArrayIterator array_iterator;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	array = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	element_type = ARR_ELEMTYPE(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	position = (ARR_LBOUND(array))[0] - 1;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	 * We refuse to search for elements in multi-dimensional arrays, since we
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	 * have no good way to report the element's location in the array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	if (ARR_NDIM(array) > 1)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:				 errmsg("searching for elements in multidimensional arrays is not supported")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:		/* fast return when the array doesn't have nulls */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:		if (!array_contains_nulls(array))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	 * We arrange to look up type info for array_create_iterator only once per
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	 * Accumulate each array position iff the element matches the given
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	array_iterator = array_create_iterator(array, 0, my_extra);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	while (array_iterate(array_iterator, &value, &isnull))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:		 * Can't look at the array element's value if it's null; but if we
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	array_free_iterator(array_iterator);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_userfuncs.c:	PG_FREE_IF_COPY(array, 0);
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.c:static int xml_xpathobjtoxmlarray(xmlXPathObjectPtr xpathobj,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.c:	 * named_argvalue/named_argnull or argvalue/argnull arrays.  This avoids
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.c:	if (type_is_array_domain(type))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.c:		ArrayType  *array;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.c:		array = DatumGetArrayTypeP(value);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.c:		elmtype = ARR_ELEMTYPE(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.c:		deconstruct_array(array, elmtype,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.c: * to an array of xml values, which are appended to astate.  The function
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.c: * result value is the number of elements in the array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.c: * If "astate" is NULL then we don't generate the array value, but we still
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.c: * Nodesets are converted to an array containing the nodes' textual
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.c: * to a single-element array containing the value's string representation.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.c:xml_xpathobjtoxmlarray(xmlXPathObjectPtr xpathobj,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.c: * and array of XML values in astate.  Either of those pointers can be
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.c:	 * Namespace mappings are passed as text[].  If an empty array is passed
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.c:	 * Else, a 2-dimensional array with length of the second axis being equal
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.c:	 * to 2 should be passed, i.e., every subarray contains 2 elements, the
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.c:					 errmsg("invalid array for XML namespace mapping"),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.c:					 errdetail("The array must be two-dimensional with length of the second axis equal to 2.")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.c:		deconstruct_array(namespaces, TEXTOID, -1, false, 'i',
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.c:			*res_nitems = xml_xpathobjtoxmlarray(xpathobj, astate, xmlerrcxt);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.c:			(void) xml_xpathobjtoxmlarray(xpathobj, astate, xmlerrcxt);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.c: * Evaluate XPath expression and return array of XML values.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/xml.c: * to be the most useful one (array of XML functions plays a role of
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pg_locale.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pgstatfuncs.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pgstatfuncs.c:	/* Initialise values and NULL flags arrays */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/amutils.c:		"search_array", AMPROP_SEARCH_ARRAY
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/amutils.c:				PG_RETURN_BOOL(routine->amsearcharray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_gin.c:				/* Pretend string array elements are keys, see jsonb.h */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_gin.c:		/* Query is a text array; each element is treated as a key */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_gin.c:		deconstruct_array(query,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_gin.c:			/* Nulls in the array are ignored */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_gin.c:		 * keys and the index's failure to distinguish keys from string array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_gin.c:				 * Nesting an array within another array will not alter
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_gin.c:	 * special rules around the containment of raw scalars in arrays that are
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_gin.c: * or if it is a string array element (since we pretend those are keys,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsgistidx.c: * Removes duplicates from an array of int32. 'l' is
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsgistidx.c: * size of the input array. Returns the new size of the array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsgistidx.c:		/* make signature, if array is too long */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsgistidx.c: * is there value 'val' in array or not ?
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regproc.c:	 * array syntax.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regproc.c:	 * Invoke the full parser to deal with special cases such as array syntax.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regproc.c: * type names to an array of OIDs (returned into *nargs and *argtypes;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regproc.c: * the argtypes array should be of size FUNC_MAX_ARGS).  The function or
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/geo_ops.c: *	evaluating to only zero or one to use as an array index.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c: * strip_array_coercion - strip binary-compatible relabeling from an array expr
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c: * For array values, the parser normally generates ArrayCoerceExpr conversions,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:strip_array_coercion(Node *node)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c: *		scalararraysel		- Selectivity of ScalarArrayOpExpr Node.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:scalararraysel(PlannerInfo *root,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	rightop = strip_array_coercion(rightop);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	 * operator of the array element type.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	 * form of array containment; for instance "const = ANY(column)" can be
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	 * treated as "ARRAY[const] <@ column".  scalararraysel_containment tries
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		s1 = scalararraysel_containment(root, leftop, rightop,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	 * In the array-containment check above, we must only believe that an
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	 * operators that array containment will use.  But in what follows, we can
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	 * 1. rightop is an Array constant: deconstruct the array, apply the
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	 * operator's selectivity function for each array element, and merge the
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		Datum		arraydatum = ((Const *) rightop)->constvalue;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		bool		arrayisnull = ((Const *) rightop)->constisnull;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		ArrayType  *arrayval;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		if (arrayisnull)		/* qual can't succeed if null array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		arrayval = DatumGetArrayTypeP(arraydatum);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		get_typlenbyvalalign(ARR_ELEMTYPE(arrayval),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		deconstruct_array(arrayval,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:						  ARR_ELEMTYPE(arrayval),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		 * independent for each array element.  But for "= ANY" or "<> ALL",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		 * if the array elements are distinct (which'd typically be the case)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		ArrayExpr  *arrayexpr = (ArrayExpr *) rightop;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		get_typlenbyval(arrayexpr->element_typeid,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		 * the odds of equal array elements are rather higher if the elements
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		foreach(l, arrayexpr->elements)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		 * Arbitrarily assume 10 elements in the eventual array value (see
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		 * also estimate_array_length).  We don't risk an assumption of
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c: * Estimate number of elements in the array yielded by an expression.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c: * It's important that this agree with scalararraysel.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:estimate_array_length(Node *arrayexpr)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	/* look through any binary-compatible relabeling of arrayexpr */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	arrayexpr = strip_array_coercion(arrayexpr);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	if (arrayexpr && IsA(arrayexpr, Const))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		Datum		arraydatum = ((Const *) arrayexpr)->constvalue;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		bool		arrayisnull = ((Const *) arrayexpr)->constisnull;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		ArrayType  *arrayval;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		if (arrayisnull)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		arrayval = DatumGetArrayTypeP(arraydatum);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		return ArrayGetNItems(ARR_NDIM(arrayval), ARR_DIMS(arrayval));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	else if (arrayexpr && IsA(arrayexpr, ArrayExpr) &&
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:			 !((ArrayExpr *) arrayexpr)->multidims)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		return list_length(((ArrayExpr *) arrayexpr)->elements);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		/* default guess --- see also scalararraysel */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	RangeTblEntry *rte = root->simple_rte_array[var->varno];
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	rte = root->simple_rte_array[rel->relid];
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:			int			alength = estimate_array_length(lsecond(saop->args));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:			int			alength = estimate_array_length(qinfo->other_operand);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	double		arrayScans;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c: * each of which involves one value from the RHS array, plus all the
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c: * non-array quals (if any).  To model this, we average the counts across
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c: * correspond to per-indexscan costs).  We also multiply counts->arrayScans
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:gincost_scalararrayopexpr(PlannerInfo *root,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	ArrayType  *arrayval;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	GinQualCounts arraycounts;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	 * one ordinary search entry from each array entry at runtime, and fall
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	 * back on a probably-bad estimate of the number of array entries.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		counts->arrayScans *= estimate_array_length(rightop);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	/* Otherwise, extract the array elements and iterate over them */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	arrayval = DatumGetArrayTypeP(((Const *) rightop)->constvalue);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	get_typlenbyvalalign(ARR_ELEMTYPE(arrayval),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	deconstruct_array(arrayval,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:					  ARR_ELEMTYPE(arrayval),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	memset(&arraycounts, 0, sizeof(arraycounts));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:			/* We ignore array elements that are unsatisfiable patterns */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:			arraycounts.partialEntries += elemcounts.partialEntries;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:			arraycounts.exactEntries += elemcounts.exactEntries;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:			arraycounts.searchEntries += elemcounts.searchEntries;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		/* No satisfiable patterns in the array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	 * including contributions from both array and non-array quals.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	counts->partialEntries += arraycounts.partialEntries / numPossible;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	counts->exactEntries += arraycounts.exactEntries / numPossible;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	counts->searchEntries += arraycounts.searchEntries / numPossible;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	counts->arrayScans *= numPossible;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	counts.arrayScans = 1;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:			matchPossible = gincost_scalararrayopexpr(root,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	 * Calculate cache effects if more than one scan due to nestloops or array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	 * quals.  The result is pro-rated per nestloop scan, but the array qual
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	if (outer_scans > 1 || counts.arrayScans > 1)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		entryPagesFetched *= outer_scans * counts.arrayScans;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		dataPagesFetched *= outer_scans * counts.arrayScans;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	 * is no overlap between them. (XXX: tsvector and array opclasses collect
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:	if (outer_scans > 1 || counts.arrayScans > 1)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.c:		dataPagesFetched *= outer_scans * counts.arrayScans;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/txid.c:	uint32		nxip;			/* number of txids in xip array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/txid.c:	 * Compile-time limits on the procarray (MAX_BACKENDS processes plus
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ri_triggers.c:	 * We expect the arrays to be 1-D arrays of the right types; verify that.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ri_triggers.c:	 * We don't need to use deconstruct_array() since the array data is just
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ri_triggers.c:	 * going to look like a C array of values.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ri_triggers.c:		elog(ERROR, "conkey is not a 1-D smallint array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ri_triggers.c:		elog(ERROR, "confkey is not a 1-D smallint array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ri_triggers.c:		elog(ERROR, "conpfeqop is not a 1-D Oid array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ri_triggers.c:		elog(ERROR, "conppeqop is not a 1-D Oid array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ri_triggers.c:		elog(ERROR, "conffeqop is not a 1-D Oid array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ri_triggers.c: * Extract fields from a tuple into Datum/nulls arrays
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ri_triggers.c:		 * XXX eventually it would be good to support array-coercion cases
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/ri_triggers.c:		 * because cases involving nonidentical array types will be rejected
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c: * array_typanalyze.c
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c: *	  Functions for gathering statistics from array columns
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c: *	  src/backend/utils/adt/array_typanalyze.c
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c: * too much space in the resulting pg_statistic rows, we ignore arrays that
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:/* Extra data for compute_array_stats function */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:	/* Information about array element type */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c: * While compute_array_stats is running, we keep a pointer to the extra data
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c: * here for use by assorted subroutines.  compute_array_stats doesn't
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:static ArrayAnalyzeExtraData *array_extra_data;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:	int			last_container; /* For de-duplication of array elements. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:	int			count;			/* Count of distinct elements in an array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:	int			frequency;		/* Number of arrays seen with this count */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:static void compute_array_stats(VacAttrStats *stats,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c: * array_typanalyze -- typanalyze function for array columns
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:array_typanalyze(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:	 * Check attribute data type is a varlena array (or a domain over one).
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:		elog(ERROR, "array_typanalyze was invoked for non-array type %u",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:	/* Store our findings for use by compute_array_stats() */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:	stats->compute_stats = compute_array_stats;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:	 * be increased for array analysis purposes?
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c: * compute_array_stats() -- compute statistics for an array column
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c: * the array operators <@, &&, and @>.  It is invoked by ANALYZE via the
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c: * "scalar" statistics relevant to the btree-style array comparison operators.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c: * However, exact duplicates of an entire array may be rare despite many
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c: * arrays sharing individual elements.  This especially afflicts long arrays,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c: * we find the most common array elements and compute a histogram of distinct
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c: * arrays.  These parameters give bucket width w = K/0.007 and maximum
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c: * Elements may repeat within an array.  Since duplicates do not change the
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c: * array.  Therefore, we store in the finished pg_statistic entry each
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:compute_array_stats(VacAttrStats *stats, AnalyzeAttrFetchFunc fetchfunc,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:	int			array_no;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:	array_extra_data = extra_data;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:	 * We want statistics_target * 10 elements in the MCELEM array. This
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:	/* hashtable for array distinct elements counts */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:	/* Loop over the arrays. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:	for (array_no = 0; array_no < samplerows; array_no++)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:		ArrayType  *array;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:		value = fetchfunc(stats, array_no, &isnull);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:			/* array is null, just count that */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:		 * Now detoast the array if needed, and deconstruct into datums.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:		array = DatumGetArrayTypeP(value);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:		Assert(ARR_ELEMTYPE(array) == extra_data->type_id);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:		deconstruct_array(array,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:		 * We loop through the elements in the array and add them to our
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:				 * The operators we assist ignore duplicate array elements, so
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:				 * count a given distinct element only once per array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:				if (item->last_container == array_no)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:				item->last_container = array_no;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:				 * palloc'd space, so that we can release the array below. (We
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:				 * array values around, it could be much more.)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:				item->last_container = array_no;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:		/* Count null element presence once per array. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:		/* Update frequency of the particular array distinct element count. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:		if (PointerGetDatum(array) != value)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:			pfree(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:		elog(ERROR, "insufficient pg_statistic slots for array stats");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:		 * Construct an array of the interesting hashtable items, that is,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:		elog(DEBUG3, "compute_array_stats: target # mces = %d, "
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:		 * with least frequencies.  The easiest way is to qsort the array into
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:		 * descending frequency order and truncate the array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:			 * Create an array of DECountItem pointers, and sort them into
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:			 * average count.  This array must be stored in anl_context.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:			 * whole input population of arrays).  If we had a complete sorted
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:			 * array of DECs, one per analyzed row, the i'th hist value would
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:			 * But instead of that we have the sorted_count_items[] array,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:			 * a run-length-compressed version of the full array).  So we
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:			 * where x is the index in the notional DECs array corresponding
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:			if (!array_extra_data->typbyval)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:	h = FunctionCall1Coll(array_extra_data->hash, DEFAULT_COLLATION_OID, d);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_typanalyze.c:	c = FunctionCall2Coll(array_extra_data->cmp, DEFAULT_COLLATION_OID, d1, d2);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsginidx.c:		 * same, entry's) number. Entry's number is used in check array in
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsginidx.c:		/* Now rescan the VAL items and fill in the arrays */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsginidx.c:		 * check-parameter array has one entry for each value (operand) in the
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsginidx.c:		 * check-parameter array has one entry for each value (operand) in the
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/rangetypes_gist.c:	/* Index of entry in the initial array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/rangetypes_gist.c: * classes_groups is an array of length CLS_COUNT indicating the side of the
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/rangetypes_gist.c:	 * Prepare auxiliary array and sort the values.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/rangetypes_gist.c:		/* Put appropriate bound into array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/rangetypes_gist.c:	/* Allocate arrays for sorted range bounds */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/rangetypes_gist.c:	/* Fill arrays of bounds */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/rangetypes_gist.c:	 * Make two arrays of range bounds: one sorted by lower bound and another
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/rangetypes_gist.c:	 * be placed unambiguously and collect "common entries" to array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/rangetypes_gist.c:	 * Allocate an array for "common entries" - entries which can be placed to
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/json.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/formatting.c: * The array is laid out such that matches for AD have an even index, and
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/formatting.c: * taking the array index of the match, modulo 2.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/formatting.c: * The array is laid out such that matches for AM have an even index, and
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/formatting.c: * taking the array index of the match, modulo 2.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/formatting.c:static int	seq_search(char *name, const char *const *array, int type, int max, int *len);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/formatting.c:static int	from_char_seq_search(int *dest, char **src, const char *const *array, int type, int max, FormatNode *node);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/formatting.c:seq_search(char *name, const char *const *array, int type, int max, int *len)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/formatting.c:	for (last = 0, a = array; *a != NULL; a++)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/formatting.c:				return a - array;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/formatting.c:				return a - array;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/formatting.c:			/* Not found in array 'a' */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/formatting.c: * Perform a sequential search in 'array' for text matching the first 'max'
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/formatting.c: * If a match is found, copy the array index of the match into the integer
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/formatting.c:from_char_seq_search(int *dest, char **src, const char *const *array, int type, int max,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/formatting.c:	*dest = seq_search(*src, array, type, max, &len);
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/acl.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c: * the array, dropping the entry at the end of the array if necessary to
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:static cached_re_str re_array[MAX_CACHED_RES];	/* cached re's */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c: * an array of pg_wchar, which is what Spencer's regex package wants.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:		if (re_array[i].cre_pat_len == text_re_len &&
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:			re_array[i].cre_flags == cflags &&
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:			re_array[i].cre_collation == collation &&
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:			memcmp(re_array[i].cre_pat, text_re_val, text_re_len) == 0)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:				re_temp = re_array[i];
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:				memmove(&re_array[1], &re_array[0], i * sizeof(cached_re_str));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:				re_array[0] = re_temp;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:			return &re_array[0].cre_re;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:	 * array.  Discard last entry if needed.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:		pg_regfree(&re_array[num_res].cre_re);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:		free(re_array[num_res].cre_pat);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:		memmove(&re_array[1], &re_array[0], num_res * sizeof(cached_re_str));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:	re_array[0] = re_temp;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:	return &re_array[0].cre_re;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c: * Data is given as array of pg_wchar which is what Spencer's regex package
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c: * convert to array of pg_wchar which is what Spencer's regex package wants.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c: * convert to array of pg_wchar which is what Spencer's regex package wants.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:	int			array_len;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:	int			array_idx;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:	array_len = re_flags->glob ? 256 : 32;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:	matchctx->match_locs = (int *) palloc(sizeof(int) * array_len);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:	array_idx = 0;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:			while (array_idx + matchctx->npatterns * 2 > array_len)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:				array_len *= 2;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:														sizeof(int) * array_len);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:					matchctx->match_locs[array_idx++] = pmatch[i].rm_so;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:					matchctx->match_locs[array_idx++] = pmatch[i].rm_eo;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:				matchctx->match_locs[array_idx++] = pmatch[0].rm_so;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:				matchctx->match_locs[array_idx++] = pmatch[0].rm_eo;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c: * build_regexp_match_result - build output array for current match
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:	/* And form an array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:	return construct_md_array(elems, nulls, 1, dims, lbs,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c: * regexp_split_to_array()
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c: *		split-out substrings as an array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:regexp_split_to_array(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:				 errmsg("regexp_split_to_array does not support the global option")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:regexp_split_to_array_no_flags(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.c:	return regexp_split_to_array(fcinfo);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/network_spgist.c:	/* Don't need labels; allocate output arrays */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * arrayfuncs.c
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	  Support functions for arrays.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	  src/backend/utils/adt/arrayfuncs.c
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:#include "utils/arrayaccess.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:#define AARR_FREE_IF_COPY(array,n) \
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		if (!VARATT_IS_EXPANDED_HEADER(array)) \
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			PG_FREE_IF_COPY(array, n); \
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:/* Working state for array_iterate() */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* basic info about the array, set up during array_create_iterator() */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	ArrayType  *arr;			/* array we're iterating through */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	int			nitems;			/* total number of elements in array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	int		   *slice_dims;		/* slice dims array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	int		   *slice_lbound;	/* slice lbound array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	char	   *data_ptr;		/* our current position in the array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	int			current_item;	/* the item # we're at in the array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:static bool array_isspace(char ch);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:static void ReadArrayStr(char *arrayStr, const char *origStr,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:static Datum array_get_element_expanded(Datum arraydatum,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:						   int arraytyplen,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:static Datum array_set_element_expanded(Datum arraydatum,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:						   int arraytyplen,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:static bool array_get_isnull(const bits8 *nullbitmap, int offset);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:static void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:static int array_copy(char *destptr, int nitems,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:static void array_extract_slice(ArrayType *newarray,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					char *arraydataptr, bits8 *arraynullsptr,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:static int	array_cmp(FunctionCallInfo fcinfo);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:static ArrayType *array_replace_internal(ArrayType *array,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:static int	width_bucket_array_float8(Datum operand, ArrayType *thresholds);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:static int width_bucket_array_fixed(Datum operand,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:static int width_bucket_array_variable(Datum operand,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_in :
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		  converts an array from the external format in "string" to
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		  the internal representation of the input array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_in(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	Oid			element_type = PG_GETARG_OID(1);	/* type of an array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	int32		typmod = PG_GETARG_INT32(2);	/* typmod for array elements */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		while (array_isspace(*p))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errmsg("number of array dimensions (%d) exceeds the maximum allowed (%d)",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errmsg("malformed array literal: \"%s\"", string),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errdetail("\"[\" must introduce explicitly-specified array dimensions.")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:						 errmsg("malformed array literal: \"%s\"", string),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:						 errdetail("Missing array dimension value.")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errmsg("malformed array literal: \"%s\"", string),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errdetail("Missing \"%s\" after array dimensions.",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		/* No array dimensions, so intuit dimensions from brace structure */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errmsg("malformed array literal: \"%s\"", string),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		/* If array dimensions are given, expect '=' operator */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errmsg("malformed array literal: \"%s\"", string),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errdetail("Missing \"%s\" after array dimensions.",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		while (array_isspace(*p))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errmsg("malformed array literal: \"%s\"", string),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errmsg("malformed array literal: \"%s\"", string),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errdetail("Specified array dimensions do not match array contents.")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:						 errmsg("malformed array literal: \"%s\"", string),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:						 errdetail("Specified array dimensions do not match array contents.")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	printf("array_in- ndim %d (", ndim);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* This checks for overflow of the array dimensions */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Empty array? */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		PG_RETURN_ARRAYTYPE_P(construct_empty_array(element_type));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * This comes from the array's pg_type.typelem (which points to the base
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_isspace() --- a non-locale-dependent isspace()
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * We used to use isspace() for parsing array values, but that has
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * undesirable results: an array value might be silently interpreted
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_isspace(char ch)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	 Determines the dimensions for an array string.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	bool		empty_array = true;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				empty_array = false;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:							 errmsg("malformed array literal: \"%s\"", str),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:								 errmsg("malformed array literal: \"%s\"", str),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:								 errmsg("malformed array literal: \"%s\"", str),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:								 errmsg("malformed array literal: \"%s\"", str),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:								 errdetail("Unexpected array element.")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:									 errmsg("malformed array literal: \"%s\"", str),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:									 errmsg("number of array dimensions (%d) exceeds the maximum allowed (%d)",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:									 errmsg("malformed array literal: \"%s\"", str),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:									 errmsg("malformed array literal: \"%s\"", str),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:									 errmsg("malformed array literal: \"%s\"", str),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:									 errdetail("Multidimensional arrays must have "
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:											   "sub-arrays with matching "
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:										 errmsg("malformed array literal: \"%s\"", str),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:						else if (!array_isspace(*ptr))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:										 errmsg("malformed array literal: \"%s\"", str),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:										 errdetail("Unexpected array element.")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		if (!array_isspace(*ptr++))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errmsg("malformed array literal: \"%s\"", str),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* special case for an empty array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	if (empty_array)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	 parses the array string pointed to by "arrayStr" and converts the values
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	 The array dimensions must already have been determined.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	arrayStr: the string to parse.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *			  CAUTION: the contents of "arrayStr" will be modified!
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	nitems: total number of array elements, as already determined.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	ndim: number of array dimensions
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	dim[]: array axis lengths
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		padding but not including array header overhead).
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:ReadArrayStr(char *arrayStr,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * in-place within arrayStr to do this.  srcptr is the current scan point,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	srcptr = arrayStr;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:							 errmsg("malformed array literal: \"%s\"",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:								 errmsg("malformed array literal: \"%s\"",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:									 errmsg("malformed array literal: \"%s\"",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:									 errmsg("malformed array literal: \"%s\"",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					else if (array_isspace(*srcptr))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errmsg("malformed array literal: \"%s\"",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:						 errmsg("array size exceeds the maximum allowed (%d)",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * Copy data into an array object from a temporary array of Datums.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array: array object (with header fields already filled in)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * values: array of Datums to be copied
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * nulls: array of is-null flags (can be NULL if no nulls)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * caller has already allocated space for the array...)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:CopyArrayEls(ArrayType *array,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	char	   *p = ARR_DATA_PTR(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	bits8	   *bitmap = ARR_NULLBITMAP(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				elog(ERROR, "null array element where not supported");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_out :
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		   takes the internal representation of an array and returns a string
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		  containing the array in its external format.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_out(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	array_iter	iter;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	array_iter_setup(&iter, v);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		itemvalue = array_iter_next(&iter, &isnull, i,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:						 array_isspace(ch))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_recv :
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		  converts an array from the external binary format to
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		  the internal representation of the input array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_recv(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	Oid			spec_element_type = PG_GETARG_OID(1);	/* type of an array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	int32		typmod = PG_GETARG_INT32(2);	/* typmod for array elements */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Get the array header information */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	if (ndim < 0)				/* we do allow zero-dimension arrays */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				 errmsg("number of array dimensions (%d) exceeds the maximum allowed (%d)",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				 errmsg("invalid array flags")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* This checks for overflow of array dimensions */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		/* Return empty array ... but not till we've validated element_type */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		PG_RETURN_ARRAYTYPE_P(construct_empty_array(element_type));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	 collect the data elements of an array being read in binary style.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	nitems: total number of array elements (already read).
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		padding but not including array header overhead).
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errmsg("improper binary format in array element %d",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:						 errmsg("array size exceeds the maximum allowed (%d)",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_send :
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		  takes the internal representation of an array and returns a bytea
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		  containing the array in its external binary format.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_send(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	array_iter	iter;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Send the array header information */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Send the array elements using the element's own sendproc */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	array_iter_setup(&iter, v);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		itemvalue = array_iter_next(&iter, &isnull, i,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_ndims :
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		  returns the number of dimensions of the array pointed to by "v"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_ndims(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Sanity check: does it look like an array at all? */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_dims :
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		  returns the dimensions of the array pointed to by "v", as a "text"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_dims(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Sanity check: does it look like an array at all? */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_lower :
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		the array pointed to by "v", as an int4
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_lower(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Sanity check: does it look like an array at all? */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_upper :
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		the array pointed to by "v", as an int4
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_upper(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Sanity check: does it look like an array at all? */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_length :
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		the array pointed to by "v", as an int4
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_length(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Sanity check: does it look like an array at all? */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_cardinality:
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		returns the total number of elements in an array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_cardinality(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_get_element :
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	  This routine takes an array datum and a subscript array and returns
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	  datatype, the returned Datum is a pointer into the array object.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * This handles both ordinary varlena arrays and fixed-length arrays.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	arraydatum: the array object (mustn't be NULL)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	arraytyplen: pg_type.typlen for the array type
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	elmlen: pg_type.typlen for the array's element type
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	elmbyval: pg_type.typbyval for the array's element type
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	elmalign: pg_type.typalign for the array's element type
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_get_element(Datum arraydatum,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				  int arraytyplen,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	char	   *arraydataptr,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	bits8	   *arraynullsptr;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	if (arraytyplen > 0)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * fixed-length arrays -- these are assumed to be 1-d, 0-based
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		fixedDim[0] = arraytyplen / elmlen;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		arraydataptr = (char *) DatumGetPointer(arraydatum);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		arraynullsptr = NULL;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	else if (VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(arraydatum)))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		/* expanded array: let's do this in a separate function */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		return array_get_element_expanded(arraydatum,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:										  arraytyplen,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		/* detoast array if necessary, producing normal varlena input */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		ArrayType  *array = DatumGetArrayTypeP(arraydatum);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		ndim = ARR_NDIM(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		dim = ARR_DIMS(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		lb = ARR_LBOUND(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		arraydataptr = ARR_DATA_PTR(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		arraynullsptr = ARR_NULLBITMAP(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * Check for NULL array element
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	if (array_get_isnull(arraynullsptr, offset))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	retptr = array_seek(arraydataptr, 0, arraynullsptr, offset,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * Implementation of array_get_element() for an expanded array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_get_element_expanded(Datum arraydatum,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:						   int arraytyplen,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	eah = (ExpandedArrayHeader *) DatumGetEOHP(arraydatum);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	Assert(arraytyplen == -1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * Deconstruct array if we didn't already.  Note that we apply this even
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	deconstruct_expanded_array(eah);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * Check for NULL array element
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * pointer into the expanded array, for the same reason that regular
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * array_get_element can return a pointer into flat arrays: the value is
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_get_slice :
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		   This routine takes an array and a range of indices (upperIndex and
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		   lowerIndx), creates a new array structure for the referred elements
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * This handles both ordinary varlena arrays and fixed-length arrays.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	arraydatum: the array object (mustn't be NULL)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	arraytyplen: pg_type.typlen for the array type
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	elmlen: pg_type.typlen for the array's element type
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	elmbyval: pg_type.typbyval for the array's element type
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	elmalign: pg_type.typalign for the array's element type
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	The return value is the new array Datum (it's never NULL)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array bound.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * NOTE: we assume it is OK to scribble on the provided subscript arrays
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_get_slice(Datum arraydatum,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				int arraytyplen,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	ArrayType  *array;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	ArrayType  *newarray;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	char	   *arraydataptr;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	bits8	   *arraynullsptr;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	if (arraytyplen > 0)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * fixed-length arrays -- currently, cannot slice these because parser
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * labels output as being of the fixed-length array type! Code below
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * output as a suitable varlena array type.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				 errmsg("slices of fixed-length arrays not implemented")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * fixed-length arrays -- these are assumed to be 1-d, 0-based
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		fixedDim[0] = arraytyplen / elmlen;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		arraydataptr = (char *) DatumGetPointer(arraydatum);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		arraynullsptr = NULL;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		/* detoast input array if necessary */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		array = DatumGetArrayTypeP(arraydatum);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		ndim = ARR_NDIM(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		dim = ARR_DIMS(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		lb = ARR_LBOUND(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		elemtype = ARR_ELEMTYPE(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		arraydataptr = ARR_DATA_PTR(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		arraynullsptr = ARR_NULLBITMAP(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * Check provided subscripts.  A slice exceeding the current array limits
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * is silently truncated to the array limits.  If we end up with an empty
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * slice, return an empty array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		return PointerGetDatum(construct_empty_array(elemtype));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			return PointerGetDatum(construct_empty_array(elemtype));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* fill any missing subscript positions with full array range */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			return PointerGetDatum(construct_empty_array(elemtype));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	bytes = array_slice_size(arraydataptr, arraynullsptr,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	if (arraynullsptr)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	newarray = (ArrayType *) palloc0(bytes);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	SET_VARSIZE(newarray, bytes);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	newarray->ndim = ndim;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	newarray->dataoffset = dataoffset;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	newarray->elemtype = elemtype;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	memcpy(ARR_DIMS(newarray), span, ndim * sizeof(int));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * Lower bounds of the new array are set to 1.  Formerly (before 7.3) we
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	newlb = ARR_LBOUND(newarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	array_extract_slice(newarray,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:						arraydataptr, arraynullsptr,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	return PointerGetDatum(newarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_set_element :
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		  This routine sets the value of one array element (specified by
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		  a subscript array) to a new value specified by "dataValue".
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * This handles both ordinary varlena arrays and fixed-length arrays.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	arraydatum: the initial array object (mustn't be NULL)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	arraytyplen: pg_type.typlen for the array type
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	elmlen: pg_type.typlen for the array's element type
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	elmbyval: pg_type.typbyval for the array's element type
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	elmalign: pg_type.typalign for the array's element type
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		  A new array is returned, just like the old except for the one
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		  modified entry.  The original array object is not changed,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		  array object; in that case the expanded array is updated in-place.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * For one-dimensional arrays only, we allow the array to be extended
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * (XXX TODO: allow a corresponding behavior for multidimensional arrays)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_set_element(Datum arraydatum,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				  int arraytyplen,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	ArrayType  *array;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	ArrayType  *newarray;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	if (arraytyplen > 0)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * fixed-length arrays -- these are assumed to be 1-d, 0-based. We
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		char	   *resultarray;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errmsg("wrong number of array subscripts")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		if (indx[0] < 0 || indx[0] * elmlen >= arraytyplen)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errmsg("array subscript out of range")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errmsg("cannot assign null value to an element of a fixed-length array")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		resultarray = (char *) palloc(arraytyplen);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		memcpy(resultarray, DatumGetPointer(arraydatum), arraytyplen);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		elt_ptr = (char *) resultarray + indx[0] * elmlen;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		return PointerGetDatum(resultarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				 errmsg("wrong number of array subscripts")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	if (VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(arraydatum)))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		/* expanded array: let's do this in a separate function */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		return array_set_element_expanded(arraydatum,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:										  arraytyplen,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* detoast input array if necessary */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	array = DatumGetArrayTypeP(arraydatum);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	ndim = ARR_NDIM(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * if number of dims is zero, i.e. an empty array, create an array with
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		Oid			elmtype = ARR_ELEMTYPE(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		return PointerGetDatum(construct_md_array(&dataValue, &isNull,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				 errmsg("wrong number of array subscripts")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	memcpy(dim, ARR_DIMS(array), ndim * sizeof(int));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	memcpy(lb, ARR_LBOUND(array), ndim * sizeof(int));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	newhasnulls = (ARR_HASNULL(array) || isNull);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * XXX currently we do not support extending multi-dimensional arrays
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:						 errmsg("array subscript out of range")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	oldnitems = ArrayGetNItems(ndim, ARR_DIMS(array));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	oldnullbitmap = ARR_NULLBITMAP(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	oldoverheadlen = ARR_DATA_OFFSET(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	olddatasize = ARR_SIZE(array) - oldoverheadlen;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		elt_ptr = array_seek(ARR_DATA_PTR(array), 0, oldnullbitmap, offset,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		lenbefore = (int) (elt_ptr - ARR_DATA_PTR(array));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		if (array_get_isnull(oldnullbitmap, offset))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * OK, create the new array and fill in header/dimensions
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	newarray = (ArrayType *) palloc0(newsize);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	SET_VARSIZE(newarray, newsize);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	newarray->ndim = ndim;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	newarray->dataoffset = newhasnulls ? overheadlen : 0;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	newarray->elemtype = ARR_ELEMTYPE(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	memcpy(ARR_DIMS(newarray), dim, ndim * sizeof(int));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	memcpy(ARR_LBOUND(newarray), lb, ndim * sizeof(int));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	memcpy((char *) newarray + overheadlen,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		   (char *) array + oldoverheadlen,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:						(char *) newarray + overheadlen + lenbefore);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	memcpy((char *) newarray + overheadlen + lenbefore + newitemlen,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		   (char *) array + oldoverheadlen + lenbefore + olditemlen,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		bits8	   *newnullbitmap = ARR_NULLBITMAP(newarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			array_set_isnull(newnullbitmap, newnitems - 1, isNull);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			array_set_isnull(newnullbitmap, offset, isNull);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			array_bitmap_copy(newnullbitmap, addedbefore,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			array_bitmap_copy(newnullbitmap, 0,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				array_bitmap_copy(newnullbitmap, offset + 1,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	return PointerGetDatum(newarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * Implementation of array_set_element() for an expanded array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_set_element_expanded(Datum arraydatum,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:						   int arraytyplen,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	eah = DatumGetExpandedArray(arraydatum);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	Assert(arraytyplen == -1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * if number of dims is zero, i.e. an empty array, create an array with
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				 errmsg("wrong number of array subscripts")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * Deconstruct array if we didn't already.  (Someday maybe add a special
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	deconstruct_expanded_array(eah);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * Copy new element into array's context, if needed (we assume it's
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * Check subscripts (this logic matches original array_set_element)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * XXX currently we do not support extending multi-dimensional arrays
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:						 errmsg("array subscript out of range")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Now we can calculate linear offset of target item in array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Physically enlarge existing dvalues/dnulls arrays if needed */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Flattened value will no longer represent array accurately */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * from bloating the array's storage.  If the pfree somehow fails, it
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * won't corrupt the array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		/* Don't try to pfree a part of the original flat array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_set_slice :
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		  This routine sets the value of a range of array locations (specified
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		  another array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * This handles both ordinary varlena arrays and fixed-length arrays.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	arraydatum: the initial array object (mustn't be NULL)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	arraytyplen: pg_type.typlen for the array type
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	elmlen: pg_type.typlen for the array's element type
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	elmbyval: pg_type.typbyval for the array's element type
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	elmalign: pg_type.typalign for the array's element type
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		  A new array is returned, just like the old except for the
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		  modified range.  The original array object is not changed.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array bound.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * For one-dimensional arrays only, we allow the array to be extended
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * (XXX TODO: allow a corresponding behavior for multidimensional arrays)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * NOTE: we assume it is OK to scribble on the provided index arrays
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * rather than returning a NULL or empty array as the fetch operations do.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_set_slice(Datum arraydatum,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				int arraytyplen,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	ArrayType  *array;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	ArrayType  *newarray;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Currently, assignment from a NULL source array is a no-op */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		return arraydatum;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	if (arraytyplen > 0)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * fixed-length arrays -- not got round to doing this...
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				 errmsg("updates on slices of fixed-length arrays not implemented")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* detoast arrays if necessary */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	array = DatumGetArrayTypeP(arraydatum);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	ndim = ARR_NDIM(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * if number of dims is zero, i.e. an empty array, create an array with
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		Oid			elmtype = ARR_ELEMTYPE(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		deconstruct_array(srcArray, elmtype, elmlen, elmbyval, elmalign,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:						 errmsg("array slice subscript must provide both boundaries"),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:						 errdetail("When assigning to a slice of an empty array value,"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errmsg("source array too small")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		return PointerGetDatum(construct_md_array(dvalues, dnulls, nSubscripts,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				 errmsg("wrong number of array subscripts")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	memcpy(dim, ARR_DIMS(array), ndim * sizeof(int));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	memcpy(lb, ARR_LBOUND(array), ndim * sizeof(int));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	newhasnulls = (ARR_HASNULL(array) || ARR_HASNULL(srcArray));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * XXX currently we do not support extending multi-dimensional arrays
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:						 errmsg("array subscript out of range")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		/* fill any missing subscript positions with full array range */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * Make sure source array has enough entries.  Note we ignore the shape of
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * the source array and just read entries serially.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				 errmsg("source array too small")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * entries, and required space for new array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	newitemsize = array_nelems_size(ARR_DATA_PTR(srcArray), 0,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	oldoverheadlen = ARR_DATA_OFFSET(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	olddatasize = ARR_SIZE(array) - oldoverheadlen;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * here we do not need to cope with extension of the array; it would
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		olditemsize = array_slice_size(ARR_DATA_PTR(array),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:									   ARR_NULLBITMAP(array),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * here we must allow for possibility of slice larger than orig array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * and/or not adjacent to orig array subscripts
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		int			oldlb = ARR_LBOUND(array)[0];
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		int			oldub = oldlb + ARR_DIMS(array)[0] - 1;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		char	   *oldarraydata = ARR_DATA_PTR(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		bits8	   *oldarraybitmap = ARR_NULLBITMAP(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		/* count/size of old array entries that will go before the slice */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		lenbefore = array_nelems_size(oldarraydata, 0, oldarraybitmap,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		/* count/size of old array entries that will be replaced by slice */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			olditemsize = array_nelems_size(oldarraydata + lenbefore,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:											itemsbefore, oldarraybitmap,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		/* count/size of old array entries that will go after the slice */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	newarray = (ArrayType *) palloc0(newsize);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	SET_VARSIZE(newarray, newsize);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	newarray->ndim = ndim;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	newarray->dataoffset = newhasnulls ? overheadlen : 0;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	newarray->elemtype = ARR_ELEMTYPE(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	memcpy(ARR_DIMS(newarray), dim, ndim * sizeof(int));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	memcpy(ARR_LBOUND(newarray), lb, ndim * sizeof(int));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * here we do not need to cope with extension of the array; it would
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		array_insert_slice(newarray, array, srcArray,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		memcpy((char *) newarray + overheadlen,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			   (char *) array + oldoverheadlen,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		memcpy((char *) newarray + overheadlen + lenbefore,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		memcpy((char *) newarray + overheadlen + lenbefore + newitemsize,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			   (char *) array + oldoverheadlen + lenbefore + olditemsize,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			bits8	   *newnullbitmap = ARR_NULLBITMAP(newarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			bits8	   *oldnullbitmap = ARR_NULLBITMAP(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			array_bitmap_copy(newnullbitmap, addedbefore,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			array_bitmap_copy(newnullbitmap, lowerIndx[0] - lb[0],
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			array_bitmap_copy(newnullbitmap, addedbefore + itemsbefore + nolditems,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	return PointerGetDatum(newarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_ref : backwards compatibility wrapper for array_get_element
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * This only works for detoasted/flattened varlena arrays, since the array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_ref(ArrayType *array, int nSubscripts, int *indx,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		  int arraytyplen, int elmlen, bool elmbyval, char elmalign,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	return array_get_element(PointerGetDatum(array), nSubscripts, indx,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:							 arraytyplen, elmlen, elmbyval, elmalign,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_set : backwards compatibility wrapper for array_set_element
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * This only works for detoasted/flattened varlena arrays, since the array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_set(ArrayType *array, int nSubscripts, int *indx,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		  int arraytyplen, int elmlen, bool elmbyval, char elmalign)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	return DatumGetArrayTypeP(array_set_element(PointerGetDatum(array),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:												arraytyplen,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_map()
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * Map an array through an arbitrary function.  Return a new array with
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * The output array can have a different element type than the input.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	 first argument position initially holds the input array value.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * * retType: OID of element type of output array.  This must be the same as,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * * amstate: workspace for array_map.  Must be zeroed by caller before
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * NB: caller must assure that input array is not NULL.  NULL elements in
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * the array are OK however.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_map(FunctionCallInfo fcinfo, Oid retType, ArrayMapState *amstate)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	array_iter	iter;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Get input array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		elog(ERROR, "null input array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Check for empty array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		/* Return empty array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		PG_RETURN_ARRAYTYPE_P(construct_empty_array(retType));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Allocate temporary arrays for new values */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	array_iter_setup(&iter, v);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		fcinfo->arg[0] = array_iter_next(&iter, &fcinfo->argnull[0], i,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:						 errmsg("array size exceeds the maximum allowed (%d)",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Allocate and initialize the result array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * construct_array	--- simple method for constructing an array object
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * elems: array of Datum items to become the array contents
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * A palloc'd 1-D array object is constructed and returned.  Note that
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:construct_array(Datum *elems, int nelems,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	return construct_md_array(elems, NULL, 1, dims, lbs,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * construct_md_array	--- simple method for constructing an array object
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * elems: array of Datum items to become the array contents
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * nulls: array of is-null flags (can be NULL if no nulls)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * dims: integer array with size of each dimension
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * lbs: integer array with lower bound of each dimension
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * A palloc'd ndims-D array object is constructed and returned.  Note that
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:construct_md_array(Datum *elems,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	if (ndims < 0)				/* we do allow zero-dimension arrays */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				 errmsg("number of array dimensions (%d) exceeds the maximum allowed (%d)",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* fast track for empty array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		return construct_empty_array(elmtype);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errmsg("array size exceeds the maximum allowed (%d)",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Allocate and initialize result array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * construct_empty_array	--- make a zero-dimensional array of given type
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:construct_empty_array(Oid elmtype)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * construct_empty_expanded_array: make an empty expanded array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:construct_empty_expanded_array(Oid element_type,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	ArrayType  *array = construct_empty_array(element_type);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	d = expand_array(PointerGetDatum(array), parentcontext, metacache);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	pfree(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * deconstruct_array  --- simple method for extracting data from an array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array: array object to examine (must not be NULL)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * elemsp: return value, set to point to palloc'd array of Datum values
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * nullsp: return value, set to point to palloc'd array of isnull markers
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array.  Note that this produces a very uninformative error message,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * If array elements are pass-by-ref data type, the returned Datums will
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * be pointers into the array object.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:deconstruct_array(ArrayType *array,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	Assert(ARR_ELEMTYPE(array) == elmtype);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	nelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	p = ARR_DATA_PTR(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	bitmap = ARR_NULLBITMAP(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:						 errmsg("null array element not allowed in this context")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_contains_nulls --- detect whether an array has any null elements
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * if the array *might* contain a null.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_contains_nulls(ArrayType *array)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	if (!ARR_HASNULL(array))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	nelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	bitmap = ARR_NULLBITMAP(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_eq :
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		  compares two arrays for equality
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		  returns true if the arrays are equal, false otherwise.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * Note: we do not use array_cmp here, since equality may be meaningful in
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_eq(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	AnyArrayType *array1 = PG_GETARG_ANY_ARRAY(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	AnyArrayType *array2 = PG_GETARG_ANY_ARRAY(1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	int			ndims1 = AARR_NDIM(array1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	int			ndims2 = AARR_NDIM(array2);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	int		   *dims1 = AARR_DIMS(array1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	int		   *dims2 = AARR_DIMS(array2);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	int		   *lbs1 = AARR_LBOUND(array1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	int		   *lbs2 = AARR_LBOUND(array2);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	Oid			element_type = AARR_ELEMTYPE(array1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	array_iter	it1;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	array_iter	it2;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	if (element_type != AARR_ELEMTYPE(array2))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				 errmsg("cannot compare arrays of different element types")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* fast path if the arrays do not have the same dimensionality */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * apply the operator to each pair of array elements.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		array_iter_setup(&it1, array1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		array_iter_setup(&it2, array2);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			elt1 = array_iter_next(&it1, &isnull1, i,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			elt2 = array_iter_next(&it2, &isnull2, i,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	AARR_FREE_IF_COPY(array1, 0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	AARR_FREE_IF_COPY(array2, 1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array-array bool operators:
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		Given two arrays, iterate comparison operators
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		over the array. Uses logic similar to text comparison
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_ne(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	PG_RETURN_BOOL(!DatumGetBool(array_eq(fcinfo)));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_lt(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	PG_RETURN_BOOL(array_cmp(fcinfo) < 0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_gt(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	PG_RETURN_BOOL(array_cmp(fcinfo) > 0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_le(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	PG_RETURN_BOOL(array_cmp(fcinfo) <= 0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_ge(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	PG_RETURN_BOOL(array_cmp(fcinfo) >= 0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:btarraycmp(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	PG_RETURN_INT32(array_cmp(fcinfo));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_cmp()
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * Internal comparison function for arrays.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_cmp(FunctionCallInfo fcinfo)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	AnyArrayType *array1 = PG_GETARG_ANY_ARRAY(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	AnyArrayType *array2 = PG_GETARG_ANY_ARRAY(1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	int			ndims1 = AARR_NDIM(array1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	int			ndims2 = AARR_NDIM(array2);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	int		   *dims1 = AARR_DIMS(array1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	int		   *dims2 = AARR_DIMS(array2);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	Oid			element_type = AARR_ELEMTYPE(array1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	array_iter	it1;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	array_iter	it2;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	if (element_type != AARR_ELEMTYPE(array2))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				 errmsg("cannot compare arrays of different element types")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * apply the operator to each pair of array elements.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	array_iter_setup(&it1, array1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	array_iter_setup(&it2, array2);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		elt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		elt2 = array_iter_next(&it2, &isnull2, i, typlen, typbyval, typalign);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * If arrays contain same data (up to end of shorter one), apply
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * that we don't say "equal" for arrays of different dimensionality.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				int		   *lbound1 = AARR_LBOUND(array1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				int		   *lbound2 = AARR_LBOUND(array2);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	AARR_FREE_IF_COPY(array1, 0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	AARR_FREE_IF_COPY(array2, 1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array hashing
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:hash_array(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	AnyArrayType *array = PG_GETARG_ANY_ARRAY(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	int			ndims = AARR_NDIM(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	int		   *dims = AARR_DIMS(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	Oid			element_type = AARR_ELEMTYPE(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	array_iter	iter;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * apply the hash function to each array element.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	array_iter_setup(&iter, array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		elt = array_iter_next(&iter, &isnull, i, typlen, typbyval, typalign);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * order 2^27. So for arrays of up to 2^27 elements, each element's
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	AARR_FREE_IF_COPY(array, 0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array overlap/containment comparisons
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		These use the same methods of comparing array elements as array_eq.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		We consider only the elements of the arrays, ignoring dimensionality.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_contain_compare :
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		  compares two arrays for overlap/containment
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * When matchall is true, return true if all members of array1 are in array2.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * When matchall is false, return true if any members of array1 are in array2.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_contain_compare(AnyArrayType *array1, AnyArrayType *array2, Oid collation,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	Oid			element_type = AARR_ELEMTYPE(array1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	array_iter	it1;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	if (element_type != AARR_ELEMTYPE(array2))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				 errmsg("cannot compare arrays of different element types")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * Since we probably will need to scan array2 multiple times, it's
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * worthwhile to use deconstruct_array on it.  We scan array1 the hard way
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	if (VARATT_IS_EXPANDED_HEADER(array2))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		deconstruct_expanded_array(&(array2->xpn));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		values2 = array2->xpn.dvalues;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		nulls2 = array2->xpn.dnulls;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		nelems2 = array2->xpn.nelems;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		deconstruct_array(&(array2->flt),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * Apply the comparison operator to each pair of array elements.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	nelems1 = ArrayGetNItems(AARR_NDIM(array1), AARR_DIMS(array1));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	array_iter_setup(&it1, array1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		elt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * array_eq, should we act like that?
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:arrayoverlap(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	AnyArrayType *array1 = PG_GETARG_ANY_ARRAY(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	AnyArrayType *array2 = PG_GETARG_ANY_ARRAY(1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	result = array_contain_compare(array1, array2, collation, false,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	AARR_FREE_IF_COPY(array1, 0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	AARR_FREE_IF_COPY(array2, 1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:arraycontains(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	AnyArrayType *array1 = PG_GETARG_ANY_ARRAY(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	AnyArrayType *array2 = PG_GETARG_ANY_ARRAY(1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	result = array_contain_compare(array2, array1, collation, true,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	AARR_FREE_IF_COPY(array1, 0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	AARR_FREE_IF_COPY(array2, 1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:arraycontained(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	AnyArrayType *array1 = PG_GETARG_ANY_ARRAY(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	AnyArrayType *array2 = PG_GETARG_ANY_ARRAY(1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	result = array_contain_compare(array1, array2, collation, true,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	AARR_FREE_IF_COPY(array1, 0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	AARR_FREE_IF_COPY(array2, 1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		These functions are used to iterate efficiently through arrays
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_create_iterator --- set up to iterate through an array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * datums are of the array's element type.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * returned datums are of the same array type as 'arr', but of size
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * The passed-in array must remain valid for the lifetime of the iterator.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_create_iterator(ArrayType *arr, int slice_ndim, ArrayMetaState *mstate)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		elog(ERROR, "invalid arguments to array_create_iterator");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * Remember basic info about the array and its element type
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * Get pointers into the array's dims and lbound arrays to represent
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * the dims/lbound arrays of a slice.  These are the same as the
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * rightmost N dimensions of the array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * Create workspace for building sub-arrays.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * advance through the array during array_iterate().
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * Iterate through the array referenced by 'iterator'.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_iterate(ArrayIterator iterator, Datum *value, bool *isnull)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Done if we have reached the end of the array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		if (array_get_isnull(iterator->nullbitmap, iterator->current_item++))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * Slice case: build and return an array of the requested size.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			if (array_get_isnull(iterator->nullbitmap,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		result = construct_md_array(values,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_free_iterator(ArrayIterator iterator)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * Check whether a specific array element is NULL
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * nullbitmap: pointer to array's null bitmap (NULL if none)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * offset: 0-based linear element number of array element
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_get_isnull(const bits8 *nullbitmap, int offset)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * Set a specific array element's null-bitmap entry
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * nullbitmap: pointer to array's null bitmap (mustn't be NULL)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * offset: 0-based linear element number of array element
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_set_isnull(bits8 *nullbitmap, int offset, bool isNull)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * Fetch array element at pointer, converted correctly to a Datum
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * Advance ptr over nitems array elements
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * ptr: starting location in array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * nullbitmap: start of array's null bitmap, or NULL if none
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * nitems: number of array elements to advance over (>= 0)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * typlen, typbyval, typalign: storage parameters of array element datatype
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * Compute total size of the nitems array elements starting at *ptr
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * Parameters same as for array_seek
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_nelems_size(char *ptr, int offset, bits8 *nullbitmap, int nitems,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	return array_seek(ptr, offset, nullbitmap, nitems,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * Copy nitems array elements from srcptr to destptr
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * nitems: number of array elements to copy (>= 0)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * srcptr: starting location in source array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * nullbitmap: start of source array's null bitmap, or NULL if none
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * typlen, typbyval, typalign: storage parameters of array element datatype
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_copy(char *destptr, int nitems,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	numbytes = array_nelems_size(srcptr, offset, nullbitmap, nitems,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * destbitmap: start of destination array's null bitmap (mustn't be NULL)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * srcbitmap: start of source array's null bitmap, or NULL if none
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * However, it's not clear that the typical Postgres array has enough elements
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_bitmap_copy(bits8 *destbitmap, int destoffset,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * Compute space needed for a slice of an array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_slice_size(char *arraydataptr, bits8 *arraynullsptr,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	if (typlen > 0 && !arraynullsptr)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	ptr = array_seek(arraydataptr, 0, arraynullsptr, src_offset,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			ptr = array_seek(ptr, src_offset, arraynullsptr, dist[j],
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		if (!array_get_isnull(arraynullsptr, src_offset))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * Extract a slice of an array into consecutive elements in the destination
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * of the new array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_extract_slice(ArrayType *newarray,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					char *arraydataptr,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					bits8 *arraynullsptr,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	char	   *destdataptr = ARR_DATA_PTR(newarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	bits8	   *destnullsptr = ARR_NULLBITMAP(newarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	srcdataptr = array_seek(arraydataptr, 0, arraynullsptr, src_offset,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			srcdataptr = array_seek(srcdataptr, src_offset, arraynullsptr,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		inc = array_copy(destdataptr, 1,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:						 srcdataptr, src_offset, arraynullsptr,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			array_bitmap_copy(destnullsptr, dest_offset,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:							  arraynullsptr, src_offset,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * Insert a slice into an array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * ndim/dim[]/lb[] are dimensions of the original array.  A new array with
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_insert_slice(ArrayType *destArray,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	inc = array_copy(destPtr, dest_offset,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		array_bitmap_copy(destBitmap, 0, origBitmap, 0, dest_offset);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			inc = array_copy(destPtr, dist[j],
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				array_bitmap_copy(destBitmap, dest_offset,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		inc = array_copy(destPtr, 1,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			array_bitmap_copy(destBitmap, dest_offset,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		origPtr = array_seek(origPtr, orig_offset, origBitmap, 1,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	array_copy(destPtr, orignitems - orig_offset,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		array_bitmap_copy(destBitmap, dest_offset,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	element_type is the array element type (must be a valid array element type)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * that you can pass to makeArrayResult; you get an empty array if there
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * were no elements.  This is preferred if an empty array is what you want.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array build state, or whether to allocate it directly within rcontext.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * When there are many concurrent small states (e.g. array_agg() using hash
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * context to initialize all such array build states, and pass
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * In cases when the array build states have different lifetimes, using a
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * the array build states can be freed individually.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	astate->alen = (subcontext ? 64 : 8);	/* arbitrary starting array size */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * accumArrayResult - accumulate one (more) Datum for an array result
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	dvalue/disnull represent the new Datum to append to the array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	element_type is the Datum's type (must be a valid array element type)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * because construct_md_array can detoast the array elements later.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * However, we must not let construct_md_array modify the ArrayBuildState
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * because that would mean array_agg_finalfn damages its input, which is
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* If no elements were presented, we want to create an empty array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Build the final array result in rcontext */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	result = construct_md_array(astate->dvalues,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * inputs that are array elements, they accept inputs that are arrays and
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * produce an output array having N+1 dimensions.  The inputs must all have
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	array_type is the array type (must be a valid varlena array type)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	element_type is the type of the array's elements (lookup if InvalidOid)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:initArrayResultArr(Oid array_type, Oid element_type, MemoryContext rcontext,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		element_type = get_element_type(array_type);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errmsg("data type %s is not an array type",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:							format_type_be(array_type))));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	astate->array_type = array_type;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * accumArrayResultArr - accumulate one (more) sub-array for an array result
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	dvalue/disnull represent the new sub-array to append to the array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	array_type is the array type (must be a valid varlena array type)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					Oid array_type,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * We disallow accumulating null subarrays.  Another plausible definition
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				 errmsg("cannot accumulate null arrays")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Detoast input array in caller's context */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		astate = initArrayResultArr(array_type, InvalidOid, rcontext, true);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		Assert(astate->array_type == array_type);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errmsg("cannot accumulate empty arrays")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errmsg("number of array dimensions (%d) exceeds the maximum allowed (%d)",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * The output array will have n+1 dimensions, with the ones after the
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errmsg("cannot accumulate arrays of different dimensionality")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:						 errmsg("cannot accumulate arrays of different dimensionality")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * Copy the data portion of the sub-array.  Note we assume that the
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * advertised data length of the sub-array is properly aligned.  We do not
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * sub-array should be OK already.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			array_bitmap_copy(astate->nullbitmap, 0,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		array_bitmap_copy(astate->nullbitmap, astate->nitems,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Build the final array result in rcontext */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		/* No inputs, return empty array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		result = construct_empty_array(astate->element_type);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			array_bitmap_copy(ARR_NULLBITMAP(result), 0,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * scalar or array inputs, invoking the appropriate set of functions above.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	input_type is the input datatype (either element or array type)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		ArrayBuildStateArr *arraystate;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		arraystate = initArrayResultArr(input_type, InvalidOid, rcontext, subcontext);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			MemoryContextAlloc(arraystate->mcontext,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		astate->arraystate = arraystate;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		/* Let's just check that we have a type that can be put into arrays */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		Assert(OidIsValid(get_array_type(input_type)));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		astate->arraystate = NULL;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * accumArrayResultAny - accumulate one (more) input for an array result
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	dvalue/disnull represent the new input to append to the array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *	input_type is the input datatype (either element or array type)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		(void) accumArrayResultArr(astate->arraystate,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		/* If no elements were presented, we want to create an empty array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		result = makeArrayResultArr(astate->arraystate,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_larger(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	if (array_cmp(fcinfo) > 0)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_smaller(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	if (array_cmp(fcinfo) < 0)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * generate_subscripts(array anyarray, dim int [, reverse bool])
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		Returns all subscripts of the array for any dimension
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		/* Sanity check: does it look like an array at all? */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_fill_with_lower_bounds
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		Create and fill array with defined lower bounds.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_fill_with_lower_bounds(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				 errmsg("dimension array or low bound array cannot be null")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	result = array_fill_internal(dims, lbs, value, isnull, elmtype, fcinfo);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_fill
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: *		Create and fill array with default lower bounds.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_fill(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				 errmsg("dimension array or low bound array cannot be null")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	result = array_fill_internal(dims, NULL, value, isnull, elmtype, fcinfo);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:create_array_envelope(int ndims, int *dimv, int *lbsv, int nbytes,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_fill_internal(ArrayType *dims, ArrayType *lbs,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				 errmsg("wrong number of array subscripts"),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				 errdetail("Dimension array must be one dimensional.")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	if (array_contains_nulls(dims))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	if (ndims < 0)				/* we do allow zero-dimension arrays */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				 errmsg("number of array dimensions (%d) exceeds the maximum allowed (%d)",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errmsg("wrong number of array subscripts"),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errdetail("Dimension array must be one dimensional.")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		if (array_contains_nulls(lbs))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errmsg("wrong number of array subscripts"),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errdetail("Low bound array has different size than dimensions array.")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* fast track for empty array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		return construct_empty_array(elmtype);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:					 errmsg("array size exceeds the maximum allowed (%d)",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		result = create_array_envelope(ndims, dimv, lbsv, totbytes,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		result = create_array_envelope(ndims, dimv, lbsv, nbytes,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		/* create_array_envelope already zeroed the bitmap, so we're done */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_unnest(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		array_iter	iter;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	} array_unnest_fctx;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	array_unnest_fctx *fctx;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * Get the array value and detoast if needed.  We can't do this
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * passed array will stick around till then.)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		fctx = (array_unnest_fctx *) palloc(sizeof(array_unnest_fctx));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		array_iter_setup(&fctx->iter, arr);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			/* we can just grab the type data from expanded array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		elem = array_iter_next(&fctx->iter, &fcinfo->isnull, offset,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * array_replace/array_remove support
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * Find all array entries matching (not distinct from) search/search_isnull,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_replace_internal(ArrayType *array,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	char	   *arraydataptr;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	element_type = ARR_ELEMTYPE(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	ndim = ARR_NDIM(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	dim = ARR_DIMS(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Return input array unmodified if it is empty */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		return array;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * We can't remove elements from multi-dimensional arrays, since the
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				 errmsg("removing elements from multidimensional arrays is not supported")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * detoasted for insertion into the result array, while detoasting the
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Allocate temporary arrays for new values */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	arraydataptr = ARR_DATA_PTR(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	bitmap = ARR_NULLBITMAP(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			elt = fetch_att(arraydataptr, typbyval, typlen);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			arraydataptr = att_addlength_datum(arraydataptr, typlen, elt);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			arraydataptr = (char *) att_align_nominal(arraydataptr, typalign);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:							 errmsg("array size exceeds the maximum allowed (%d)",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * If not changed just return the original array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		return array;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* If all elements were removed return an empty array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		return construct_empty_array(element_type);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Allocate and initialize the result array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	memcpy(ARR_DIMS(result), ARR_DIMS(array), ndim * sizeof(int));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	memcpy(ARR_LBOUND(result), ARR_LBOUND(array), ndim * sizeof(int));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	/* Insert data into result array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * Remove any occurrences of an element from an array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * If used on a multi-dimensional array this will raise an error.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_remove(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	ArrayType  *array;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	array = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	array = array_replace_internal(array,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	PG_RETURN_ARRAYTYPE_P(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * Replace any occurrences of an element in an array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:array_replace(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	ArrayType  *array;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	array = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	array = array_replace_internal(array,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	PG_RETURN_ARRAYTYPE_P(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * Implements width_bucket(anyelement, anyarray).
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * 'thresholds' is an array containing lower bound values for each bucket;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:width_bucket_array(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				 errmsg("thresholds must be one-dimensional array")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	if (array_contains_nulls(thresholds))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:				 errmsg("thresholds array must not contain NULLs")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		result = width_bucket_array_float8(operand, thresholds);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		 * types, since indexing the array is a lot cheaper in the first case.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			result = width_bucket_array_fixed(operand, thresholds,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			result = width_bucket_array_variable(operand, thresholds,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * width_bucket_array for float8 data.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:width_bucket_array_float8(Datum operand, ArrayType *thresholds)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * Since we know the array contains no NULLs, we can just index it
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * that this would give the same result as searching even if the array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * width_bucket_array for generic fixed-width data types.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:width_bucket_array_fixed(Datum operand,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:	 * Since we know the array contains no NULLs, we can just index it
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c: * width_bucket_array for generic variable-width data types.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:width_bucket_array_variable(Datum operand,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:		/* Locate mid'th array element by advancing from left element */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/arrayfuncs.c:			 * ensures we do only O(N) array indexing work, not O(N^2).
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/regexp.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:static Datum text_to_array_internal(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:static text *array_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c: *		byteain			- converts from printable representation of byte array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c: *		byteaout		- converts to printable representation of byte array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:	start_pos--;				/* adjust for zero based arrays */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c: * this routine treats "bytea" as an array of bytes.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c: * This routine treats a "bytea" type like an array of bits.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c: * text_to_array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c: * parse input string and return text array of elements,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:text_to_array(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:	return text_to_array_internal(fcinfo);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c: * text_to_array_null
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c: * parse input string and return text array of elements,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:text_to_array_null(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:	return text_to_array_internal(fcinfo);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c: * common code for text_to_array and text_to_array_null functions
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:text_to_array_internal(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:		/* return empty array for empty input string */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:			PG_RETURN_ARRAYTYPE_P(construct_empty_array(TEXTOID));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:		 * array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:			PG_RETURN_ARRAYTYPE_P(construct_md_array(elems, nulls,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:		 * element in the result array.  The separator is effectively the
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:		/* return empty array for empty input string */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:			PG_RETURN_ARRAYTYPE_P(construct_empty_array(TEXTOID));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c: * array_to_text
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c: * concatenate Cstring representation of input array elements
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:array_to_text(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:	PG_RETURN_TEXT_P(array_to_text_internal(fcinfo, v, fldsep, NULL));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c: * array_to_text_null
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c: * concatenate Cstring representation of input array elements
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:array_to_text_null(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:	PG_RETURN_TEXT_P(array_to_text_internal(fcinfo, v, fldsep, null_string));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c: * common code for array_to_text and array_to_text_null functions
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:array_to_text_internal(FunctionCallInfo fcinfo, ArrayType *v,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:	 * concat(VARIADIC some-array) is essentially equivalent to
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:	 * array_to_text(), ie concat the array elements with the given separator.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:		 * Non-null argument had better be an array.  We assume that any call
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:		 * checked that a VARIADIC-labeled parameter actually is an array.  So
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:		 * it should be okay to just Assert that it's an array rather than
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:		/* OK, safe to fetch the array value */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:		 * And serialize the array.  We tell array_to_text to ignore null
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:		return array_to_text_internal(fcinfo, arr, sepstr, NULL);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:	/* If argument is marked VARIADIC, expand array into elements */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:		/* If argument is NULL, we treat it as zero-length array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:			 * Non-null argument had better be an array.  We assume that any
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:			 * an array.  So it should be okay to just Assert that it's an
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:			 * array rather than doing a full-fledged error check.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:			/* OK, safe to fetch the array value */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:			/* Get info about array element type */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:			/* Extract all array elements */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:			deconstruct_array(arr, element_type, elmlen, elmbyval, elmalign,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:		 * variadic-array case, but often saves work even for ordinary calls.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varlena.c:	/* Don't need deconstruct_array results anymore. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsquery.c:			 * here we just collect them to an array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/misc.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/misc.c:	/* Did we get a VARIADIC array argument, or separate arguments? */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/misc.c:		 * If we get a null as VARIADIC array argument, we can't say anything
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/misc.c:		 * Non-null argument had better be an array.  We assume that any call
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/misc.c:		 * checked that a VARIADIC-labeled parameter actually is an array.  So
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/misc.c:		 * it should be okay to just Assert that it's an array rather than
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/misc.c:		/* OK, safe to fetch the array value */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/misc.c:		/* Count the array elements */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c: * Maximum number of elements in an array (or key/value pairs in an object).
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c: * This is limited by two things: the size of the JEntry array must fit
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c: * (The total size of an array's or object's elements is also limited by
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:		scalarArray.val.array.rawScalar = true;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:		scalarArray.val.array.nElems = 1;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c: * by index within the container's JEntry array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c: * The node is identified by index within the container's JEntry array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:				 * There is no array or object to compare at this stage of
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:						 * This could be a "raw scalar" pseudo array.  That's
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:						 * as we're concerned a pseudo array is just a scalar.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:						if (va.val.array.rawScalar != vb.val.array.rawScalar)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:							res = (va.val.array.rawScalar) ? -1 : 1;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:						if (va.val.array.nElems != vb.val.array.nElems)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:							res = (va.val.array.nElems > vb.val.array.nElems) ? 1 : -1;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c: * object), or find a matching element if we're looking through an array.  Do
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c: * Otherwise, for an array, any type of JsonbValue will do.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c: * most one can make sense, because the container either points to an array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c: * (possibly a "raw scalar" pseudo array) or an object.)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c: * object, but we never do so on an array.  If the caller asks to look through
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:	/* Quick out without a palloc cycle if object/array is empty */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c: * Get i-th value of a Jsonb array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:		elog(ERROR, "not a jsonb array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c: * array, or a key or value of an object.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c: * A nested array or object will be returned as jbvBinary, ie. it won't be
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c: * "raw scalar" pseudo array to append it - the actual scalar should be passed
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c: * next and it will be added as the only member of the array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c: * Values of type jvbBinary, which are rolled up arrays and objects,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c: * Do the actual pushing, with only scalar or pseudo-scalar-array values
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:			Assert(!scalarVal || scalarVal->val.array.rawScalar);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:			(*pstate)->contVal.val.array.nElems = 0;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:			(*pstate)->contVal.val.array.rawScalar = (scalarVal &&
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:													  scalarVal->val.array.rawScalar);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:			if (scalarVal && scalarVal->val.array.nElems > 0)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:				/* Assume that this array is still really a scalar */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:				(*pstate)->size = scalarVal->val.array.nElems;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:			(*pstate)->contVal.val.array.elems = palloc(sizeof(JsonbValue) *
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:			 * Pop stack and push current array/object as value in parent
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:			 * array/object
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:	JsonbValue *array = &pstate->contVal;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:	Assert(array->type == jbvArray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:	if (array->val.array.nElems >= JSONB_MAX_ELEMS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:				 errmsg("number of jsonb array elements exceeds the maximum allowed (%zu)",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:	if (array->val.array.nElems >= pstate->size)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:		array->val.array.elems = repalloc(array->val.array.elems,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:	array->val.array.elems[array->val.array.nElems++] = *scalarVal;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c: * with it.  However, clients should not take it upon themselves to touch array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:			/* Set v to array on first array call */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:			val->val.array.nElems = (*it)->nElems;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:			 * v->val.array.elems is not actually set, because we aren't doing
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:			val->val.array.rawScalar = (*it)->isScalar;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:				 * All elements within array already processed.  Report this
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:				 * Scalar item in array, or a container and caller didn't want
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:			/* This is either a "raw scalar", or an array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:		 * optimization in the array case.)  The case probably won't arise
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:				/* Nested container value (object or array) */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:		uint32		nLhsElems = vval.val.array.nElems;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:		 * Handle distinction between "raw scalar" pseudo arrays, and real
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:		 * arrays.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:		 * A raw scalar may contain another raw scalar, and an array may
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:		 * contain a raw scalar, but a raw scalar may not contain an array. We
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:		if (vval.val.array.rawScalar && !vcontained.val.array.rawScalar)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:		/* Work through rhs "is it contained within?" array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:			 * array without failing to find one of its values, it's
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:				 * If this is first container found in rhs array (at this
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:				 * depth), initialize temp lhs array of containers
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:						/* Store all lhs elements in temp array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:					/* No container elements in temp array, so give up now */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:					/* We may have only partially filled array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:				/* XXX: Nested array containment is O(N^2) */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:					/* Nested container value (object or array) */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c: * If the value is an array or an object, this recurses. 'level' is only used
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:	int			nElems = val->val.array.nElems;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:	/* Remember where in the buffer this array starts. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:	if (val->val.array.rawScalar)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:		JsonbValue *elem = &val->val.array.elems[i];
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:					 errmsg("total size of jsonb array elements exceeds the maximum of %u bytes",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:				 errmsg("total size of jsonb array elements exceeds the maximum of %u bytes",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:	/* Initialize the header of this node in the container's JEntry array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonb_util.c:	/* Initialize the header of this node in the container's JEntry array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	int			npath;			/* length of each path-related array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	int		   *path_indexes;	/* array index(es) being sought */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	int		   *array_cur_index;	/* current element index at each path
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:/* state for json_array_length */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:/* state for json_array_elements */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:/* structure to cache metadata needed for populate_array() */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	Oid			element_type;	/* array element type id */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	int32		element_typmod; /* array element type modifier */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		ArrayIOData array;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:/* common data for populate_array_json() and populate_array_dim_jsonb() */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	ArrayBuildState *astate;	/* array build state */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	MemoryContext acxt;			/* array build memory context */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:/* state for populate_array_json() */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	char	   *element_start;	/* start of the current array element */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	char	   *element_scalar; /* current array element token if it is a
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	JsonTokenType element_type; /* current array element type */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void okeys_array_start(void *state);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void get_array_start(void *state);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void get_array_end(void *state);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void get_array_element_start(void *state, bool isnull);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void get_array_element_end(void *state, bool isnull);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:/* semantic action functions for json_array_length */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void alen_array_element_start(void *state, bool isnull);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void each_array_start(void *state);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:/* common workers for json{b}_array_elements_* functions */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:/* semantic action functions for json_array_elements */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void elements_array_element_start(void *state, bool isnull);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void elements_array_element_end(void *state, bool isnull);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:/* semantic actions for populate_array_json */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void populate_array_object_start(void *_state);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void populate_array_array_end(void *_state);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void populate_array_element_start(void *_state, bool isnull);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void populate_array_element_end(void *_state, bool isnull);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void populate_array_scalar(void *_state, char *token, JsonTokenType tokentype);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void hash_array_start(void *state);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void populate_recordset_array_start(void *state);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void populate_recordset_array_element_start(void *state, bool isnull);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void sn_array_start(void *state);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void sn_array_end(void *state);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void sn_array_element_start(void *state, bool isnull);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void populate_array_json(PopulateArrayContext *ctx, char *json, int len);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void populate_array_dim_jsonb(PopulateArrayContext *ctx, JsonbValue *jbv,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void populate_array_check_dimension(PopulateArrayContext *ctx, int ndim);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static Datum populate_array(ArrayIOData *aio, const char *colname,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void transform_string_values_array_start(void *state);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void transform_string_values_array_end(void *state);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:static void transform_string_values_array_element_start(void *state, bool isnull);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c: * in an array, whose size is expanded as necessary. This is probably
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:					 errmsg("cannot call %s on an array",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		sem->array_start = okeys_array_start;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	/* enlarge result array if necessary */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:okeys_array_start(void *state)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:				 errmsg("cannot call %s on an array",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:json_array_element(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:jsonb_array_element(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:json_array_element_text(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:jsonb_array_element_text(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	 * If the array contains any null elements, return NULL, on the grounds
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	 * regardless of the contents of the rest of the array.)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	if (array_contains_nulls(path))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	deconstruct_array(path, TEXTOID, -1, false, 'i',
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c: * ipath[]: array index(es) (zero-based) to extract, accepts negatives
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c: * be NULL, or any one ipath[] entry can be INT_MIN if an array element is
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	state->array_cur_index = palloc(sizeof(int) * npath);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		sem->array_start = get_array_start;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		sem->array_end = get_array_end;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		sem->array_start = get_array_start;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		sem->array_element_start = get_array_element_start;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		sem->array_element_end = get_array_element_end;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		 * been started by the outer field or array element callback.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:get_array_start(void *state)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		/* Initialize counting of elements in this array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		_state->array_cur_index[lex_level] = -1;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:			int			nelements = json_count_array_elements(_state->lex);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		 * Special case: we should match the entire array.  We only need this
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		 * been started by the outer field or array element callback.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:get_array_end(void *state)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		/* Special case: return the entire array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:get_array_element_start(void *state, bool isnull)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	/* Update array element counter */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		_state->array_cur_index[lex_level - 1]++;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		_state->array_cur_index[lex_level - 1] == _state->path_indexes[lex_level - 1])
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:get_array_element_end(void *state, bool isnull)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	/* same tests as in get_array_element_start */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		_state->array_cur_index[lex_level - 1] == _state->path_indexes[lex_level - 1])
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:				have_array = false;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	 * If the array contains any null elements, return NULL, on the grounds
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	 * regardless of the contents of the rest of the array.)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	if (array_contains_nulls(path))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	deconstruct_array(path, TEXTOID, -1, false, 'i',
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	/* Identify whether we have object, array, or scalar at top-level */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		have_array = true;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	 * If the array is empty, return the entire LHS object, on the grounds
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		else if (have_array)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:				/* Container must be array, but make sure */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:					elog(ERROR, "not a jsonb array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:			have_array = r == WJB_BEGIN_ARRAY;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:			have_array = jbvp->type == jbvArray;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c: * SQL function json_array_length(json) -> int
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:json_array_length(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	sem->array_element_start = alen_array_element_start;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:jsonb_array_length(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:				 errmsg("cannot get array length of a scalar")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:				 errmsg("cannot get array length of a non-array")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c: * These next two checks ensure that the json is an array (since it can't be
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:				 errmsg("cannot get array length of a non-array")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:				 errmsg("cannot get array length of a scalar")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:alen_array_element_start(void *state, bool isnull)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	sem->array_start = each_array_start;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:each_array_start(void *state)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:				 errmsg("cannot deconstruct an array as an object")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c: * SQL functions json_array_elements and json_array_elements_text
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c: * get the elements from a json array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:jsonb_array_elements(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	return elements_worker_jsonb(fcinfo, "jsonb_array_elements", false);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:jsonb_array_elements_text(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	return elements_worker_jsonb(fcinfo, "jsonb_array_elements_text", true);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:									"jsonb_array_elements temporary cxt",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:json_array_elements(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	return elements_worker(fcinfo, "json_array_elements", false);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:json_array_elements_text(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	return elements_worker(fcinfo, "json_array_elements_text", true);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	sem->array_element_start = elements_array_element_start;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	sem->array_element_end = elements_array_element_end;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:										   "json_array_elements temporary cxt",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:elements_array_element_start(void *state, bool isnull)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		 * next_scalar will be reset in the array_element_end handler, and
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:elements_array_element_end(void *state, bool isnull)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:				 errmsg("cannot call %s on a non-array",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:populate_array_report_expected_array(PopulateArrayContext *ctx, int ndim)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:					 errmsg("expected json array"),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:					 errmsg("expected json array")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:					 errmsg("expected json array"),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:					 errhint("See the array element %s of key \"%s\".",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:					 errmsg("expected json array"),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:					 errhint("See the array element %s.",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:/* set the number of dimensions of the populated array when it becomes known */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:populate_array_assign_ndims(PopulateArrayContext *ctx, int ndims)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		populate_array_report_expected_array(ctx, ndims);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:/* check the populated subarray dimension */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:populate_array_check_dimension(PopulateArrayContext *ctx, int ndim)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:				 errmsg("malformed json array"),
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:				 errdetail("Multidimensional arrays must have "
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:						   "sub-arrays with matching dimensions.")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	/* reset the current array dimension size counter */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	/* increment the parent dimension counter if it is a nested sub-array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:populate_array_element(PopulateArrayContext *ctx, int ndim, JsValue *jsv)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	/* populate the array element */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:/* json object start handler for populate_array_json() */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:populate_array_object_start(void *_state)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		populate_array_assign_ndims(state->ctx, ndim);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		populate_array_report_expected_array(state->ctx, ndim);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:/* json array end handler for populate_array_json() */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:populate_array_array_end(void *_state)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		populate_array_assign_ndims(ctx, ndim + 1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		populate_array_check_dimension(ctx, ndim);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:/* json array element start handler for populate_array_json() */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:populate_array_element_start(void *_state, bool isnull)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		/* remember current array element start */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:/* json array element end handler for populate_array_json() */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:populate_array_element_end(void *_state, bool isnull)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		populate_array_element(ctx, ndim, &jsv);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:/* json scalar handler for populate_array_json() */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:populate_array_scalar(void *_state, char *token, JsonTokenType tokentype)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		populate_array_assign_ndims(ctx, ndim);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		populate_array_report_expected_array(ctx, ndim);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		/* element_type must already be set in populate_array_element_start() */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:/* parse a json array and populate array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:populate_array_json(PopulateArrayContext *ctx, char *json, int len)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	sem.object_start = populate_array_object_start;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	sem.array_end = populate_array_array_end;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	sem.array_element_start = populate_array_element_start;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	sem.array_element_end = populate_array_element_end;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	sem.scalar = populate_array_scalar;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c: * populate_array_dim_jsonb() -- Iterate recursively through jsonb sub-array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:populate_array_dim_jsonb(PopulateArrayContext *ctx, /* context */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:						 JsonbValue *jbv,	/* jsonb sub-array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		populate_array_report_expected_array(ctx, ndim - 1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	 * the array, or the first child element is not an array, then assign the
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		populate_array_assign_ndims(ctx, ndim);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	/* process all the array elements */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:			populate_array_element(ctx, ndim, &jsv);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:			/* populate child sub-array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:			populate_array_dim_jsonb(ctx, &val, ndim + 1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:			populate_array_check_dimension(ctx, ndim);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:/* recursively populate an array from json/jsonb */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:populate_array(ArrayIOData *aio,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		populate_array_json(&ctx, jsv->val.json.str,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		populate_array_dim_jsonb(&ctx, jsv->val.jsonb, 1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:					 : errmsg("cannot call %s on an array",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		column->io.array.element_info = MemoryContextAllocZero(mcxt,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		column->io.array.element_type = type->typelem;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		/* array element typemod stored in attribute's typmod */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		column->io.array.element_typmod = typmod;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:/* recursively populate a record field or an array element from a json/jsonb value */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:			return populate_array(&col->io.array, colname, mcxt, jsv);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	sem->array_start = hash_array_start;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:hash_array_start(void *state)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:				 errmsg("cannot call %s on an array", _state->function_name)));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c: * which must be an array of objects.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c: * per object in the array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		sem->array_start = populate_recordset_array_start;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		sem->array_element_start = populate_recordset_array_element_start;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:					 errmsg("cannot call %s on a non-array",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:							 errmsg("argument of %s must be an array of objects",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	/* Reject object at top level: we must have an array at level 0 */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:populate_recordset_array_element_start(void *state, bool isnull)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:				 errmsg("argument of %s must be an array of objects",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:populate_recordset_array_start(void *state)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:sn_array_start(void *state)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:sn_array_end(void *state)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		 * object or array. The flag will be reset in the scalar action.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:sn_array_element_start(void *state, bool isnull)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	sem->array_start = sn_array_start;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	sem->array_end = sn_array_end;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	sem->array_element_start = sn_array_element_start;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		(void) JsonbIteratorNext(&it, &v, false);	/* skip array header */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:jsonb_delete_array(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:				 errmsg("wrong number of array subscripts")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	deconstruct_array(keys, TEXTOID, -1, false, 'i',
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	n = v.val.array.nElems;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:				 errmsg("wrong number of array subscripts")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	deconstruct_array(path, TEXTOID, -1, false, 'i',
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:				 errmsg("wrong number of array subscripts")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	deconstruct_array(path, TEXTOID, -1, false, 'i',
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:				 errmsg("wrong number of array subscripts")));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	deconstruct_array(path, TEXTOID, -1, false, 'i',
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	 * Both elements are arrays (either can be scalar).
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	/* have we got array || object or object || array? */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		JsonbIterator **it_array = rk1 == WJB_BEGIN_ARRAY ? it1 : it2;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:			while ((r2 = JsonbIteratorNext(it_array, &v2, true)) != 0)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:			while ((r1 = JsonbIteratorNext(it_array, &v1, true)) != WJB_END_ARRAY)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c: * we create the new value if the key or array index does not exist.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:						 newval, v.val.array.nElems, op_type);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	 * array also if the array is empty - in which case we don't really care
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	/* iterate over the array elements */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:		res->val.array.rawScalar = is_scalar;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	sem->array_start = transform_string_values_array_start;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	sem->array_end = transform_string_values_array_end;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:	sem->array_element_start = transform_string_values_array_element_start;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:transform_string_values_array_start(void *state)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:transform_string_values_array_end(void *state)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.c:transform_string_values_array_element_start(void *state, bool isnull)
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/timestamp.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/network_gist.c: * Examine the keys in elements m..n inclusive of the GISTENTRY array,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/network_gist.c: * indices listed in the offsets[] array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector.c: * Sort an array of WordEntryIN, remove duplicates.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector.c:				elog(ERROR, "positions array too long");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsvector.c:		 * the strings in the TSVector array are not null-terminated, so we
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varbit.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varbit.c: * External format is the bitlen as an int32, then the byte array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/varbit.c: * returns the value of the Nth bit of a bit array (0 or 1).
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/orderedsetaggs.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/format_type.c:	Oid			array_base_type;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/format_type.c:	bool		is_array;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/format_type.c:	 * Check if it's a regular (variable length) array type.  Fixed-length
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/format_type.c:	 * array types such as "name" shouldn't get deconstructed.  As of Postgres
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/format_type.c:	 * deconstruct "plain storage" array types --- this is because we don't
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/format_type.c:	array_base_type = typeform->typelem;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/format_type.c:	if (array_base_type != InvalidOid &&
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/format_type.c:		/* Switch our attention to the array element type */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/format_type.c:		tuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(array_base_type));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/format_type.c:		type_oid = array_base_type;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/format_type.c:		is_array = true;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/format_type.c:		is_array = false;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/format_type.c:	if (is_array)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c: * array_expanded.c
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c: *	  Basic functions for manipulating expanded arrays.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c: *	  src/backend/utils/adt/array_expanded.c
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:static void copy_byval_expanded_array(ExpandedArrayHeader *eah,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c: * expand_array: convert an array Datum into an expanded array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:expand_array(Datum arraydatum, MemoryContext parentcontext,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	ArrayType  *array;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	 * that the array won't be very large; but if it does grow a lot, don't
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:								   "expanded array",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	/* Set up expanded array header */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	/* If the source is an expanded array, we may be able to optimize */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	if (VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(arraydatum)))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:		ExpandedArrayHeader *oldeah = (ExpandedArrayHeader *) DatumGetEOHP(arraydatum);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:		 * next call might be for a non-expanded source array.  Furthermore,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:		 * If element type is pass-by-value and we have a Datum-array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:		 * arrays.  The original flat array, if present at all, adds no
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:			copy_byval_expanded_array(eah, oldeah);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:			/* return a R/W pointer to the expanded array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	 * Detoast and copy source array into private context, as a flat array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	 * which seems worthwhile, especially if the array is large enough to need
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	array = DatumGetArrayTypePCopy(arraydatum);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	eah->ndims = ARR_NDIM(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	eah->dims = ARR_DIMS(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	eah->lbound = ARR_LBOUND(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	/* Save array's element-type data for possible use later */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	eah->element_type = ARR_ELEMTYPE(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	eah->fvalue = array;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	eah->fstartptr = ARR_DATA_PTR(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	eah->fendptr = ((char *) array) + ARR_SIZE(array);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	/* return a R/W pointer to the expanded array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c: * helper for expand_array(): copy pass-by-value Datum-array representation
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:copy_byval_expanded_array(ExpandedArrayHeader *eah,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	/* Copy array dimensionality information */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	/* We can alloc both dimensionality arrays with one palloc */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	/* .. but don't assume the source's arrays are contiguous */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c: * get_flat_size method for expanded arrays
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	 * array will have a nulls bitmap if dnulls isn't NULL, even if the array
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:					 errmsg("array size exceeds the maximum allowed (%d)",
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c: * flatten_into method for expanded arrays
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	/* Fill result array from dvalues/dnulls */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c: * DatumGetExpandedArray: get a writable expanded array from an input argument
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c: * they cannot leave the array in a corrupt state.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	/* If it's a writable expanded array already, just return it */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	d = expand_array(d, CurrentMemoryContext, NULL);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	/* If it's a writable expanded array already, just return it */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	d = expand_array(d, CurrentMemoryContext, metacache);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c: * DatumGetAnyArray: return either an expanded array or a detoasted varlena
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c: * array.  The result must not be modified in-place.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:	 * If it's an expanded array (RW or RO), return the header pointer.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c: * Create the Datum/isnull representation of an expanded array object
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:deconstruct_expanded_array(ExpandedArrayHeader *eah)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:		deconstruct_array(eah->fvalue,
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.c:		 * deconstruct_array fails partway through, worst consequence is some
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/int.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/int.c: * construct int2vector given a raw array of int2s
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/int.c:	 * Attach standard array header.  For historical reasons, we set the index
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/int.c:	 * Normally one would call array_recv() using DirectFunctionCall3, but
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/int.c:	 * that does not work since array_recv wants to cache some data using
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/int.c:	result = (int2vector *) DatumGetPointer(array_recv(&locfcinfo));
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/int.c:	return array_send(fcinfo);
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/oid.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/selfuncs.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pg_upgrade_support.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pg_upgrade_support.c:binary_upgrade_set_next_array_pg_type_oid(PG_FUNCTION_ARGS)
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pg_upgrade_support.c:	binary_upgrade_next_array_pg_type_oid = typoid;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pg_upgrade_support.c:		deconstruct_array(textArray,
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/pg_upgrade_support.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/array_expanded.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/adt/jsonfuncs.o matches
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c: * NumericVar is the format we use for arithmetic.  The digit-array part
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c: * ndigits, and digits[] array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c: * is a two-element int8 array, holding count and sum.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	ArrayType  *transarray;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:		transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:		transarray = PG_GETARG_ARRAYTYPE_P_COPY(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	if (ARR_HASNULL(transarray) ||
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:		ARR_SIZE(transarray) != ARR_OVERHEAD_NONULLS(1) + sizeof(Int8TransTypeData))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:		elog(ERROR, "expected 2-element int8 array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	transdata = (Int8TransTypeData *) ARR_DATA_PTR(transarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	PG_RETURN_ARRAYTYPE_P(transarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	ArrayType  *transarray;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:		transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:		transarray = PG_GETARG_ARRAYTYPE_P_COPY(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	if (ARR_HASNULL(transarray) ||
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:		ARR_SIZE(transarray) != ARR_OVERHEAD_NONULLS(1) + sizeof(Int8TransTypeData))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:		elog(ERROR, "expected 2-element int8 array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	transdata = (Int8TransTypeData *) ARR_DATA_PTR(transarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	PG_RETURN_ARRAYTYPE_P(transarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	ArrayType  *transarray1;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	ArrayType  *transarray2;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	transarray1 = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	transarray2 = PG_GETARG_ARRAYTYPE_P(1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	if (ARR_HASNULL(transarray1) ||
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:		ARR_SIZE(transarray1) != ARR_OVERHEAD_NONULLS(1) + sizeof(Int8TransTypeData))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:		elog(ERROR, "expected 2-element int8 array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	if (ARR_HASNULL(transarray2) ||
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:		ARR_SIZE(transarray2) != ARR_OVERHEAD_NONULLS(1) + sizeof(Int8TransTypeData))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:		elog(ERROR, "expected 2-element int8 array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	state1 = (Int8TransTypeData *) ARR_DATA_PTR(transarray1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	state2 = (Int8TransTypeData *) ARR_DATA_PTR(transarray2);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	PG_RETURN_ARRAYTYPE_P(transarray1);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	ArrayType  *transarray;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:		transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:		transarray = PG_GETARG_ARRAYTYPE_P_COPY(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	if (ARR_HASNULL(transarray) ||
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:		ARR_SIZE(transarray) != ARR_OVERHEAD_NONULLS(1) + sizeof(Int8TransTypeData))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:		elog(ERROR, "expected 2-element int8 array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	transdata = (Int8TransTypeData *) ARR_DATA_PTR(transarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	PG_RETURN_ARRAYTYPE_P(transarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	ArrayType  *transarray;
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:		transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:		transarray = PG_GETARG_ARRAYTYPE_P_COPY(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	if (ARR_HASNULL(transarray) ||
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:		ARR_SIZE(transarray) != ARR_OVERHEAD_NONULLS(1) + sizeof(Int8TransTypeData))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:		elog(ERROR, "expected 2-element int8 array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	transdata = (Int8TransTypeData *) ARR_DATA_PTR(transarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	PG_RETURN_ARRAYTYPE_P(transarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	ArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	if (ARR_HASNULL(transarray) ||
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:		ARR_SIZE(transarray) != ARR_OVERHEAD_NONULLS(1) + sizeof(Int8TransTypeData))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:		elog(ERROR, "expected 2-element int8 array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	transdata = (Int8TransTypeData *) ARR_DATA_PTR(transarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	ArrayType  *transarray = PG_GETARG_ARRAYTYPE_P(0);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	if (ARR_HASNULL(transarray) ||
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:		ARR_SIZE(transarray) != ARR_OVERHEAD_NONULLS(1) + sizeof(Int8TransTypeData))
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:		elog(ERROR, "expected 2-element int8 array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	transdata = (Int8TransTypeData *) ARR_DATA_PTR(transarray);
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c: *	Initialize a variable from packed db format. The digits array is not
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	dest->buf = NULL;			/* digits array is not palloc'd */
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	 * accumulator array needs to be normalized.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	 * We do the arithmetic in an array "dig[]" of signed int's.  Since
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	 * i1+i2+2 of the accumulator array, so we need only consider digits of
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/numeric.c:	 * We do the arithmetic in an array "div[]" of signed int's.  Since
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsquery_util.c: * Build QTNode tree for a tsquery given in QueryItem array format.
/srvr/z5089358/postgresql-10.4/src/backend/utils/adt/tsquery_util.c: * Caller must have allocated arrays of the correct size.
/srvr/z5089358/postgresql-10.4/src/backend/utils/mb/Unicode/convutils.pm:# charset     - ref to character set array
/srvr/z5089358/postgresql-10.4/src/backend/utils/mb/Unicode/convutils.pm:# Input character set array format:
/srvr/z5089358/postgresql-10.4/src/backend/utils/mb/Unicode/convutils.pm:# Each element in the character set array is a hash. Each hash has the following fields:
/srvr/z5089358/postgresql-10.4/src/backend/utils/mb/Unicode/convutils.pm:# charset     - ref to character set array
/srvr/z5089358/postgresql-10.4/src/backend/utils/mb/Unicode/convutils.pm:	### The segments are written out physically to one big array in the final
/srvr/z5089358/postgresql-10.4/src/backend/utils/mb/Unicode/convutils.pm:	### of the final array. You cannot move, add, or remove segments after
/srvr/z5089358/postgresql-10.4/src/backend/utils/mb/Unicode/convutils.pm:	### Print the struct and array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/mb/conversion_procs/euc_tw_and_big5/big5.c:			(const codes_t *array, int high, unsigned short code)
/srvr/z5089358/postgresql-10.4/src/backend/utils/mb/conversion_procs/euc_tw_and_big5/big5.c:		if ((array[mid].code <= code) && (array[mid + 1].code > code))
/srvr/z5089358/postgresql-10.4/src/backend/utils/mb/conversion_procs/euc_tw_and_big5/big5.c:			if (0 == array[mid].peer)
/srvr/z5089358/postgresql-10.4/src/backend/utils/mb/conversion_procs/euc_tw_and_big5/big5.c:				tmp = ((code & 0xff00) - (array[mid].code & 0xff00)) >> 8;
/srvr/z5089358/postgresql-10.4/src/backend/utils/mb/conversion_procs/euc_tw_and_big5/big5.c:				low = array[mid].code & 0x00ff;
/srvr/z5089358/postgresql-10.4/src/backend/utils/mb/conversion_procs/euc_tw_and_big5/big5.c:				tmp = (array[mid].peer & 0x00ff) + distance - 0x21;
/srvr/z5089358/postgresql-10.4/src/backend/utils/mb/conversion_procs/euc_tw_and_big5/big5.c:				tmp = (array[mid].peer & 0xff00) + ((tmp / 0x5e) << 8)
/srvr/z5089358/postgresql-10.4/src/backend/utils/mb/conversion_procs/euc_tw_and_big5/big5.c:				tmp = ((code & 0xff00) - (array[mid].code & 0xff00)) >> 8;
/srvr/z5089358/postgresql-10.4/src/backend/utils/mb/conversion_procs/euc_tw_and_big5/big5.c:					+ ((int) (code & 0x00ff) - (int) (array[mid].code & 0x00ff));
/srvr/z5089358/postgresql-10.4/src/backend/utils/mb/conversion_procs/euc_tw_and_big5/big5.c:				low = array[mid].peer & 0x00ff;
/srvr/z5089358/postgresql-10.4/src/backend/utils/mb/conversion_procs/euc_tw_and_big5/big5.c:				tmp = (array[mid].peer & 0xff00) + ((tmp / 0x9d) << 8)
/srvr/z5089358/postgresql-10.4/src/backend/utils/mb/conversion_procs/euc_tw_and_big5/big5.c:		else if (array[mid].code > code)
/srvr/z5089358/postgresql-10.4/src/backend/utils/hash/dynahash.c:/* A hash segment is an array of bucket headers */
/srvr/z5089358/postgresql-10.4/src/backend/utils/hash/dynahash.c: * Using an array of FreeListData instead of separate arrays of mutexes,
/srvr/z5089358/postgresql-10.4/src/backend/utils/hash/dynahash.c:	 * tables, so we use an array of freelists, each with its own mutex and
/srvr/z5089358/postgresql-10.4/src/backend/utils/hash/dynahash.c: * arrays
/srvr/z5089358/postgresql-10.4/src/backend/utils/hash/dynahash.c:	 * not only those at the end of the array, because deletion technique
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c: * we absorb tuples and simply store them in an unsorted array as long as
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c: * exceeding workMem, we sort the array using qsort() and subsequently return
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c: * tuples just by scanning the tuple array sequentially.  If we do exceed
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:	 * This array holds the tuples now in sort memory.  If we are in state
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:	 * H.  In state SORTEDONTAPE, the array is not used.
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:	SortTuple  *memtuples;		/* array of SortTuple structs */
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:	int			memtupsize;		/* allocated length of memtuples array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:	 * arrays of length maxTapes, holding per-tape data.
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:	 * number, ie, an index into the tp_xxx[] arrays.  Be careful to keep
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:	int			current;		/* array index (only used if SORTEDINMEM) */
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:	SortSupport sortKeys;		/* array of length nKeys */
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c: * the space used by the variable-size memtuples array.  Fixed-size space
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:	 * fragmentation. Note that the memtuples array of SortTuples is allocated
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:	 * Initial size of array must be more than ALLOCSET_SEPARATE_THRESHOLD;
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:	/* workMem must be large enough for the minimal memtuples array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c: * Grow the memtuples[] array, if possible within our memory constraint.  We
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c: * limit.  Return TRUE if we were able to enlarge the array, FALSE if not.
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c: * Normally, at each increment we double the size of the array.  When doing
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:		 * space for the tuples to which the new array slots will refer.  We
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:		 * memtuples array.  The optimal value might be higher or lower than
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:		 * This calculation is safe against enlarging the array so much that
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:		 * the present array; thus, there would be enough allowedMem for the
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:		 * new array elements even if no other memory were currently used.
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:	/* Must enlarge array by at least one element, else report failure */
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:	 * that the array growth fits within availMem.  (We could still cause
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:	 * array were to increase.  That shouldn't happen because we chose the
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:	 * initial array size large enough to ensure that palloc will be treating
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:	 * both old and new arrays as separate chunks.  But we'll check LACKMEM
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:			 * Save the tuple into the unsorted array.  First, grow the array
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:			 * as needed.  Note that we try to grow the array when there is
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:			 * Done if we still fit in available memory and have array slots.
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:			 * We don't want to grow the array here, so check whether the new
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:			 * have to transform the heap to a properly-sorted array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:	 * array in this calculation, but we effectively treat that as part of the
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:	 * pass-by-value Datums; in all other scenarios the memtuples[] array is
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:	 * Create the tape set and allocate the per-tape data arrays.
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:	 * We no longer need a large memtuples array.  (We will allocate a smaller
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:	 * Allocate a new 'memtuples' array, for the heap.  It will hold one tuple
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c: * slot in the memtuples[] array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c: * Convert the existing unordered array of SortTuples to a bounded heap,
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c: * at the root (array entry zero), instead of the smallest as in the normal
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c: * Convert the bounded heap to a properly-sorted array
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c: * to the end of the heap (ie, in the [memtupcount] array entry) --- if it
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplesort.c:	 * using 1-based array indexes, not 0-based.
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/logtape.c:	long	   *freeBlocks;		/* resizable array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/logtape.c:	/* The array of logical tapes. */
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/logtape.c:	 * freeBlocks[] (after sorting the array if needed).  If there are none,
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/logtape.c:	 * Enlarge freeBlocks array if full.
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/logtape.c:	 * Add blocknum to array, and mark the array unsorted if it's no longer in
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/logtape.c:	lts->blocksSorted = true;	/* a zero-length array is sorted ... */
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c: * in-memory array as long as we haven't exceeded maxKBytes.  If we do exceed
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c:	int			current;		/* next array index to read */
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c:	 * This array holds pointers to tuples in memory if we are in state INMEM.
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c:	void	  **memtuples;		/* array of pointers to palloc'd tuples */
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c:	int			memtupsize;		/* allocated length of memtuples array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c:	TSReadPointer *readptrs;	/* array of read pointers */
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c:	int			readptrsize;	/* allocated length of readptrs array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c: * plus the space used by the variable-size array memtuples.
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c: * We don't worry about the size of the read pointer array, either.
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c:	 * Initial size of array must be more than ALLOCSET_SEPARATE_THRESHOLD;
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c: * Grow the memtuples[] array, if possible within our memory constraint.  We
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c: * limit.  Return TRUE if we were able to enlarge the array, FALSE if not.
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c: * Normally, at each increment we double the size of the array.  When doing
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c:		 * space for the tuples to which the new array slots will refer.  We
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c:		 * memtuples array.  The optimal value might be higher or lower than
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c:		 * This calculation is safe against enlarging the array so much that
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c:		 * the present array; thus, there would be enough allowedMem for the
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c:		 * new array elements even if no other memory were currently used.
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c:	/* Must enlarge array by at least one element, else report failure */
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c:	 * that the array growth fits within availMem.  (We could still cause
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c:	 * array were to increase.  That shouldn't happen because we chose the
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c:	 * initial array size large enough to ensure that palloc will be treating
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c:	 * both old and new arrays as separate chunks.  But we'll check LACKMEM
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c: * Similar to tuplestore_puttuple(), but work from values + nulls arrays.
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c:			 * Grow the array as needed.  Note that we try to grow the array
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c:			/* Stash the tuple in the in-memory array */
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c:			 * Done if we still fit in available memory and have array slots.
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c:	 * repeatedly memmove-ing a large pointer array.  The worst case space
/srvr/z5089358/postgresql-10.4/src/backend/utils/sort/tuplestore.c:	 * Slide the array down and readjust pointers.
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum text_to_array_null(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_append(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_prepend(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum btarraycmp(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_cat(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_to_text_null(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_ne(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_lt(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_gt(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_le(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum text_to_array(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_to_text(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_ge(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_larger(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_smaller(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum hash_array(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_eq(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_dims(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_ndims(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_in(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_out(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_fill(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_fill_with_lower_bounds(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_lower(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_upper(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_length(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum anyarray_in(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum anyarray_out(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_unnest(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_agg_transfn(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_agg_finalfn(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_recv(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_send(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum anyarray_recv(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum anyarray_send(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum ginarrayextract(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum ginarrayconsistent(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum arrayoverlap(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum arraycontains(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum arraycontained(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum regexp_split_to_array_no_flags(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum regexp_split_to_array(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum ginqueryarrayextract(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum anynonarray_in(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum anynonarray_out(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum ginarrayextract_2args(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_to_json(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_to_json_pretty(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_remove(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_replace(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_cardinality(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum json_build_array(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum json_build_array_noargs(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum jsonb_array_length(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum jsonb_array_element(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum jsonb_array_element_text(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum width_bucket_array(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum jsonb_array_elements(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum jsonb_build_array(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum jsonb_build_array_noargs(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_position(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_position_start(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_positions(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum tsvector_to_array(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_to_tsvector(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum jsonb_delete_array(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum jsonb_array_elements_text(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum binary_upgrade_set_next_array_pg_type_oid(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_typanalyze(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum arraycontsel(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum arraycontjoinsel(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum ginarraytriconsistent(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum json_array_element(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum json_array_element_text(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum json_array_elements(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum json_array_length(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum json_array_elements_text(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_agg_array_transfn(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgrprotos.h:extern Datum array_agg_array_finalfn(PG_FUNCTION_ARGS);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/fmgr.c: * the array with the same name, but they should all point to the same
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/fmgr.c:	 * array.
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:	bool		have_anyarray_result = false;
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:	bool		have_anynonarray = false;
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:	Oid			anyarray_type = InvalidOid;
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:				have_anyarray_result = true;
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:				have_anynonarray = true;
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:	if (!have_anyelement_result && !have_anyarray_result &&
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:				if (!OidIsValid(anyarray_type))
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:					anyarray_type = get_call_expr_argtype(call_expr, i);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:	if (!OidIsValid(anyelement_type) && !OidIsValid(anyarray_type) &&
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		if (OidIsValid(anyarray_type))
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:												   anyarray_type,
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:			/* check for inconsistent array and range results */
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:	if (have_anyarray_result && !OidIsValid(anyarray_type))
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		anyarray_type = resolve_generic_type(ANYARRAYOID,
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:	if (have_anynonarray && type_is_array(anyelement_type))
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:	 * necessarily be the same for both anyelement and anyarray.)  Note that
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:	else if (OidIsValid(anyarray_type))
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		anycollation = get_typcollation(anyarray_type);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:								   anyarray_type,
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:	bool		have_anyarray_result = false;
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:	Oid			anyarray_type = InvalidOid;
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:					have_anyarray_result = true;
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:					if (!OidIsValid(anyarray_type))
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:						anyarray_type = get_call_expr_argtype(call_expr,
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:						if (!OidIsValid(anyarray_type))
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:					argtypes[i] = anyarray_type;
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:	if (!have_anyelement_result && !have_anyarray_result &&
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:	if (!OidIsValid(anyelement_type) && !OidIsValid(anyarray_type) &&
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		if (OidIsValid(anyarray_type))
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:												   anyarray_type,
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:			/* check for inconsistent array and range results */
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:	if (have_anyarray_result && !OidIsValid(anyarray_type))
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		anyarray_type = resolve_generic_type(ANYARRAYOID,
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:				argtypes[i] = anyarray_type;
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		 * We expect the arrays to be 1-D arrays of the right types; verify
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		 * that.  For the OID and char arrays, we don't need to use
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		 * deconstruct_array() since the array data is just going to look like
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		 * a C array of values.
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:			elog(ERROR, "proallargtypes is not a 1-D Oid array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		deconstruct_array(DatumGetArrayTypeP(proargnames),
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:			elog(ERROR, "proargmodes is not a 1-D char array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		 * We expect the arrays to be 1-D arrays of the right types; verify
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		 * that.  For the OID and char arrays, we don't need to use
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		 * deconstruct_array() since the array data is just going to look like
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		 * a C array of values.
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:			elog(ERROR, "protrftypes is not a 1-D Oid array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c: * palloc'd array returned to *arg_names.  Entries for unnamed args
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:	 * We expect the arrays to be 1-D arrays of the right types; verify that.
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:	 * For proargmodes, we don't need to use deconstruct_array() since the
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:	 * array data is just going to look like a C array of values.
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		elog(ERROR, "proargnames is not a 1-D text array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:	deconstruct_array(arr, TEXTOID, -1, false, 'i',
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:			elog(ERROR, "proargmodes is not a 1-D char array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		 * We expect the arrays to be 1-D arrays of the right types; verify
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		 * that.  For the char array, we don't need to use deconstruct_array()
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		 * since the array data is just going to look like a C array of
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:			elog(ERROR, "proargmodes is not a 1-D char array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:			elog(ERROR, "proargnames is not a 1-D text array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		deconstruct_array(arr, TEXTOID, -1, false, 'i',
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c: * proargmodes, and proargnames arrays.  This is split out for the
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:	 * We expect the arrays to be 1-D arrays of the right types; verify that.
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:	 * For the OID and char arrays, we don't need to use deconstruct_array()
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:	 * since the array data is just going to look like a C array of values.
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		elog(ERROR, "proallargtypes is not a 1-D Oid array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		elog(ERROR, "proargmodes is not a 1-D char array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:			elog(ERROR, "proargnames is not a 1-D text array");
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		deconstruct_array(arr, TEXTOID, -1, false, 'i',
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c: * has provided one argument made of an array of values, so deconstruct the
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c: * array data before using it for the next processing. If no VARIADIC call
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		ArrayType  *array_in;
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		array_in = PG_GETARG_ARRAYTYPE_P(variadic_start);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		element_type = ARR_ELEMTYPE(array_in);
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		deconstruct_array(array_in, element_type, typlen, typbyval,
/srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.c:		/* All the elements of the array have the same type */
Binary file /srvr/z5089358/postgresql-10.4/src/backend/utils/fmgr/funcapi.o matches
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/ts_typanalyze.c: *	the MCELEM array plus an arbitrary constant, meant to reflect the fact
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/ts_typanalyze.c:	 * We want statistics_target * 10 lexemes in the MCELEM array.  This
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/ts_typanalyze.c:		 * Construct an array of the interesting hashtable items, that is,
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/ts_typanalyze.c:		 * with least frequencies.  The easiest way is to qsort the array into
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/ts_typanalyze.c:		 * descending frequency order and truncate the array.
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/dict_thesaurus.c:	int			ntwrds;			/* allocated array length */
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/ts_selfuncs.c:/* type of keys for bsearch'ing through an array of TextFreqs */
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/ts_selfuncs.c:		/* MCELEM will be an array of TEXT elements for a tsvector column */
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/ts_selfuncs.c: * Extract data from the pg_statistic arrays into useful format.
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/ts_selfuncs.c:	 * Transpose the data into a single array so we can use bsearch().
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/ts_selfuncs.c:		 * The text Datums came from an array, so it cannot be compressed or
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/ts_selfuncs.c:	 * the one before the last cell of the Numbers array. See ts_typanalyze.c
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/ts_selfuncs.c: * The MCELEM array is already sorted (see ts_typanalyze.c), so we can use
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/spell.c: * affix: index of the Conf->AffixData array.
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/spell.c: * Adds the new word into the temporary array Spell.
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/spell.c: * Imports dictionary into the temporary array Spell.
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/spell.c:	/* Resize array or allocate memory for array CompoundAffixFlag */
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/spell.c: * Conf->AffixData array and function returns its entry.
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/spell.c: * low: lower index of the Conf->Spell array.
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/spell.c: * high: upper index of the Conf->Spell array.
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/spell.c:		 * indexes into Conf->AffixData array.
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/spell.c: * low: lower index of the Conf->Affix array.
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/spell.c: * high: upper index of the Conf->Affix array.
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/spell.c: * Returns true if the Conf->AffixData array contains affixflag, otherwise
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/spell.c:	/* Store compound affixes in the Conf->CompoundAffix array */
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/dict.c:	a = construct_array(da,
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/to_tsany.c:			 * before we should check size of position's array, max allowed
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/to_tsany.c:				elog(ERROR, "positions array too long");
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/to_tsany.c:		 * First time through: initialize words array to a reasonable size.
Binary file /srvr/z5089358/postgresql-10.4/src/backend/tsearch/dict.o matches
/srvr/z5089358/postgresql-10.4/src/backend/tsearch/dict_synonym.c:	int			len;			/* length of syn array */
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/bgworker.c:		 * correspondence between the postmaster's private list and the array
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/bgworker.c: * and consult the InternalBGWorkers array.  External functions are
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/bgworker.c:	 * InternalBGWorkers array.
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/pgstat.c:	struct TabStatusArray *tsa_next;	/* link to next array, if any */
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/pgstat.c: *	data.  We can avoid repeated searches of the TabStatus arrays when the
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/pgstat.c: * Functions for management of the shared-memory PgBackendStatus array
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/pgstat.c: * Initialize the shared status array and several string buffers
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/pgstat.c:	/* Create or attach to the shared array */
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/pgstat.c: *	Initialize this backend's entry in the PgBackendStatus array.
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/pgstat.c: * Lastly, clear out our entry in the PgBackendStatus array.
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/pgstat.c: * entry.  Also, zero-initialize st_progress_param array.
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/pgstat.c: *	Copy the current contents of the PgBackendStatus array to local memory,
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/pgstat.c:		/* Only valid entries get included into the local array */
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/pgstat.c: *	transaction's snapshot of the status array.
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/postmaster.c: *	  In particular, it is not a member of the PGPROC array of backends
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/postmaster.c:	 * duplicate array in shared memory.
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/postmaster.c:	 * shared-inval backend array.
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/postmaster.c:	 * The limit here must match the sizes of the per-child-process arrays;
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/postmaster.c: * The caller must have set up the argv array already, except for argv[2]
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/postmaster.c: * This reports the number of entries needed in per-child-process arrays
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/postmaster.c: * (the PMChildFlags array, and if EXEC_BACKEND the ShmemBackendArray).
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/postmaster.c: * These arrays include regular backends, autovac workers, walsenders
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/postmaster.c: * This allows the arrays to have a fixed maximum size, to wit the same
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/postmaster.c:	/* The array slot corresponding to my PMChildSlot should be free */
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/autovacuum.c: * an array of these in shared memory, sized according to
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/autovacuum.c: * Autovacuum workitem array, stored in AutoVacuumShmem->av_workItems.  This
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/autovacuum.c: * struct and the array of WorkerInfo structs.  This struct keeps:
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/autovacuum.c: * av_workItems		work item array
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/autovacuum.c:	 * Then we will put all the hash elements into an array, sort the array by
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/autovacuum.c:	 * score, and finally put the array elements into the new doubly linked
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/autovacuum.c:		/* put all the hash elements into an array */
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/autovacuum.c:		/* sort the array */
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/autovacuum.c:		 * move the elements from the array into the dllist, setting the
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/autovacuum.c:		 * next_worker while walking the array
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/autovacuum.c:		 * also need the AutovacuumLock to walk the worker array, but that one
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/autovacuum.c:	 * Need the fixed struct and the array of WorkerInfoData.
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/checkpointer.c: * The requests array holds fsync requests sent by backends and not yet
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/checkpointer.c:	int			max_requests;	/* allocated array size */
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/checkpointer.c:	 * Currently, the size of the requests[] array is arbitrarily set equal to
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/checkpointer.c:		 * requests array; this is so that CompactCheckpointerRequestQueue can
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/checkpointer.c:	/* Initialize skip_slot array */
/srvr/z5089358/postgresql-10.4/src/backend/postmaster/checkpointer.c:	 * array, and processing the requests after releasing the lock.
/srvr/z5089358/postgresql-10.4/src/backend/foreign/foreign.c: * Convert options array to name/value table.  Useful for information
/srvr/z5089358/postgresql-10.4/src/backend/foreign/foreign.c:	Datum		array = PG_GETARG_DATUM(0);
/srvr/z5089358/postgresql-10.4/src/backend/foreign/foreign.c:						  untransformRelOptions(array));
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_publication.c:#include "utils/array.h"
Binary file /srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.o matches
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_type.c:	 * initialize our *nulls and *values arrays
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_type.c:	values[Anum_pg_type_typarray - 1] = ObjectIdGetDatum(InvalidOid);
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_type.c:		   Oid arrayType,
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_type.c:	 * initialize arrays needed for heap_form_tuple or heap_modify_tuple
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_type.c:	values[Anum_pg_type_typarray - 1] = ObjectIdGetDatum(arrayType);
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_type.c:	 * entry.  Likewise, skip for implicit arrays since we'll depend on them
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_type.c:	 * If the type is an implicitly-created array type, mark it as internally
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_type.c: *		This renames a type, as well as any associated array type.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_type.c:	Oid			arrayOid;
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_type.c:	arrayOid = typ->typarray;
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_type.c:	 * If there is one, see if it's an autogenerated array type, and if so
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_type.c:	 * If the type has an array type, recurse to handle that.  But we don't
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_type.c:	 * need to do anything more if we already renamed that array type above
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_type.c:	if (OidIsValid(arrayOid) && arrayOid != oldTypeOid)
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_type.c:		RenameTypeInternal(arrayOid, arrname, typeNamespace);
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_type.c: *	  - given a base type name, make an array type name for it
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_type.c:				 errmsg("could not form array type name for type \"%s\"",
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_type.c: *	  - try to reassign an array type name that the user wants to use.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_type.c: * OID).  If it is an autogenerated array type, change the array type's name
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_type.c: * determine the new type's own array type name; else the latter will
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_type.c:	/* Can't change it if it's not an autogenerated array type. */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_type.c:		get_array_type(elemOid) != typeOid)
/srvr/z5089358/postgresql-10.4/src/backend/catalog/aclchk.c:	 * it exists.  Must sort both arrays to compare properly.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/aclchk.c: * OR the specified privilege(s) into per-column array entries for each
/srvr/z5089358/postgresql-10.4/src/backend/catalog/aclchk.c: * specified attribute.  The per-column array is indexed starting at
/srvr/z5089358/postgresql-10.4/src/backend/catalog/aclchk.c: * OR the specified privilege(s) into per-column array entries for each valid
/srvr/z5089358/postgresql-10.4/src/backend/catalog/aclchk.c: * attribute of a relation.  The per-column array is indexed starting at
/srvr/z5089358/postgresql-10.4/src/backend/catalog/aclchk.c:		 * Set up array in which we'll accumulate any column privilege bits
/srvr/z5089358/postgresql-10.4/src/backend/catalog/aclchk.c:		 * that need modification.  The array is indexed such that entry [0]
/srvr/z5089358/postgresql-10.4/src/backend/catalog/aclchk.c:		 * array, and then iterate over all nonempty array entries.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/aclchk.c:					 errmsg("cannot set privileges of array types"),
/srvr/z5089358/postgresql-10.4/src/backend/catalog/aclchk.c: * Special common handling for types: use element type instead of array type,
/srvr/z5089358/postgresql-10.4/src/backend/catalog/aclchk.c:	 * "True" array types don't manage permissions of their own; consult the
/srvr/z5089358/postgresql-10.4/src/backend/catalog/aclchk.c:	 * This requires sorting both arrays to get an accurate comparison.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_shdepend.c: * Takes two Oid arrays and removes elements that are common to both arrays,
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_shdepend.c: * We assume both arrays have been sorted and de-duped.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_shdepend.c: * noldmembers, oldmembers: array of roleids appearing in old ACL
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_shdepend.c: * nnewmembers, newmembers: array of roleids appearing in new ACL
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_shdepend.c: * NOTE: Both input arrays must be sorted and de-duped.  (Typically they
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_shdepend.c: * are extracted from an ACL array by aclmembers(), which takes care of
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_shdepend.c: * both requirements.)	The arrays are pfreed before return.
Binary file /srvr/z5089358/postgresql-10.4/src/backend/catalog/namespace.o matches
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_aggregate.c:	 * to protect fixed-size arrays here and possibly in called functions.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_aggregate.c:	 * subsets of arguments into array values.  Since no standard aggregates
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_aggregate.c:	Oid		   *true_oid_array;
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_aggregate.c:							   &true_oid_array, NULL);
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_aggregate.c:												true_oid_array,
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_aggregate.c:		if (!IsBinaryCoercible(input_types[i], true_oid_array[i]))
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_aggregate.c:												  NIL, true_oid_array))));
Binary file /srvr/z5089358/postgresql-10.4/src/backend/catalog/aclchk.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_subscription.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_constraint.o matches
/srvr/z5089358/postgresql-10.4/src/backend/catalog/sql_features.txt:F402	Named column joins for LOBs, arrays, and multisets			YES	
/srvr/z5089358/postgresql-10.4/src/backend/catalog/sql_features.txt:S091	Basic array support			NO	partially supported
/srvr/z5089358/postgresql-10.4/src/backend/catalog/sql_features.txt:S091	Basic array support	01	Arrays of built-in data types	NO	
/srvr/z5089358/postgresql-10.4/src/backend/catalog/sql_features.txt:S091	Basic array support	02	Arrays of distinct types	NO	
/srvr/z5089358/postgresql-10.4/src/backend/catalog/sql_features.txt:S091	Basic array support	03	Array expressions	NO	
/srvr/z5089358/postgresql-10.4/src/backend/catalog/sql_features.txt:S096	Optional array bounds			YES	
/srvr/z5089358/postgresql-10.4/src/backend/catalog/sql_features.txt:S201	SQL-invoked routines on arrays			YES	
/srvr/z5089358/postgresql-10.4/src/backend/catalog/sql_features.txt:S201	SQL-invoked routines on arrays	01	Array parameters	YES	
/srvr/z5089358/postgresql-10.4/src/backend/catalog/sql_features.txt:S201	SQL-invoked routines on arrays	02	Array as result type of functions	YES	
/srvr/z5089358/postgresql-10.4/src/backend/catalog/sql_features.txt:S401	Distinct types based on array types			NO	
Binary file /srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_type.o matches
/srvr/z5089358/postgresql-10.4/src/backend/catalog/Catalog.pm:# Call this function with an array of names of header files to parse.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/Catalog.pm:					if ($attname =~ /(.*)\[.*\]/)    # array attribute
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_proc.c: * are either arrays of the proper types or NULL.  We declare them Datum,
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_proc.c: * not "ArrayType *", to avoid importing array.h into pg_proc_fn.h.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_proc.c:	/* Deconstruct array inputs */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_proc.c:		 * We expect the array to be a 1-D OID array; verify that. We don't
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_proc.c:		 * need to use deconstruct_array() since the array data is just going
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_proc.c:		 * to look like a C array of OID values.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_proc.c:			elog(ERROR, "allParameterTypes is not a 1-D Oid array");
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_proc.c:		 * We expect the array to be a 1-D CHAR array; verify that. We don't
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_proc.c:		 * need to use deconstruct_array() since the array data is just going
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_proc.c:		 * to look like a C array of char values.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_proc.c:			elog(ERROR, "parameterModes is not a 1-D char array");
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_proc.c:								elog(ERROR, "variadic parameter is not an array");
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_proc.c:oid_array_to_list(Datum datum)
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_proc.c:	ArrayType  *array = DatumGetArrayTypeP(datum);
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_proc.c:	deconstruct_array(array,
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_constraint.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_constraint.c:	 * Convert C arrays into Postgres arrays.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_constraint.c:		conkeyArray = construct_array(conkey, constraintNKeys,
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_constraint.c:		confkeyArray = construct_array(fkdatums, foreignNKeys,
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_constraint.c:		conpfeqopArray = construct_array(fkdatums, foreignNKeys,
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_constraint.c:		conppeqopArray = construct_array(fkdatums, foreignNKeys,
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_constraint.c:		conffeqopArray = construct_array(fkdatums, foreignNKeys,
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_constraint.c:		conexclopArray = construct_array(opdatums, constraintNKeys,
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_constraint.c:		/* Extract the conkey array, ie, attnums of constrained columns */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_constraint.c:			elog(ERROR, "conkey is not a 1-D smallint array");
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_constraint.c:		/* Extract the conkey array, ie, attnums of PK's columns */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_constraint.c:			elog(ERROR, "conkey is not a 1-D smallint array");
/srvr/z5089358/postgresql-10.4/src/backend/catalog/schemapg.h:{ 1247, {"typarray"}, 26, -1, 4, 13, 0, -1, -1, true, 'p', 'i', true, false, '\0', false, true, 0, 0 }, \
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_operator.c:	 * initialize our *nulls and *values arrays
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 382 ( btarraycmp 11 10 12 1 0 0 0 f f f f t f i s 2 0 23 "2277 2277" _null_ _null_ _null_ _null_ _null_ btarraycmp _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 626 ( hash_array 11 10 12 1 0 0 0 f f f f t f i s 1 0 23 "2277" _null_ _null_ _null_ _null_ _null_ hash_array _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 744 ( array_eq 11 10 12 1 0 0 0 f f f f t f i s 2 0 16 "2277 2277" _null_ _null_ _null_ _null_ _null_ array_eq _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 390 ( array_ne 11 10 12 1 0 0 0 f f f f t f i s 2 0 16 "2277 2277" _null_ _null_ _null_ _null_ _null_ array_ne _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 391 ( array_lt 11 10 12 1 0 0 0 f f f f t f i s 2 0 16 "2277 2277" _null_ _null_ _null_ _null_ _null_ array_lt _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 392 ( array_gt 11 10 12 1 0 0 0 f f f f t f i s 2 0 16 "2277 2277" _null_ _null_ _null_ _null_ _null_ array_gt _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 393 ( array_le 11 10 12 1 0 0 0 f f f f t f i s 2 0 16 "2277 2277" _null_ _null_ _null_ _null_ _null_ array_le _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 396 ( array_ge 11 10 12 1 0 0 0 f f f f t f i s 2 0 16 "2277 2277" _null_ _null_ _null_ _null_ _null_ array_ge _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 747 ( array_dims 11 10 12 1 0 0 0 f f f f t f i s 1 0 25 "2277" _null_ _null_ _null_ _null_ _null_ array_dims _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 748 ( array_ndims 11 10 12 1 0 0 0 f f f f t f i s 1 0 23 "2277" _null_ _null_ _null_ _null_ _null_ array_ndims _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 750 ( array_in 11 10 12 1 0 0 0 f f f f t f s s 3 0 2277 "2275 26 23" _null_ _null_ _null_ _null_ _null_ array_in _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 751 ( array_out 11 10 12 1 0 0 0 f f f f t f s s 1 0 2275 "2277" _null_ _null_ _null_ _null_ _null_ array_out _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2091 ( array_lower 11 10 12 1 0 0 0 f f f f t f i s 2 0 23 "2277 23" _null_ _null_ _null_ _null_ _null_ array_lower _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2092 ( array_upper 11 10 12 1 0 0 0 f f f f t f i s 2 0 23 "2277 23" _null_ _null_ _null_ _null_ _null_ array_upper _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2176 ( array_length 11 10 12 1 0 0 0 f f f f t f i s 2 0 23 "2277 23" _null_ _null_ _null_ _null_ _null_ array_length _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3179 ( cardinality 11 10 12 1 0 0 0 f f f f t f i s 1 0 23 "2277" _null_ _null_ _null_ _null_ _null_ array_cardinality _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 378 ( array_append 11 10 12 1 0 0 0 f f f f f f i s 2 0 2277 "2277 2283" _null_ _null_ _null_ _null_ _null_ array_append _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 379 ( array_prepend 11 10 12 1 0 0 0 f f f f f f i s 2 0 2277 "2283 2277" _null_ _null_ _null_ _null_ _null_ array_prepend _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 383 ( array_cat 11 10 12 1 0 0 0 f f f f f f i s 2 0 2277 "2277 2277" _null_ _null_ _null_ _null_ _null_ array_cat _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 394 ( string_to_array 11 10 12 1 0 0 0 f f f f f f i s 2 0 1009 "25 25" _null_ _null_ _null_ _null_ _null_ text_to_array _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 395 ( array_to_string 11 10 12 1 0 0 0 f f f f t f s s 2 0 25 "2277 25" _null_ _null_ _null_ _null_ _null_ array_to_text _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 376 ( string_to_array 11 10 12 1 0 0 0 f f f f f f i s 3 0 1009 "25 25 25" _null_ _null_ _null_ _null_ _null_ text_to_array_null _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 384 ( array_to_string 11 10 12 1 0 0 0 f f f f f f s s 3 0 25 "2277 25 25" _null_ _null_ _null_ _null_ _null_ array_to_text_null _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 515 ( array_larger 11 10 12 1 0 0 0 f f f f t f i s 2 0 2277 "2277 2277" _null_ _null_ _null_ _null_ _null_ array_larger _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 516 ( array_smaller 11 10 12 1 0 0 0 f f f f t f i s 2 0 2277 "2277 2277" _null_ _null_ _null_ _null_ _null_ array_smaller _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3277 ( array_position 11 10 12 1 0 0 0 f f f f f f i s 2 0 23 "2277 2283" _null_ _null_ _null_ _null_ _null_ array_position _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3278 ( array_position 11 10 12 1 0 0 0 f f f f f f i s 3 0 23 "2277 2283 23" _null_ _null_ _null_ _null_ _null_ array_position_start _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3279 ( array_positions 11 10 12 1 0 0 0 f f f f f f i s 2 0 1007 "2277 2283" _null_ _null_ _null_ _null_ _null_ array_positions _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 1193 ( array_fill 11 10 12 1 0 0 0 f f f f f f i s 2 0 2277 "2283 1007" _null_ _null_ _null_ _null_ _null_ array_fill _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 1286 ( array_fill 11 10 12 1 0 0 0 f f f f f f i s 3 0 2277 "2283 1007 1007" _null_ _null_ _null_ _null_ _null_ array_fill_with_lower_bounds _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2331 ( unnest 11 10 12 1 100 0 0 f f f f t t i s 1 0 2283 "2277" _null_ _null_ _null_ _null_ _null_ array_unnest _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3167 ( array_remove 11 10 12 1 0 0 0 f f f f f f i s 2 0 2277 "2277 2283" _null_ _null_ _null_ _null_ _null_ array_remove _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3168 ( array_replace 11 10 12 1 0 0 0 f f f f f f i s 3 0 2277 "2277 2283 2283" _null_ _null_ _null_ _null_ _null_ array_replace _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2333 ( array_agg_transfn 11 10 12 1 0 0 0 f f f f f f i s 2 0 2281 "2281 2776" _null_ _null_ _null_ _null_ _null_ array_agg_transfn _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2334 ( array_agg_finalfn 11 10 12 1 0 0 0 f f f f f f i s 2 0 2277 "2281 2776" _null_ _null_ _null_ _null_ _null_ array_agg_finalfn _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2335 ( array_agg 11 10 12 1 0 0 0 t f f f f f i s 1 0 2277 "2776" _null_ _null_ _null_ _null_ _null_ aggregate_dummy _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 4051 ( array_agg_array_transfn 11 10 12 1 0 0 0 f f f f f f i s 2 0 2281 "2281 2277" _null_ _null_ _null_ _null_ _null_ array_agg_array_transfn _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 4052 ( array_agg_array_finalfn 11 10 12 1 0 0 0 f f f f f f i s 2 0 2277 "2281 2277" _null_ _null_ _null_ _null_ _null_ array_agg_array_finalfn _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 4053 ( array_agg 11 10 12 1 0 0 0 t f f f f f i s 1 0 2277 "2277" _null_ _null_ _null_ _null_ _null_ aggregate_dummy _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3218 ( width_bucket 11 10 12 1 0 0 0 f f f f t f i s 2 0 23 "2283 2277" _null_ _null_ _null_ _null_ _null_ width_bucket_array _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3816 ( array_typanalyze 11 10 12 1 0 0 0 f f f f t f s s 1 0 16 "2281" _null_ _null_ _null_ _null_ _null_ array_typanalyze _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3817 ( arraycontsel 11 10 12 1 0 0 0 f f f f t f s s 4 0 701 "2281 26 2281 23" _null_ _null_ _null_ _null_ _null_ arraycontsel _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3818 ( arraycontjoinsel 11 10 12 1 0 0 0 f f f f t f s s 5 0 701 "2281 26 2281 21 2281" _null_ _null_ _null_ _null_ _null_ arraycontjoinsel _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2767 ( regexp_split_to_array 11 10 12 1 0 0 0 f f f f t f i s 2 0 1009 "25 25" _null_ _null_ _null_ _null_ _null_ regexp_split_to_array_no_flags _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2768 ( regexp_split_to_array 11 10 12 1 0 0 0 f f f f t f i s 3 0 1009 "25 25 25" _null_ _null_ _null_ _null_ _null_ regexp_split_to_array _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2289 ( pg_options_to_table 11 10 12 1 3 0 0 f f f f t t s s 1 0 2249 "1009" "{1009,25,25}" "{i,o,o}" "{options_array,option_name,option_value}" _null_ _null_ pg_options_to_table _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2296 ( anyarray_in 11 10 12 1 0 0 0 f f f f t f i s 1 0 2277 "2275" _null_ _null_ _null_ _null_ _null_ anyarray_in _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2297 ( anyarray_out 11 10 12 1 0 0 0 f f f f t f s s 1 0 2275 "2277" _null_ _null_ _null_ _null_ _null_ anyarray_out _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2777 ( anynonarray_in 11 10 12 1 0 0 0 f f f f t f i s 1 0 2776 "2275" _null_ _null_ _null_ _null_ _null_ anynonarray_in _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2778 ( anynonarray_out 11 10 12 1 0 0 0 f f f f t f i s 1 0 2275 "2776" _null_ _null_ _null_ _null_ _null_ anynonarray_out _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2400 ( array_recv 11 10 12 1 0 0 0 f f f f t f s s 3 0 2277 "2281 26 23" _null_ _null_ _null_ _null_ _null_ array_recv _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2401 ( array_send 11 10 12 1 0 0 0 f f f f t f s s 1 0 17 "2277" _null_ _null_ _null_ _null_ _null_ array_send _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2502 ( anyarray_recv 11 10 12 1 0 0 0 f f f f t f s s 1 0 2277 "2281" _null_ _null_ _null_ _null_ _null_ anyarray_recv _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2503 ( anyarray_send 11 10 12 1 0 0 0 f f f f t f s s 1 0 17 "2277" _null_ _null_ _null_ _null_ _null_ anyarray_send _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2743 ( ginarrayextract 11 10 12 1 0 0 0 f f f f t f i s 3 0 2281 "2277 2281 2281" _null_ _null_ _null_ _null_ _null_ ginarrayextract _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2774 ( ginqueryarrayextract 11 10 12 1 0 0 0 f f f f t f i s 7 0 2281 "2277 2281 21 2281 2281 2281 2281" _null_ _null_ _null_ _null_ _null_ ginqueryarrayextract _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2744 ( ginarrayconsistent 11 10 12 1 0 0 0 f f f f t f i s 8 0 16 "2281 21 2277 23 2281 2281 2281 2281" _null_ _null_ _null_ _null_ _null_ ginarrayconsistent _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3920 ( ginarraytriconsistent 11 10 12 1 0 0 0 f f f f t f i s 7 0 18 "2281 21 2277 23 2281 2281 2281" _null_ _null_ _null_ _null_ _null_ ginarraytriconsistent _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3076 ( ginarrayextract 11 10 12 1 0 0 0 f f f f t f i s 2 0 2281 "2277 2281" _null_ _null_ _null_ _null_ _null_ ginarrayextract_2args _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2747 ( arrayoverlap 11 10 12 1 0 0 0 f f f f t f i s 2 0 16 "2277 2277" _null_ _null_ _null_ _null_ _null_ arrayoverlap _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2748 ( arraycontains 11 10 12 1 0 0 0 f f f f t f i s 2 0 16 "2277 2277" _null_ _null_ _null_ _null_ _null_ arraycontains _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2749 ( arraycontained 11 10 12 1 0 0 0 f f f f t f i s 2 0 16 "2277 2277" _null_ _null_ _null_ _null_ _null_ arraycontained _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3153 ( array_to_json 11 10 12 1 0 0 0 f f f f t f s s 1 0 114 "2277" _null_ _null_ _null_ _null_ _null_ array_to_json _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3154 ( array_to_json 11 10 12 1 0 0 0 f f f f t f s s 2 0 114 "2277 16" _null_ _null_ _null_ _null_ _null_ array_to_json_pretty _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3198 ( json_build_array 11 10 12 1 0 2276 0 f f f f f f s s 1 0 114 "2276" "{2276}" "{v}" _null_ _null_ _null_ json_build_array _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3199 ( json_build_array 11 10 12 1 0 0 0 f f f f f f s s 0 0 114 "" _null_ _null_ _null_ _null_ _null_ json_build_array_noargs _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3949 ( json_array_element 11 10 12 1 0 0 0 f f f f t f i s 2 0 114 "114 23" _null_ _null_ "{from_json, element_index}" _null_ _null_ json_array_element _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3950 ( json_array_element_text 11 10 12 1 0 0 0 f f f f t f i s 2 0 25 "114 23" _null_ _null_ "{from_json, element_index}" _null_ _null_ json_array_element_text _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3955 ( json_array_elements 11 10 12 1 100 0 0 f f f f t t i s 1 0 114 "114" "{114,114}" "{i,o}" "{from_json,value}" _null_ _null_ json_array_elements _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3969 ( json_array_elements_text 11 10 12 1 100 0 0 f f f f t t i s 1 0 25 "114" "{114,25}" "{i,o}" "{from_json,value}" _null_ _null_ json_array_elements_text _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3956 ( json_array_length 11 10 12 1 0 0 0 f f f f t f i s 1 0 23 "114" _null_ _null_ _null_ _null_ _null_ json_array_length _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3326 ( tsvector_to_array 11 10 12 1 0 0 0 f f f f t f i s 1 0 1009 "3614" _null_ _null_ _null_ _null_ _null_ tsvector_to_array _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3327 ( array_to_tsvector 11 10 12 1 0 0 0 f f f f t f i s 1 0 3614 "1009" _null_ _null_ _null_ _null_ _null_ array_to_tsvector _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3271 ( jsonb_build_array 11 10 12 1 0 2276 0 f f f f f f s s 1 0 3802 "2276" "{2276}" "{v}" _null_ _null_ _null_ jsonb_build_array _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3272 ( jsonb_build_array 11 10 12 1 0 0 0 f f f f f f s s 0 0 3802 "" _null_ _null_ _null_ _null_ _null_ jsonb_build_array_noargs _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3215 ( jsonb_array_element 11 10 12 1 0 0 0 f f f f t f i s 2 0 3802 "3802 23" _null_ _null_ "{from_json, element_index}" _null_ _null_ jsonb_array_element _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3216 ( jsonb_array_element_text 11 10 12 1 0 0 0 f f f f t f i s 2 0 25 "3802 23" _null_ _null_ "{from_json, element_index}" _null_ _null_ jsonb_array_element_text _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3219 ( jsonb_array_elements 11 10 12 1 100 0 0 f f f f t t i s 1 0 3802 "3802" "{3802,3802}" "{i,o}" "{from_json,value}" _null_ _null_ jsonb_array_elements _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3465 ( jsonb_array_elements_text 11 10 12 1 100 0 0 f f f f t t i s 1 0 25 "3802" "{3802,25}" "{i,o}" "{from_json,value}" _null_ _null_ jsonb_array_elements_text _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3207 ( jsonb_array_length 11 10 12 1 0 0 0 f f f f t f i s 1 0 23 "3802" _null_ _null_ _null_ _null_ _null_ jsonb_array_length _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3343 ( jsonb_delete 11 10 12 1 0 25 0 f f f f t f i s 2 0 3802 "3802 1009" "{3802,1009}" "{i,v}" "{from_json,path_elems}" _null_ _null_ jsonb_delete_array _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 3584 ( binary_upgrade_set_next_array_pg_type_oid 11 10 12 1 0 0 0 f f f f t f v r 1 0 2278 "26" _null_ _null_ _null_ _null_ _null_ binary_upgrade_set_next_array_pg_type_oid _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki: typarray = oid ,
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2277 ( anyarray 11 10 -1 f p P f t \054 0 0 0 2296 2297 2502 2503 - - - d x f 0 -1 0 0 _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2776 ( anynonarray 11 10 4 t p P f t \054 0 0 0 2777 2778 - - - - - i p f 0 -1 0 0 _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert ( 1247 typarray 26 -1 4 13 0 -1 -1 t p i t f "" f t 0 0 _null_ _null_ _null_ )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 397 ( 403 array_ops 11 10 )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 627 ( 405 array_ops 11 10 )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert OID = 2745 ( 2742 array_ops 11 10 )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert ( 403 array_ops 11 10 397 2277 t 0 )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert ( 405 array_ops 11 10 627 2277 t 0 )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki:insert ( 2742 array_ops 11 10 2745 2277 t 2283 )
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki: stavalues1 = anyarray ,
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki: stavalues2 = anyarray ,
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki: stavalues3 = anyarray ,
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki: stavalues4 = anyarray ,
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.bki: stavalues5 = anyarray
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_db_role_setting.c:	 * - in RESET ALL, request GUC to reset the settings array and update the
Binary file /srvr/z5089358/postgresql-10.4/src/backend/catalog/objectaddress.o matches
/srvr/z5089358/postgresql-10.4/src/backend/catalog/objectaddress.c: * This array provides a common part of system object structure; to help
/srvr/z5089358/postgresql-10.4/src/backend/catalog/objectaddress.c: * Convert an array of TEXT into a List of string Values, as emitted by the
/srvr/z5089358/postgresql-10.4/src/backend/catalog/objectaddress.c:textarray_to_strvaluelist(ArrayType *arr)
/srvr/z5089358/postgresql-10.4/src/backend/catalog/objectaddress.c:	deconstruct_array(arr, TEXTOID, -1, false, 'i',
/srvr/z5089358/postgresql-10.4/src/backend/catalog/objectaddress.c:	 * Convert the text array to the representation appropriate for the given
/srvr/z5089358/postgresql-10.4/src/backend/catalog/objectaddress.c:		deconstruct_array(namearr, TEXTOID, -1, false, 'i',
/srvr/z5089358/postgresql-10.4/src/backend/catalog/objectaddress.c:		deconstruct_array(namearr, TEXTOID, -1, false, 'i',
/srvr/z5089358/postgresql-10.4/src/backend/catalog/objectaddress.c:		name = textarray_to_strvaluelist(namearr);
/srvr/z5089358/postgresql-10.4/src/backend/catalog/objectaddress.c:		deconstruct_array(argsarr, TEXTOID, -1, false, 'i',
/srvr/z5089358/postgresql-10.4/src/backend/catalog/objectaddress.c:		args = textarray_to_strvaluelist(argsarr);
/srvr/z5089358/postgresql-10.4/src/backend/catalog/objectaddress.c:	values[1] = PointerGetDatum(strlist_to_textarray(names));
/srvr/z5089358/postgresql-10.4/src/backend/catalog/objectaddress.c:		values[2] = PointerGetDatum(strlist_to_textarray(args));
/srvr/z5089358/postgresql-10.4/src/backend/catalog/objectaddress.c:		values[2] = PointerGetDatum(construct_empty_array(TEXTOID));
/srvr/z5089358/postgresql-10.4/src/backend/catalog/objectaddress.c: * Auxiliary function to return a TEXT array out of a list of C-strings.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/objectaddress.c:strlist_to_textarray(List *list)
/srvr/z5089358/postgresql-10.4/src/backend/catalog/objectaddress.c:								   "strlist to array",
/srvr/z5089358/postgresql-10.4/src/backend/catalog/objectaddress.c:	arr = construct_array(datums, list_length(list),
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:747	pg_proc	0	array dimensions
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:748	pg_proc	0	number of array dimensions
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:2091	pg_proc	0	array lower dimension
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:2092	pg_proc	0	array upper dimension
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:2176	pg_proc	0	array length
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3179	pg_proc	0	array cardinality
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:378	pg_proc	0	append element onto end of array
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:379	pg_proc	0	prepend element onto front of array
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:395	pg_proc	0	concatenate array elements, using delimiter, into text
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:384	pg_proc	0	concatenate array elements, using delimiter and null string, into text
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3277	pg_proc	0	returns an offset of value in array
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3278	pg_proc	0	returns an offset of value in array with start index
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3279	pg_proc	0	returns an array of offsets of some value in array
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:1191	pg_proc	0	array subscripts generator
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:1192	pg_proc	0	array subscripts generator
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:1193	pg_proc	0	array constructor with value
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:1286	pg_proc	0	array constructor with value
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:2331	pg_proc	0	expand array to set of rows
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3167	pg_proc	0	remove any occurrences of an element from an array
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3168	pg_proc	0	replace any occurrences of an element in an array
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:2335	pg_proc	0	concatenate aggregate input into an array
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:4053	pg_proc	0	concatenate aggregate input into an array
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3218	pg_proc	0	bucket number of operand given a sorted array of bucket lower bounds
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3816	pg_proc	0	array typanalyze
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3817	pg_proc	0	restriction selectivity for array-containment operators
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3818	pg_proc	0	join selectivity for array-containment operators
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:1689	pg_proc	0	convert ACL item array to table, for use by information schema
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:2289	pg_proc	0	convert generic options array to name/value table
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:2561	pg_proc	0	get array of PIDs of sessions blocking specified backend PID from acquiring a heavyweight lock
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3376	pg_proc	0	get array of PIDs of sessions blocking specified backend PID from acquiring a safe snapshot
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3954	pg_proc	0	get OID-based object address from name/args arrays
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:2050	pg_proc	0	maximum value of all anyarray input values
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:2051	pg_proc	0	minimum value of all anyarray input values
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:1268	pg_proc	0	parse qualified identifier to array of identifiers
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:2743	pg_proc	0	GIN array support
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:2774	pg_proc	0	GIN array support
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:2744	pg_proc	0	GIN array support
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3920	pg_proc	0	GIN array support
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3076	pg_proc	0	GIN array support (obsolete)
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3153	pg_proc	0	map array to json
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3154	pg_proc	0	map array to json with optional pretty printing
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3198	pg_proc	0	build a json array from any inputs
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3199	pg_proc	0	build an empty json array
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3202	pg_proc	0	map text array of key value pairs to json object
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3203	pg_proc	0	map text arrays of keys and values to json object
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3969	pg_proc	0	elements of json array
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3956	pg_proc	0	length of json array
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3961	pg_proc	0	get set of records with fields from a json array of objects
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3205	pg_proc	0	get set of records with fields from a json array of objects
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3530	pg_proc	0	range between the two given enum values, as an ordered array
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3531	pg_proc	0	range of the given enum type, as an ordered array
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3326	pg_proc	0	convert tsvector to array of lexemes
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3327	pg_proc	0	build tsvector from array of lexemes
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3263	pg_proc	0	map text array of key value pairs to jsonb object
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3264	pg_proc	0	map text array of key value pairs to jsonb object
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3271	pg_proc	0	build a jsonb array from any inputs
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3272	pg_proc	0	build an empty jsonb array
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3219	pg_proc	0	elements of a jsonb array
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3465	pg_proc	0	elements of jsonb array
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3207	pg_proc	0	length of jsonb array
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3475	pg_proc	0	get set of records with fields from a jsonb array of objects
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3491	pg_proc	0	get set of records with fields from a jsonb array of objects
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:22	pg_type	0	array of int2, used in system tables
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:30	pg_type	0	array of oids, used in system tables
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:349	pg_operator	0	append element onto end of array
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:374	pg_operator	0	prepend element onto front of array
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3964	pg_operator	0	get json array element
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3965	pg_operator	0	get json array element as text
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3212	pg_operator	0	get jsonb array element
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3481	pg_operator	0	get jsonb array element as text
/srvr/z5089358/postgresql-10.4/src/backend/catalog/postgres.description:3286	pg_operator	0	delete array element
/srvr/z5089358/postgresql-10.4/src/backend/catalog/indexing.c:					 values,	/* array of index Datums */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/storage.c:				/* allocate the initial array, or extend it, if needed */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/storage.c: * *ptr is set to point to a freshly-palloc'd array of RelFileNodes.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/namespace.c: * distinct.)  The returned structs will include an argnumbers array showing
/srvr/z5089358/postgresql-10.4/src/backend/catalog/namespace.c: * When argnames isn't NIL, the returned args[] type arrays are not ordered
/srvr/z5089358/postgresql-10.4/src/backend/catalog/namespace.c: * array can be used to map this back to the catalog information.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/namespace.c:			 * presumed-nameless parameters expanded from the variadic array.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/namespace.c: * On match, return true and fill *argnumbers with a palloc'd array showing
/srvr/z5089358/postgresql-10.4/src/backend/catalog/namespace.c:	 * spent in palloc, we allocate the result space as an array large enough
/srvr/z5089358/postgresql-10.4/src/backend/catalog/namespace.c: * Fetch the active search path into a caller-allocated array of OIDs.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/namespace.c: * Returns the number of path entries.  (If this is more than sarray_len,
/srvr/z5089358/postgresql-10.4/src/backend/catalog/namespace.c:fetch_search_path_array(Oid *sarray, int sarray_len)
/srvr/z5089358/postgresql-10.4/src/backend/catalog/namespace.c:		if (count < sarray_len)
/srvr/z5089358/postgresql-10.4/src/backend/catalog/namespace.c:			sarray[count] = namespaceId;
/srvr/z5089358/postgresql-10.4/src/backend/catalog/dependency.c: * ObjectAddresses code support arrays with or without this extra state.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/dependency.c:	ObjectAddress *refs;		/* => palloc'd array */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/dependency.c:	ObjectAddressExtra *extras; /* => palloc'd array, or NULL if not used */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/dependency.c:	int			maxrefs;		/* current size of palloc'd array(s) */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/dependency.c: * Given an array of dependency references, eliminate any duplicates.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/dependency.c:	 * We can't sort if the array has "extra" data, because there's no way to
/srvr/z5089358/postgresql-10.4/src/backend/catalog/dependency.c: * Routines for handling an expansible array of ObjectAddress items.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/dependency.c: * new_object_addresses: create a new ObjectAddresses array.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/dependency.c: * Add an entry to an ObjectAddresses array.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/dependency.c:	/* enlarge array if needed */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/dependency.c: * Add an entry to an ObjectAddresses array.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/dependency.c:	/* enlarge array if needed */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/dependency.c: * Add an entry to an ObjectAddresses array.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/dependency.c:	/* enlarge array if needed */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/dependency.c: * Test whether an object is present in an ObjectAddresses array.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/dependency.c: * We return "true" if object is a subobject of something in the array, too.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/dependency.c:				 * found the subobject in the array.  But don't plaster its
/srvr/z5089358/postgresql-10.4/src/backend/catalog/dependency.c:				 * can't report that the whole object is in the array, but we
/srvr/z5089358/postgresql-10.4/src/backend/catalog/dependency.c:				 * array entry, or at least mark it as no longer needing
/srvr/z5089358/postgresql-10.4/src/backend/catalog/dependency.c:				 * the array, this case means we always have to loop through
/srvr/z5089358/postgresql-10.4/src/backend/catalog/dependency.c:				 * the whole array; we cannot exit early on a match.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/dependency.c: * Record multiple dependencies from an ObjectAddresses array, after first
/srvr/z5089358/postgresql-10.4/src/backend/catalog/dependency.c: * Clean up when done with an ObjectAddresses array.
Binary file /srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_proc.o matches
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c: * datums array. Instead, it is tracked using the null_index field.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c: * In the case of list partitioning, the indexes array stores one entry for
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c:	int			ndatums;		/* Length of the datums following array */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c:								 * the datums array (plus one if range
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c:						 * Never put a null into the values array, flag
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c:			 * Collect all list values in one array. Alongside the value, we
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c:			 * Count the number of distinct bounds to allocate an array of
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c:				 * that we'd like put in the relcache array.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c:			 * Finally save them in an array from where they will be copied
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c:		/* Initialize mapping array with invalid values */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c:						 * Any lower bounds in the rbounds array have invalid
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c:		 * Now assign OIDs from the original array into mapped indexes of the
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c:		 * result array.  Order of OIDs in the former is defined by the
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c:					 * since the index array is initialised with an extra -1
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c: * The number of elements in the returned array (that is, the number of
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c:	 * the leaf partition OIDs list and the array of PartitionDispatch objects
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c:	 * We want to create two arrays - one for leaf partitions and another for
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c:	 * While we only create the latter here, leaf partition array of suitable
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c:	 * list of OIDs we return.  Indexes into these arrays get assigned in a
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c:	 * consecutively in the respective arrays.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c:					!type_is_array(key->parttypid[keynum]))
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c:					arrexpr->array_typeid =
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c:									get_array_type(key->parttypid[keynum]);
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c:					arrexpr->array_collid = key->parttypcoll[keynum];
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c: *			Construct values[] and isnull[] arrays for the partition key
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c: * bound in array boundinfo->datums which is less than or equal to *probe.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c: * If all bounds in the array are greater than *probe, -1 is returned.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/partition.c: * *probe could either be a partition bound or a Datum array representing
Binary file /srvr/z5089358/postgresql-10.4/src/backend/catalog/index.o matches
/srvr/z5089358/postgresql-10.4/src/backend/catalog/information_schema.sql:/* Expand any 1-D array into a set with integers 1..N */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/information_schema.sql:CREATE FUNCTION _pg_expandarray(IN anyarray, OUT x anyelement, OUT n int)
/srvr/z5089358/postgresql-10.4/src/backend/catalog/information_schema.sql:    AS 'select $1[s], s - pg_catalog.array_lower($1,1) + 1
/srvr/z5089358/postgresql-10.4/src/backend/catalog/information_schema.sql:        from pg_catalog.generate_series(pg_catalog.array_lower($1,1),
/srvr/z5089358/postgresql-10.4/src/backend/catalog/information_schema.sql:                                        pg_catalog.array_upper($1,1),
/srvr/z5089358/postgresql-10.4/src/backend/catalog/information_schema.sql:  (SELECT information_schema._pg_expandarray(indkey) AS a
/srvr/z5089358/postgresql-10.4/src/backend/catalog/information_schema.sql:                 _pg_expandarray(c.conkey) AS x
/srvr/z5089358/postgresql-10.4/src/backend/catalog/information_schema.sql:                 _pg_expandarray(coalesce(p.proallargtypes, p.proargtypes::oid[])) AS x
/srvr/z5089358/postgresql-10.4/src/backend/catalog/information_schema.sql:          FROM (SELECT oid AS tgoid, information_schema._pg_expandarray(tgattr) AS tgat FROM pg_trigger) AS ta0) AS ta,
/srvr/z5089358/postgresql-10.4/src/backend/catalog/information_schema.sql:                        _pg_expandarray(coalesce(p.proallargtypes, p.proargtypes::oid[])) AS x
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:				   Oid new_array_type);
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:		 * Must recurse into array types, too, in case they are composite.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:				   Oid new_array_type)
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:				   DEFAULT_TYPDELIM,	/* default array delimiter */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:				   InvalidOid,	/* array element type - irrelevant */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:				   false,		/* this is not an array type */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:				   new_array_type,	/* array type if any */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:				   0,			/* array dimensions for typBaseType */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:	Oid			new_array_oid = InvalidOid;
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:	 * autogenerated array, we can rename it out of the way; otherwise we can
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:	 * Decide whether to create an array type over the relation's rowtype. We
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:	 * do not create any array types for system catalogs (ie, those made
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:		new_array_oid = AssignTypeArrayOid();
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:									   new_array_oid);
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:	 * Now make the array type if wanted.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:	if (OidIsValid(new_array_oid))
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:		char	   *relarrayname;
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:		relarrayname = makeArrayTypeName(relname, relnamespace);
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:		TypeCreate(new_array_oid,	/* force the type's OID to this */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:				   relarrayname,	/* Array type name */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:				   TYPCATEGORY_ARRAY,	/* type-category (array) */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:				   false,		/* array types are never preferred */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:				   DEFAULT_TYPDELIM,	/* default array delimiter */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:				   F_ARRAY_IN,	/* array input proc */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:				   F_ARRAY_OUT, /* array output proc */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:				   F_ARRAY_RECV,	/* array recv (bin) proc */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:				   F_ARRAY_SEND,	/* array send (bin) proc */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:				   F_ARRAY_TYPANALYZE,	/* array analyze procedure */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:				   new_type_oid,	/* array element type - the rowtype */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:				   true,		/* yes, this is an array type */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:				   InvalidOid,	/* this has no array type */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:				   0,			/* array dimensions for typBaseType */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:		pfree(relarrayname);
/srvr/z5089358/postgresql-10.4/src/backend/catalog/heap.c:	/* Copy the partition attribute numbers, opclass OIDs into arrays */
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_inherits.c:	 * Scan pg_inherits and build a working array of subclass OIDs.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_subscription.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_subscription.c:static List *textarray_to_stringlist(ArrayType *textarray);
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_subscription.c:	sub->publications = textarray_to_stringlist(DatumGetArrayTypeP(datum));
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_subscription.c: * Convert text array to list of strings.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_subscription.c:textarray_to_stringlist(ArrayType *textarray)
/srvr/z5089358/postgresql-10.4/src/backend/catalog/pg_subscription.c:	deconstruct_array(textarray,
/srvr/z5089358/postgresql-10.4/src/backend/catalog/genbki.pl:	# Adjust type name for arrays: foo[] becomes _foo
/srvr/z5089358/postgresql-10.4/src/backend/catalog/genbki.pl:			# set attndims if it's an array type
/srvr/z5089358/postgresql-10.4/src/backend/catalog/system_views.sql:                string_to_array('public', '')
/srvr/z5089358/postgresql-10.4/src/backend/catalog/index.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/catalog/index.c:		 * then the attribute type must be an array (else it'd not have
/srvr/z5089358/postgresql-10.4/src/backend/catalog/index.c:				elog(ERROR, "could not get element type of array type %u",
/srvr/z5089358/postgresql-10.4/src/backend/catalog/index.c:	 * Copy the index key, opclass, and indoption info into arrays (should we
/srvr/z5089358/postgresql-10.4/src/backend/catalog/index.c: * collationObjectId: array of collation OIDs, one per index column
/srvr/z5089358/postgresql-10.4/src/backend/catalog/index.c: * classObjectId: array of index opclass OIDs, one per index column
/srvr/z5089358/postgresql-10.4/src/backend/catalog/index.c: * coloptions: array of per-index-column indoption settings
/srvr/z5089358/postgresql-10.4/src/backend/catalog/index.c: *			Construct values[] and isnull[] arrays for a new index tuple.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/index.c: * its input arrays values[] and isnull[].  This is because the index AM
/srvr/z5089358/postgresql-10.4/src/backend/catalog/index.c:		 * pass the values[] and isnull[] arrays, instead.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/index.c:		 * by keeping a bool array in_index[] showing all the
/srvr/z5089358/postgresql-10.4/src/backend/catalog/index.c:		 * clear that array here, when advancing onto a new heap page.
/srvr/z5089358/postgresql-10.4/src/backend/catalog/index.c:			 * first. So pass the values[] and isnull[] arrays, instead.
/srvr/z5089358/postgresql-10.4/src/backend/replication/syncrep_scanner.c: * integer for use as an array index.  If the signed char is negative,
/srvr/z5089358/postgresql-10.4/src/backend/replication/syncrep_scanner.c:static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
/srvr/z5089358/postgresql-10.4/src/backend/replication/syncrep_scanner.c:		/* Extend the array by 50%, plus the number we really need. */
/srvr/z5089358/postgresql-10.4/src/backend/replication/basebackup.c:		 * Put the WAL filenames into an array, and sort. We send the files in
/srvr/z5089358/postgresql-10.4/src/backend/replication/slot.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/replication/slot.c:/* Control array for replication slot management */
/srvr/z5089358/postgresql-10.4/src/backend/replication/slot.c:/* My backend's replication slot in the shared memory array */
/srvr/z5089358/postgresql-10.4/src/backend/replication/slot.c:	 * The slot is definitely gone.  Lock out concurrent scans of the array
/srvr/z5089358/postgresql-10.4/src/backend/replication/slot.c:	 * grabbing the mutex because nobody else can be scanning the array here,
/srvr/z5089358/postgresql-10.4/src/backend/replication/slot.c:	 * scanning the array.
/srvr/z5089358/postgresql-10.4/src/backend/replication/syncrep_gram.c:/* The size of an array large to enough to hold all stacks, each with
/srvr/z5089358/postgresql-10.4/src/backend/replication/repl_scanner.c: * integer for use as an array index.  If the signed char is negative,
/srvr/z5089358/postgresql-10.4/src/backend/replication/repl_scanner.c:static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
/srvr/z5089358/postgresql-10.4/src/backend/replication/repl_scanner.c:		/* Extend the array by 50%, plus the number we really need. */
/srvr/z5089358/postgresql-10.4/src/backend/replication/README:the PMSignal array. That way postmaster can tell it apart from regular
/srvr/z5089358/postgresql-10.4/src/backend/replication/README:initialization and has marked itself in PMSignal array, and at process
/srvr/z5089358/postgresql-10.4/src/backend/replication/README:Each walsender allocates an entry from the WalSndCtl array, and tracks
/srvr/z5089358/postgresql-10.4/src/backend/replication/walreceiver.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/replication/walsender.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/replication/walsender.c:/* My slot in the shared memory array */
/srvr/z5089358/postgresql-10.4/src/backend/replication/syncrep.c:	XLogRecPtr *write_array;
/srvr/z5089358/postgresql-10.4/src/backend/replication/syncrep.c:	XLogRecPtr *flush_array;
/srvr/z5089358/postgresql-10.4/src/backend/replication/syncrep.c:	XLogRecPtr *apply_array;
/srvr/z5089358/postgresql-10.4/src/backend/replication/syncrep.c:	write_array = (XLogRecPtr *) palloc(sizeof(XLogRecPtr) * len);
/srvr/z5089358/postgresql-10.4/src/backend/replication/syncrep.c:	flush_array = (XLogRecPtr *) palloc(sizeof(XLogRecPtr) * len);
/srvr/z5089358/postgresql-10.4/src/backend/replication/syncrep.c:	apply_array = (XLogRecPtr *) palloc(sizeof(XLogRecPtr) * len);
/srvr/z5089358/postgresql-10.4/src/backend/replication/syncrep.c:		write_array[i] = walsnd->write;
/srvr/z5089358/postgresql-10.4/src/backend/replication/syncrep.c:		flush_array[i] = walsnd->flush;
/srvr/z5089358/postgresql-10.4/src/backend/replication/syncrep.c:		apply_array[i] = walsnd->apply;
/srvr/z5089358/postgresql-10.4/src/backend/replication/syncrep.c:	/* Sort each array in descending order */
/srvr/z5089358/postgresql-10.4/src/backend/replication/syncrep.c:	qsort(write_array, len, sizeof(XLogRecPtr), cmp_lsn);
/srvr/z5089358/postgresql-10.4/src/backend/replication/syncrep.c:	qsort(flush_array, len, sizeof(XLogRecPtr), cmp_lsn);
/srvr/z5089358/postgresql-10.4/src/backend/replication/syncrep.c:	qsort(apply_array, len, sizeof(XLogRecPtr), cmp_lsn);
/srvr/z5089358/postgresql-10.4/src/backend/replication/syncrep.c:	*writePtr = write_array[nth - 1];
/srvr/z5089358/postgresql-10.4/src/backend/replication/syncrep.c:	*flushPtr = flush_array[nth - 1];
/srvr/z5089358/postgresql-10.4/src/backend/replication/syncrep.c:	*applyPtr = apply_array[nth - 1];
/srvr/z5089358/postgresql-10.4/src/backend/replication/syncrep.c:	pfree(write_array);
/srvr/z5089358/postgresql-10.4/src/backend/replication/syncrep.c:	pfree(flush_array);
/srvr/z5089358/postgresql-10.4/src/backend/replication/syncrep.c:	pfree(apply_array);
/srvr/z5089358/postgresql-10.4/src/backend/replication/syncrep.c: * Compare lsn in order to sort array in descending order.
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/worker.c:#include "storage/procarray.h"
Binary file /srvr/z5089358/postgresql-10.4/src/backend/replication/logical/logicalfuncs.o matches
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/reorderbuffer.c: * Check whether the TransactionOId 'xid' is in the pre-sorted array 'xip'.
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/reorderbuffer.c:	/* build array we can easily sort */
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/launcher.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/launcher.c: * Walks the workers array and searches for one that matches given
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/launcher.c:	 * Need the fixed struct and the array of LogicalRepWorker.
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/logicalfuncs.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/logicalfuncs.c:				 errmsg("options array must not be null")));
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/logicalfuncs.c:	/* Deconstruct options array */
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/logicalfuncs.c:				 errmsg("array must be one-dimensional")));
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/logicalfuncs.c:	else if (array_contains_nulls(arr))
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/logicalfuncs.c:				 errmsg("array must not contain nulls")));
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/logicalfuncs.c:		deconstruct_array(arr, TEXTOID, -1, false, 'i',
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/logicalfuncs.c:					 errmsg("array must have even number of elements")));
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/logical.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/origin.c: * Base address into a shared memory array of replication states of size
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/origin.c: * array doesn't have to be searched when calling
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/snapbuild.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/snapbuild.c:		TransactionId *was_xip; /* running xacts array, xidComparator-sorted */
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/snapbuild.c:		 * As this array is frequently modified we do *not* keep it in
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/snapbuild.c:		 * xidComparator order. Instead we sort the array when building &
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/snapbuild.c:	 * In the 'xip' array we store transactions that have to be treated as
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/snapbuild.c:	 * also use the 'subxip' array to store their toplevel xid and all the
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/snapbuild.c:	 * Both arrays are qsort'ed so that we can use bsearch() on them.
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/snapbuild.c:	 * TODO: It might make sense to keep the array sorted here instead of
/srvr/z5089358/postgresql-10.4/src/backend/replication/logical/snapbuild.c: * than ->xmin. Those won't ever get checked via the ->committed array but via
/srvr/z5089358/postgresql-10.4/src/backend/replication/repl_gram.c:/* The size of an array large to enough to hold all stacks, each with
/srvr/z5089358/postgresql-10.4/src/backend/main/main.c:	 * Remember the physical location of the initially given argv[] array for
/srvr/z5089358/postgresql-10.4/src/backend/main/main.c:	 * save_ps_display_args makes and returns a new copy of the argv[] array.
Binary file /srvr/z5089358/postgresql-10.4/src/backend/postgres matches
/srvr/z5089358/postgresql-10.4/src/backend/storage/file/buffile.c:	File	   *files;			/* palloc'd array with numFiles entries */
/srvr/z5089358/postgresql-10.4/src/backend/storage/file/buffile.c:	off_t	   *offsets;		/* palloc'd array with numFiles entries */
/srvr/z5089358/postgresql-10.4/src/backend/storage/file/buffile.c:	 * because after creation we only repalloc our arrays larger.)
/srvr/z5089358/postgresql-10.4/src/backend/storage/file/fd.c: * Virtual File Descriptor array pointer and size.  This grows as
/srvr/z5089358/postgresql-10.4/src/backend/storage/file/fd.c: * needed.  'File' values are indexes into this array.
/srvr/z5089358/postgresql-10.4/src/backend/storage/file/fd.c:		 * array.  We choose to double it each time this happens. However,
/srvr/z5089358/postgresql-10.4/src/backend/storage/file/fd.c: * Make room for another allocatedDescs[] array entry if needed and possible.
/srvr/z5089358/postgresql-10.4/src/backend/storage/file/fd.c: * Returns true if an array element is available.
/srvr/z5089358/postgresql-10.4/src/backend/storage/file/fd.c:	/* Quick out if array already has a free slot. */
/srvr/z5089358/postgresql-10.4/src/backend/storage/file/fd.c:	 * If the array hasn't yet been created in the current process, initialize
/srvr/z5089358/postgresql-10.4/src/backend/storage/file/fd.c:	 * Consider enlarging the array beyond the initial allocation used above.
/srvr/z5089358/postgresql-10.4/src/backend/storage/file/fd.c: * The argument *must* point into the allocatedDescs[] array.
/srvr/z5089358/postgresql-10.4/src/backend/storage/file/fd.c:	/* Compact storage in the allocatedDescs array */
/srvr/z5089358/postgresql-10.4/src/backend/storage/file/fd.c: * Define a list (actually an array) of OIDs of tablespaces to use for
/srvr/z5089358/postgresql-10.4/src/backend/storage/file/fd.c: * responsibility that the passed-in array has adequate lifespan (typically
/srvr/z5089358/postgresql-10.4/src/backend/storage/file/reinit.c:		 * rather than an array or linked list to keep track of which files
/srvr/z5089358/postgresql-10.4/src/backend/storage/freespace/README:To assist in fast searching, the map isn't simply an array of per-page
/srvr/z5089358/postgresql-10.4/src/backend/storage/freespace/README:The binary tree is stored on each FSM page as an array. Because the page
/srvr/z5089358/postgresql-10.4/src/backend/storage/freespace/README:where the numbers denote each node's position in the array.  Note that the
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/Makefile:OBJS = dsm_impl.o dsm.o ipc.o ipci.o latch.o pmsignal.o procarray.o \
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/ipci.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/ipci.c:	 * Alloc the win32 shared backend array
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/sinvaladt.c: * infinite array, where maxMsgNum is the next array subscript to store a
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/sinvaladt.c: * submitted message in, minMsgNum is the smallest array subscript containing
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/sinvaladt.c: * Access to the shared sinval array is protected by two locks, SInvalReadLock
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/sinvaladt.c: * look at anyone else's.  When we need to perform array-wide updates,
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/sinvaladt.c: * to the array are actually there before maxMsgNum is increased, and that
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/sinvaladt.c:	/* procPid is zero in an inactive ProcState array entry. */
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/sinvaladt.c:	int			maxBackends;	/* size of procState array */
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/sinvaladt.c:	/* Clear message counters, save size of procState array, init spinlock */
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/sinvaladt.c:	/* The buffer[] array is initially all unused, so we need not fill it */
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/sinvaladt.c:	/* Look for a free entry in the procState array */
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/sinvaladt.c: * If the return value is less than the array size "datasize", the caller
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/sinvaladt.c:	 * Retrieve messages and advance backend's counter, until data array is
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/sinvaladt.c: * backends as "reset" in the array, and sending PROCSIG_CATCHUP_INTERRUPT
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/objfiles.txt:src/backend/storage/ipc/dsm_impl.o src/backend/storage/ipc/dsm.o src/backend/storage/ipc/ipc.o src/backend/storage/ipc/ipci.o src/backend/storage/ipc/latch.o src/backend/storage/ipc/pmsignal.o src/backend/storage/ipc/procarray.o src/backend/storage/ipc/procsignal.o src/backend/storage/ipc/shmem.o src/backend/storage/ipc/shmqueue.o src/backend/storage/ipc/shm_mq.o src/backend/storage/ipc/shm_toc.o src/backend/storage/ipc/sinval.o src/backend/storage/ipc/sinvaladt.o src/backend/storage/ipc/standby.o
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * procarray.c
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: *	  POSTGRES process array code.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * This module maintains arrays of the PGPROC and PGXACT structures for all
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * The process arrays now also include structures representing prepared
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * KnownAssignedXids array, and is updated by watching the sequence of
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * array represents standby processes, which by definition are not running
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * ourselves by pruning the array when a valid list of running XIDs arrives.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: *	  src/backend/storage/ipc/procarray.c
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	int			maxProcs;		/* allocated size of procs array */
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	int			maxKnownAssignedXids;	/* allocated size of array */
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	 * Highest subxid that has been removed from KnownAssignedXids array to
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:/* Primitives for KnownAssignedXids array handling for standby */
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:static int	KnownAssignedXidsGet(TransactionId *xarray, TransactionId xmax);
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:static int KnownAssignedXidsGetAndSetXmin(TransactionId *xarray,
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * Initialize the shared PGPROC array during postmaster startup.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	/* Create or attach to the KnownAssignedXids arrays too, if needed */
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * Add the specified PGPROC to the shared array.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	ProcArrayStruct *arrayP = procArray;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	if (arrayP->numProcs >= arrayP->maxProcs)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	 * Keep the procs array sorted by (PGPROC *) so that we can utilize
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	for (index = 0; index < arrayP->numProcs; index++)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		 * in the array, break
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		if ((arrayP->pgprocnos[index] == -1) || (arrayP->pgprocnos[index] > proc->pgprocno))
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	memmove(&arrayP->pgprocnos[index + 1], &arrayP->pgprocnos[index],
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:			(arrayP->numProcs - index) * sizeof(int));
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	arrayP->pgprocnos[index] = proc->pgprocno;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	arrayP->numProcs++;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * Remove the specified PGPROC from the shared array.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * array, and thus causing it to appear as "not running" anymore.  In this
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	ProcArrayStruct *arrayP = procArray;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	for (index = 0; index < arrayP->numProcs; index++)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		if (arrayP->pgprocnos[index] == proc->pgprocno)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:			/* Keep the PGPROC array sorted. See notes above */
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:			memmove(&arrayP->pgprocnos[index], &arrayP->pgprocnos[index + 1],
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:					(arrayP->numProcs - index - 1) * sizeof(int));
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:			arrayP->pgprocnos[arrayP->numProcs - 1] = -1;	/* for debugging */
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:			arrayP->numProcs--;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	 * Allocate a temporary array to avoid modifying the array passed as
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	 * Add to the temp array any xids which have not already completed.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		 * in the procarray when the snapshot was taken, but were already
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		 * Sort the array so that we can add them safely into
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * 2. The given Xid is one of the cached subxact Xids in the PGPROC array.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	ProcArrayStruct *arrayP = procArray;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		 * the bigger array, but we don't bother to shrink it.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		int			maxxids = RecoveryInProgress() ? TOTAL_MAX_CACHED_SUBXIDS : arrayP->maxProcs;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	/* No shortcuts, gotta grovel through the array */
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	for (i = 0; i < arrayP->numProcs; i++)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		int			pgprocno = arrayP->pgprocnos[i];
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		 * Step 2: check the cached child-Xids arrays
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	ProcArrayStruct *arrayP = procArray;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	for (i = 0; i < arrayP->numProcs; i++)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		int			pgprocno = arrayP->pgprocnos[i];
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	ProcArrayStruct *arrayP = procArray;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	for (index = 0; index < arrayP->numProcs; index++)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		int			pgprocno = arrayP->pgprocnos[index];
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		 * than the main procarray.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * GetMaxSnapshotXidCount -- get max size for snapshot XID array
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * GetMaxSnapshotSubxidCount -- get max size for snapshot sub-XID array
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * information may not be available.  If we find any overflowed subxid arrays,
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	ProcArrayStruct *arrayP = procArray;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	 * xip arrays if any.  (This relies on the fact that all callers pass
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		int		   *pgprocnos = arrayP->pgprocnos;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		numProcs = arrayP->numProcs;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		 * way is to just store all xids in the subxact array because this is
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		 * by far the bigger array. We just leave the xip array empty.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	ProcArrayStruct *arrayP = procArray;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	for (index = 0; index < arrayP->numProcs; index++)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		int			pgprocno = arrayP->pgprocnos[index];
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * array until the caller has WAL-logged this snapshot, and releases the
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	ProcArrayStruct *arrayP = procArray;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	 * Ensure that no xids enter or leave the procarray while we obtain
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	for (index = 0; index < arrayP->numProcs; index++)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		int			pgprocno = arrayP->pgprocnos[index];
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		for (index = 0; index < arrayP->numProcs; index++)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:			int			pgprocno = arrayP->pgprocnos[index];
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	ProcArrayStruct *arrayP = procArray;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	 * sure that all XIDs < nextXid are already present in the proc array (or
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	for (index = 0; index < arrayP->numProcs; index++)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		int			pgprocno = arrayP->pgprocnos[index];
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	ProcArrayStruct *arrayP = procArray;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	 * If we're not in recovery, we walk over the procarray and collect the
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		for (index = 0; index < arrayP->numProcs; index++)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:			int			pgprocno = arrayP->pgprocnos[index];
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * Constructs an array of VXIDs of transactions that are currently in commit
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * Returns a palloc'd array that should be freed by the caller.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	ProcArrayStruct *arrayP = procArray;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		palloc(sizeof(VirtualTransactionId) * arrayP->maxProcs);
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	for (index = 0; index < arrayP->numProcs; index++)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		int			pgprocno = arrayP->pgprocnos[index];
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	ProcArrayStruct *arrayP = procArray;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	for (index = 0; index < arrayP->numProcs; index++)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		int			pgprocno = arrayP->pgprocnos[index];
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	ProcArrayStruct *arrayP = procArray;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	for (index = 0; index < arrayP->numProcs; index++)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		PGPROC	   *proc = &allProcs[arrayP->pgprocnos[index]];
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	ProcArrayStruct *arrayP = procArray;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	for (index = 0; index < arrayP->numProcs; index++)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		int			pgprocno = arrayP->pgprocnos[index];
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * GetCurrentVirtualXIDs -- returns an array of currently active VXIDs.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * The array is palloc'd. The number of valid entries is returned into *nvxids.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * some snapshot we have.  Since we examine the procarray with only shared
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	ProcArrayStruct *arrayP = procArray;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		palloc(sizeof(VirtualTransactionId) * arrayP->maxProcs);
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	for (index = 0; index < arrayP->numProcs; index++)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		int			pgprocno = arrayP->pgprocnos[index];
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * GetConflictingVirtualXIDs -- returns an array of currently active VXIDs.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * but that would not be true in the case of FATAL errors lagging in array,
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * this array sufficiently often that we use malloc for the result.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	ProcArrayStruct *arrayP = procArray;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:			malloc(sizeof(VirtualTransactionId) * (arrayP->maxProcs + 1));
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	for (index = 0; index < arrayP->numProcs; index++)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		int			pgprocno = arrayP->pgprocnos[index];
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	ProcArrayStruct *arrayP = procArray;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	for (index = 0; index < arrayP->numProcs; index++)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		int			pgprocno = arrayP->pgprocnos[index];
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	ProcArrayStruct *arrayP = procArray;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	for (index = 0; index < arrayP->numProcs; index++)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		int			pgprocno = arrayP->pgprocnos[index];
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		 * PGPROC entry that's no longer in the array. It still points to a
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	ProcArrayStruct *arrayP = procArray;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	for (index = 0; index < arrayP->numProcs; index++)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		int			pgprocno = arrayP->pgprocnos[index];
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	ProcArrayStruct *arrayP = procArray;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	for (index = 0; index < arrayP->numProcs; index++)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		int			pgprocno = arrayP->pgprocnos[index];
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	ProcArrayStruct *arrayP = procArray;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	for (index = 0; index < arrayP->numProcs; index++)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		int			pgprocno = arrayP->pgprocnos[index];
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	ProcArrayStruct *arrayP = procArray;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	for (index = 0; index < arrayP->numProcs; index++)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		int			pgprocno = arrayP->pgprocnos[index];
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	ProcArrayStruct *arrayP = procArray;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		for (index = 0; index < arrayP->numProcs; index++)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:			int			pgprocno = arrayP->pgprocnos[index];
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * the xids[] array (of length nxids) are removed from the subxids cache.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	 * from the PGPROC array.  (See src/backend/access/transam/README.)  It's
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * the standby server's PGXACT array.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * that, similarly to tracking overflow of a PGPROC's subxids array.  We do
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * array due to such dead XIDs.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		 * Add (latestObservedXid, xid] onto the KnownAssignedXids array.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: *	* startup process pruning array when special WAL records arrive
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * The XIDs are stored in an array in sorted order --- TransactionIdPrecedes
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * To keep individual deletions cheap, we need to allow gaps in the array.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * This is implemented by marking array elements as valid or invalid using
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * the parallel boolean array KnownAssignedXidsValid[].  A deletion is done
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * array immediately on every deletion.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * have unspecified contents.  When head reaches the end of the array, we
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * immediately moving the array contents.  In most cases only a small fraction
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * of the array contains valid entries at any instant.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * must hold shared ProcArrayLock to examine the array.  To remove XIDs from
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * the array, the startup process must hold ProcArrayLock exclusively, for
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * during normal running).  Compressing unused entries out of the array
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * likewise requires exclusive lock.  To add XIDs to the array, we just insert
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * see the array element changes before they see the head pointer change.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: *	* Compressing the array is O(S) and requires exclusive lock
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * sorted array technique will deliver significantly faster snapshots.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * decide when to compress the array, though trimming also helps reduce
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * currently valid XIDs in the array.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * array, removing any gaps.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		 * less often though the virtual array would spread out more and
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	 * We compress the array by reading the valid values from tail to head,
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * Add xids into KnownAssignedXids at the head of the array.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * xids from from_xid to to_xid, inclusive, are added to the array.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	 * Calculate how many array slots we'll need.  Normally this is cheap; in
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	 * ensure that other processors see the above array updates before they
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		/* take spinlock to ensure we see up-to-date array contents */
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	 * array here, since even invalid entries will contain sorted XIDs.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		return false;			/* not in array */
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		return false;			/* in array, but invalid */
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	 * XLOG_XACT_ASSIGNMENT, to avoid array overflow.  Then those XIDs will be
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	/* Opportunistically compress the array */
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	 * Mark entries invalid starting at the tail.  Since array is sorted, we
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	/* Opportunistically compress the array */
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * KnownAssignedXidsGet - Get an array of xids by scanning KnownAssignedXids.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * Returns the number of XIDs stored into xarray[].  Caller is responsible
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * that array is large enough.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:KnownAssignedXidsGet(TransactionId *xarray, TransactionId xmax)
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	return KnownAssignedXidsGetAndSetXmin(xarray, &xtmp, xmax);
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:KnownAssignedXidsGetAndSetXmin(TransactionId *xarray, TransactionId *xmin,
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	 * cannot enter and then leave the array while we hold ProcArrayLock.  We
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:	 * Must take spinlock to ensure we see up-to-date array contents.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		/* Skip any gaps in the array */
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:			 * since the array is sorted.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:			 * of array.
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:			/* Add knownXid into output array */
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:			xarray[count++] = knownXid;
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c: * Get oldest XID in the KnownAssignedXids array, or InvalidTransactionId
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.c:		/* Skip any gaps in the array */
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/dsm_impl.c:		 * Note: palloc zbuffer, instead of just using a local char array, to
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/sinval.c: * for the strange-looking choice to use a statically allocated buffer array
Binary file /srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procarray.o matches
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/shmem.c:	 * uses the allocated space - e.g. by padding each element in an array of
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/dsm.c:	/* Enter the handle into a new array slot. */
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/pmsignal.c:	elog(FATAL, "no free slots in PMChildFlags array");
Binary file /srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/pmsignal.o matches
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/standby.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/standby.c:	/* array of TransactionIds */
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/latch.c:	 * said latch, and latch_pos the offset in the ->events array. This is
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/latch.c:	/* epoll_wait returns events in a user provided arrays, allocate once */
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procsignal.c: * in the ProcSignalSlots array. The array is indexed by backend ID to make
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procsignal.c: * slot allocation simple, and to avoid having to search the array when you
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procsignal.c: *		Register the current process in the procsignal array
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procsignal.c:		 * BackendId not provided, so search the array using pid.  We search
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procsignal.c:		 * the array back to front so as to reduce search overhead.  Passing
/srvr/z5089358/postgresql-10.4/src/backend/storage/ipc/procsignal.c:		 * process, which will have a slot near the end of the array.
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/predicate.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/predicate.c: * for as short a time as possible by returning two arrays that simply
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/predicate.c:	/* Get number of locks and allocate appropriately-sized arrays. */
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/predicate.c:	 * (in particular, an elog(ERROR) in procarray.c would cause us to leak
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/predicate.c: * subxip array.
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lwlock.c: * This points to the main array of LWLocks in shared memory.  Backends inherit
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lwlock.c: * allocated in the main array.
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lwlock.c:	/* Space for the LWLock array. */
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lwlock.c: * Allocate shmem space for the main LWLock array and all tranches and
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lwlock.c:		/* Ensure desired alignment of LWLock array */
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lwlock.c:	/* Initialize all individual LWLocks in main array */
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lwlock.c:	/* Initialize buffer mapping LWLocks in main array */
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lwlock.c:	/* Initialize lmgrs' LWLocks in main array */
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lwlock.c:	/* Initialize predicate lmgrs' LWLocks in main array */
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lwlock.c:	 * be the latest-acquired lock; so search array backwards.
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/proc.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/proc.c:	 * Also allocate a separate array of PGXACT structures.  This is separate
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/proc.c:	 * from the main PGPROC array so that the most heavily accessed data is
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/proc.c:	 * Add our PGPROC to the PGPROC array in shared memory.
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/README.barrier:More subtly, the reader might prefetch the contents of the q->items array
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/README.barrier:the array before bumping the item counter, and the reader to examine the item
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/README.barrier:counter before examining the array.
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/README:array within its PGPROC structure, rather than using the primary lock table.
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/README:from one place to another.  We accomplish this using an array of 1024 integer
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/README:array for matching fast-path locks; any which are found must be transferred to
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lmgr.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lock.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lock.c:	 * having filled up the fast path array, we don't attempt to make any
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lock.c:			/* If session lock is above array position 0, move it down to 0 */
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lock.c: * If the caller knows what those locks are, it can pass them as an array.
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lock.c: * If the caller knows what those locks are, it can pass them as an array.
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lock.c: *		Grant lock using per-backend fast-path array, if there is space.
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lock.c: *		arrays to the shared hash table.
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lock.c: *		Get an array of VirtualTransactionIds of xacts currently holding locks
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lock.c: * The result array is palloc'd and is terminated with an invalid VXID.
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lock.c: * Note we never include the current xact's vxid in the result array,
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lock.c:	 * examine each backend's fast-path array for conflicts.
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lock.c: * The return data consists of an array of LockInstanceData objects,
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lock.c:	 * First, we iterate through the per-backend fast-path arrays, locking
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lock.c: * the return data includes an array of LockInstanceData objects, which are
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lock.c: * blocked PID.)  In addition, we return an array of the PIDs of those backends
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lock.c: * waiting on any heavyweight lock, return empty arrays.
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lock.c:	 * for the procs[] array; the other two could need enlargement, though.)
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lock.c:	 * We may ignore the proc's fast-path arrays, since nothing in those could
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lock.c: * LogStandbySnapshot().  The result is a palloc'd array,
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lock.c:	 * but it's more convenient and faster than having to enlarge the array.
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/lock.c: *		examined by procarray.c, while fpLocalTransactionId is protected by
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/deadlock.c:	PGPROC	  **procs;			/* array of PGPROC *'s in new wait order */
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/deadlock.c: * of nWaitOrders WAIT_ORDER structs in waitOrders[], with PGPROC array
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/deadlock.c: * The output is an array of PGPROC pointers, of length equal to the lock's
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/deadlock.c: * The partial order is specified by an array of EDGE structs.  Each EDGE
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/deadlock.c: * the "blocker" in the output array.  The EDGE array may well contain
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/deadlock.c:	/* First, fill topoProcs[] array with the procs in their current order */
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/deadlock.c:	 * Scan the constraints, and for each proc in the array, generate a count
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/deadlock.c:	 * be in just one list). The array index for the before-proc of the i'th
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/deadlock.c:	 * zero, one, or multiple locks.  Since topoProcs[] is an array of the
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/deadlock.c:	 * processes actually waiting, while constraints[] is an array of group
/srvr/z5089358/postgresql-10.4/src/backend/storage/lmgr/deadlock.c:	 * Now scan the topoProcs array backwards.  At each step, output the
/srvr/z5089358/postgresql-10.4/src/backend/storage/smgr/smgr.c:	 * create an array which contains all relations to be dropped, and close
/srvr/z5089358/postgresql-10.4/src/backend/storage/smgr/md.c: *	File descriptors are stored in the per-fork md_seg_fds arrays inside
/srvr/z5089358/postgresql-10.4/src/backend/storage/smgr/md.c: *	SMgrRelation. The length of these arrays is stored in md_num_open_segs.
/srvr/z5089358/postgresql-10.4/src/backend/storage/smgr/md.c: *	segments are in the array" as an invariant anyway, since another backend
/srvr/z5089358/postgresql-10.4/src/backend/storage/smgr/md.c: *	The entire MdfdVec array is palloc'd in the MdCxt memory context.
/srvr/z5089358/postgresql-10.4/src/backend/storage/smgr/md.c: *		and added to the mdfd_seg_fds array.  If this routine has not been
/srvr/z5089358/postgresql-10.4/src/backend/storage/smgr/md.c: *		are present in the array.
/srvr/z5089358/postgresql-10.4/src/backend/storage/smgr/md.c:	 * managing the memory for the fd array easier, should there be errors.
/srvr/z5089358/postgresql-10.4/src/backend/storage/smgr/md.c: *	_fdvec_resize() -- Resize the fork's open segments array
/srvr/z5089358/postgresql-10.4/src/backend/storage/objfiles.txt:src/backend/storage/ipc/dsm_impl.o src/backend/storage/ipc/dsm.o src/backend/storage/ipc/ipc.o src/backend/storage/ipc/ipci.o src/backend/storage/ipc/latch.o src/backend/storage/ipc/pmsignal.o src/backend/storage/ipc/procarray.o src/backend/storage/ipc/procsignal.o src/backend/storage/ipc/shmem.o src/backend/storage/ipc/shmqueue.o src/backend/storage/ipc/shm_mq.o src/backend/storage/ipc/shm_toc.o src/backend/storage/ipc/sinval.o src/backend/storage/ipc/sinvaladt.o src/backend/storage/ipc/standby.o
/srvr/z5089358/postgresql-10.4/src/backend/storage/page/bufpage.c: *	in the array to make room.
/srvr/z5089358/postgresql-10.4/src/backend/storage/page/bufpage.c:	uint16		offsetindex;	/* linp array index */
/srvr/z5089358/postgresql-10.4/src/backend/storage/page/bufpage.c:	/* sort itemIdSortData array into decreasing itemoff order */
/srvr/z5089358/postgresql-10.4/src/backend/storage/page/bufpage.c:	 * copy all subsequent linp's back one slot in the array. We don't use
/srvr/z5089358/postgresql-10.4/src/backend/storage/page/bufpage.c:	 * PageGetItemId, because we are manipulating the _array_, not individual
/srvr/z5089358/postgresql-10.4/src/backend/storage/page/bufpage.c: * PageIndexTupleDelete ... however, the caller *must* supply the array
/srvr/z5089358/postgresql-10.4/src/backend/storage/page/bufpage.c:	 * Scan the item pointer array and build a list of just the ones we are
/srvr/z5089358/postgresql-10.4/src/backend/storage/page/bufpage.c:	 * array, is first to ensure adequate alignment for the checksumming code
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/buf_init.c:	 * The array used to sort to-be-checkpointed buffer ids is located in
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/buf_init.c:	 * array of I/O locks is allocated in a separate tranche.  Because those
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/buf_init.c:	 * locks are not highly contentended, we lay out the array with minimal
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/buf_init.c:	/* size of checkpoint sort array in bufmgr.c */
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/freelist.c:	/* Number of elements in buffers[] array */
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/freelist.c: * BufferSync() will proceed circularly around the buffer array from there.
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/bufmgr.c: * To avoid - as we used to - requiring an array with NBuffers entries to keep
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/bufmgr.c: * track of local buffers, we use a small sequentially searched array
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/bufmgr.c: * refcounts are kept track of in the array; after that, new array entries
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/bufmgr.c: * can't get "stuck" in the hashtable while infrequent ones clog the array.
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/bufmgr.c:	 * First search for a free entry the array, that'll be sufficient in the
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/bufmgr.c:	 * No luck. All array entries are full. Move one array entry into the hash
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/bufmgr.c:		 * Move entry from the current clock position in the array into the
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/bufmgr.c:		/* enter victim array entry into hashtable */
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/bufmgr.c:		/* clear the now free array slot */
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/bufmgr.c: * optimized for frequent access by moving it to the array.
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/bufmgr.c:	 * First search for references in the array, that'll be sufficient in the
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/bufmgr.c:	 * the array.
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/bufmgr.c:		/* caller doesn't want us to move the hash entry into the array */
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/bufmgr.c:		/* move buffer from hashtable into the free array slot */
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/bufmgr.c:		/* Ensure there's a free array slot */
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/bufmgr.c:		 * allows us to avoid ever having to search the array/hash for free
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/bufmgr.c:	 * linear scans of the buffer array don't think the buffer is valid.
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/bufmgr.c: * searching the private refcount array & hash, which is a boon, because the
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/bufmgr.c:	 * be flushed. This requires the to-be-flushed array to be sorted.
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/bufmgr.c:		 * Grow array of per-tablespace status structs, every time a new
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/bufmgr.c:	/* check the array */
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/bufmgr.c:	 * Add buffer to the pending writeback array, unless writeback control is
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/bufmgr.c:	 * through the, now sorted, array of pending flushes, and look forward to
/srvr/z5089358/postgresql-10.4/src/backend/storage/buffer/localbuf.c:	/* Allocate and zero buffer headers and auxiliary arrays */
/srvr/z5089358/postgresql-10.4/src/backend/commands/trigger.c:	/* build column number array if it's a column-specific trigger */
/srvr/z5089358/postgresql-10.4/src/backend/commands/trigger.c:	 * Allocate a working array to hold the triggers (the array is extended if
/srvr/z5089358/postgresql-10.4/src/backend/commands/trigger.c:	 * We need not examine the hint flags, just the trigger array itself; if
/srvr/z5089358/postgresql-10.4/src/backend/commands/trigger.c: *		tgindx: trigger's index in finfo and instr arrays.
/srvr/z5089358/postgresql-10.4/src/backend/commands/trigger.c: *		finfo: array of cached trigger function call information.
/srvr/z5089358/postgresql-10.4/src/backend/commands/trigger.c: *		instr: optional array of EXPLAIN ANALYZE instrumentation state.
/srvr/z5089358/postgresql-10.4/src/backend/commands/trigger.c: * To avoid palloc overhead, we keep trigger events in arrays in successively-
/srvr/z5089358/postgresql-10.4/src/backend/commands/trigger.c: * array).  The space between CHUNK_DATA_START and freeptr is occupied by
/srvr/z5089358/postgresql-10.4/src/backend/commands/trigger.c: * We use GetCurrentTransactionNestLevel() to determine the correct array
/srvr/z5089358/postgresql-10.4/src/backend/commands/trigger.c:	AfterTriggersQueryData *query_stack;	/* array of structs shown below */
/srvr/z5089358/postgresql-10.4/src/backend/commands/trigger.c:	int			query_depth;	/* current index in above array */
/srvr/z5089358/postgresql-10.4/src/backend/commands/trigger.c:	int			maxquerydepth;	/* allocated len of above array */
/srvr/z5089358/postgresql-10.4/src/backend/commands/trigger.c:	AfterTriggersTransData *trans_stack;	/* array of structs shown below */
/srvr/z5089358/postgresql-10.4/src/backend/commands/trigger.c:	int			maxtransdepth;	/* allocated len of above array */
/srvr/z5089358/postgresql-10.4/src/backend/commands/trigger.c: *	finfo: array of fmgr lookup cache entries (one per trigger in trigdesc).
/srvr/z5089358/postgresql-10.4/src/backend/commands/trigger.c: *	instr: array of EXPLAIN ANALYZE instrumentation nodes (one per trigger),
/srvr/z5089358/postgresql-10.4/src/backend/commands/trigger.c:	 * entries of the array; not worth the notational effort to avoid it.)
/srvr/z5089358/postgresql-10.4/src/backend/commands/trigger.c:	/* Initialize new array entries to empty */
/srvr/z5089358/postgresql-10.4/src/backend/commands/trigger.c:	 * The event code will be used both as a bitmask and an array offset, so
/srvr/z5089358/postgresql-10.4/src/backend/commands/trigger.c:	 * arrays.
/srvr/z5089358/postgresql-10.4/src/backend/commands/statscmds.c:	 * the expression list to a simple array of attnums.  While at it, enforce
/srvr/z5089358/postgresql-10.4/src/backend/commands/statscmds.c:	/* construct the char array of enabled statistic types */
/srvr/z5089358/postgresql-10.4/src/backend/commands/statscmds.c:	stxkind = construct_array(types, ntypes, CHAROID, 1, true, 'c');
/srvr/z5089358/postgresql-10.4/src/backend/commands/dbcommands.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/commands/collationcmds.c:		/* expansible array of aliases */
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c: * extConfig and extCondition should be arrays or PointerGetDatum(NULL).
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c: * We declare them as plain Datum to avoid needing array.h in extension.h.
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:	a = construct_array(datums, ndatums,
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:	Datum		arrayDatum;
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:	int			arrayLength;
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:	int			arrayIndex;
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:	 * extcondition arrays.
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:	arrayDatum = heap_getattr(extTup, Anum_pg_extension_extconfig,
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		/* Previously empty extconfig, so build 1-element array */
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		arrayLength = 0;
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		arrayIndex = 1;
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		a = construct_array(&elementDatum, 1,
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		/* Modify or extend existing extconfig array */
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		Oid		   *arrayData;
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		a = DatumGetArrayTypeP(arrayDatum);
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		arrayLength = ARR_DIMS(a)[0];
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:			arrayLength < 0 ||
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:			elog(ERROR, "extconfig is not a 1-D Oid array");
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		arrayData = (Oid *) ARR_DATA_PTR(a);
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		arrayIndex = arrayLength + 1;	/* set up to add after end */
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		for (i = 0; i < arrayLength; i++)
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:			if (arrayData[i] == tableoid)
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:				arrayIndex = i + 1; /* replace this element instead */
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		a = array_set(a, 1, &arrayIndex,
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:					  -1 /* varlena array */ ,
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:	arrayDatum = heap_getattr(extTup, Anum_pg_extension_extcondition,
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		if (arrayLength != 0)
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:			elog(ERROR, "extconfig and extcondition arrays do not match");
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		a = construct_array(&elementDatum, 1,
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		a = DatumGetArrayTypeP(arrayDatum);
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:			elog(ERROR, "extcondition is not a 1-D text array");
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		if (ARR_DIMS(a)[0] != arrayLength)
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:			elog(ERROR, "extconfig and extcondition arrays do not match");
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		a = array_set(a, 1, &arrayIndex,
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:					  -1 /* varlena array */ ,
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:	Datum		arrayDatum;
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:	int			arrayLength;
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:	int			arrayIndex;
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:	arrayDatum = heap_getattr(extTup, Anum_pg_extension_extconfig,
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		arrayLength = 0;
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		arrayIndex = -1;
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		Oid		   *arrayData;
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		a = DatumGetArrayTypeP(arrayDatum);
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		arrayLength = ARR_DIMS(a)[0];
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:			arrayLength < 0 ||
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:			elog(ERROR, "extconfig is not a 1-D Oid array");
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		arrayData = (Oid *) ARR_DATA_PTR(a);
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		arrayIndex = -1;		/* flag for no deletion needed */
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		for (i = 0; i < arrayLength; i++)
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:			if (arrayData[i] == tableoid)
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:				arrayIndex = i; /* index to remove */
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:	if (arrayIndex < 0)
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:	if (arrayLength <= 1)
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		/* removing only element, just set array to null */
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		deconstruct_array(a, OIDOID, sizeof(Oid), true, 'i',
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		for (i = arrayIndex; i < arrayLength - 1; i++)
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		a = construct_array(dvalues, arrayLength - 1,
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:	arrayDatum = heap_getattr(extTup, Anum_pg_extension_extcondition,
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		elog(ERROR, "extconfig and extcondition arrays do not match");
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		a = DatumGetArrayTypeP(arrayDatum);
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:			elog(ERROR, "extcondition is not a 1-D text array");
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		if (ARR_DIMS(a)[0] != arrayLength)
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:			elog(ERROR, "extconfig and extcondition arrays do not match");
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:	if (arrayLength <= 1)
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		/* removing only element, just set array to null */
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		deconstruct_array(a, TEXTOID, -1, false, 'i',
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		for (i = arrayIndex; i < arrayLength - 1; i++)
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		a = construct_array(dvalues, arrayLength - 1,
/srvr/z5089358/postgresql-10.4/src/backend/commands/extension.c:		 * extconfig array, which we must remove.
/srvr/z5089358/postgresql-10.4/src/backend/commands/subscriptioncmds.c: * Auxiliary function to return a text array out of a list of String nodes.
/srvr/z5089358/postgresql-10.4/src/backend/commands/subscriptioncmds.c:								   "publicationListToArray to array",
/srvr/z5089358/postgresql-10.4/src/backend/commands/subscriptioncmds.c:	arr = construct_array(datums, list_length(publist),
/srvr/z5089358/postgresql-10.4/src/backend/commands/subscriptioncmds.c:	 * Build qsorted array of local table oids for faster lookup. This can
/srvr/z5089358/postgresql-10.4/src/backend/commands/subscriptioncmds.c:	 * Also builds array of local oids of remote tables for the next step.
/srvr/z5089358/postgresql-10.4/src/backend/commands/tablespace.c:	/* Generate new proposed spcoptions (text array) */
/srvr/z5089358/postgresql-10.4/src/backend/commands/tablespace.c:	/* Generate new proposed spcoptions (text array) */
/srvr/z5089358/postgresql-10.4/src/backend/commands/tablespace.c:	/* Store tablespace OIDs in an array in TopTransactionContext */
Binary file /srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.o matches
/srvr/z5089358/postgresql-10.4/src/backend/commands/tsearchcmds.c: * Translate a list of token type names to an array of token type numbers
/srvr/z5089358/postgresql-10.4/src/backend/commands/tsearchcmds.c:	 * Convert list of dictionary names to array of dict OIDs
Binary file /srvr/z5089358/postgresql-10.4/src/backend/commands/statscmds.o matches
/srvr/z5089358/postgresql-10.4/src/backend/commands/prepare.c:static Datum build_regtype_array(Oid *param_types, int num_params);
/srvr/z5089358/postgresql-10.4/src/backend/commands/prepare.c:	/* Transform list of TypeNames to array of type OIDs */
/srvr/z5089358/postgresql-10.4/src/backend/commands/prepare.c:			values[3] = build_regtype_array(prep_stmt->plansource->param_types,
/srvr/z5089358/postgresql-10.4/src/backend/commands/prepare.c: * This utility function takes a C array of Oids, and returns a Datum
/srvr/z5089358/postgresql-10.4/src/backend/commands/prepare.c: * pointing to a one-dimensional Postgres array of regtypes. An empty
/srvr/z5089358/postgresql-10.4/src/backend/commands/prepare.c: * array is returned as a zero-element array, not NULL.
/srvr/z5089358/postgresql-10.4/src/backend/commands/prepare.c:build_regtype_array(Oid *param_types, int num_params)
/srvr/z5089358/postgresql-10.4/src/backend/commands/prepare.c:	result = construct_array(tmp_ary, num_params, REGTYPEOID, 4, true, 'i');
/srvr/z5089358/postgresql-10.4/src/backend/commands/functioncmds.c: * be created, but the other arrays are set to NULL if not needed.
/srvr/z5089358/postgresql-10.4/src/backend/commands/functioncmds.c: * variadicArgType is set to the variadic array type if there's a VARIADIC
/srvr/z5089358/postgresql-10.4/src/backend/commands/functioncmds.c:	/* Scan the list and extract data into work arrays */
/srvr/z5089358/postgresql-10.4/src/backend/commands/functioncmds.c:								 errmsg("VARIADIC parameter must be an array")));
/srvr/z5089358/postgresql-10.4/src/backend/commands/functioncmds.c:		*allParameterTypes = construct_array(allTypes, parameterCount, OIDOID,
/srvr/z5089358/postgresql-10.4/src/backend/commands/functioncmds.c:		*parameterModes = construct_array(paramModes, parameterCount, CHAROID,
/srvr/z5089358/postgresql-10.4/src/backend/commands/functioncmds.c:		*parameterNames = construct_array(paramNames, parameterCount, TEXTOID,
/srvr/z5089358/postgresql-10.4/src/backend/commands/functioncmds.c:		trftypes = construct_array(arr, list_length(trftypes_list),
/srvr/z5089358/postgresql-10.4/src/backend/commands/functioncmds.c:		/* store SQL NULL instead of empty array */
/srvr/z5089358/postgresql-10.4/src/backend/commands/functioncmds.c:		 * We know that composite, enum and array types are never binary-
/srvr/z5089358/postgresql-10.4/src/backend/commands/functioncmds.c:		 * binary-compatible with a composite, enum, or array type.  But we
/srvr/z5089358/postgresql-10.4/src/backend/commands/functioncmds.c:					 errmsg("array data types are not binary-compatible")));
Binary file /srvr/z5089358/postgresql-10.4/src/backend/commands/extension.o matches
/srvr/z5089358/postgresql-10.4/src/backend/commands/analyze.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/commands/analyze.c: * Selected rows are returned in the caller-allocated array rows[], which
/srvr/z5089358/postgresql-10.4/src/backend/commands/analyze.c: * qsort comparator for sorting rows[] array
/srvr/z5089358/postgresql-10.4/src/backend/commands/analyze.c:				arry = construct_array(numdatums, nnum,
/srvr/z5089358/postgresql-10.4/src/backend/commands/analyze.c:				arry = construct_array(stats->stavalues[k],
/srvr/z5089358/postgresql-10.4/src/backend/commands/analyze.c: * just in Datum arrays.
/srvr/z5089358/postgresql-10.4/src/backend/commands/analyze.c:			 * Collapse out the MCV items from the values[] array.
/srvr/z5089358/postgresql-10.4/src/backend/commands/analyze.c:			 * Note we destroy the values[] array here... but we don't need it
/srvr/z5089358/postgresql-10.4/src/backend/commands/analyze.c: * Aside from sorting the items, we update the tupnoLink[] array
/srvr/z5089358/postgresql-10.4/src/backend/commands/analyze.c: * whenever two ScalarItems are found to contain equal datums.  The array
/srvr/z5089358/postgresql-10.4/src/backend/commands/vacuumlazy.c: * The major space usage for LAZY VACUUM is storage for the array of dead tuple
/srvr/z5089358/postgresql-10.4/src/backend/commands/vacuumlazy.c: * initially allocate an array of TIDs of that size, with an upper limit that
/srvr/z5089358/postgresql-10.4/src/backend/commands/vacuumlazy.c: * uselessly for vacuuming small tables).  If the array threatens to overflow,
/srvr/z5089358/postgresql-10.4/src/backend/commands/vacuumlazy.c: * compaction, then resume the heap scan with an empty TID array.
/srvr/z5089358/postgresql-10.4/src/backend/commands/vacuumlazy.c: * the TID array, just enough to hold as many heap tuples as fit on one page.
/srvr/z5089358/postgresql-10.4/src/backend/commands/vacuumlazy.c:	int			max_dead_tuples;	/* # slots allocated in array */
/srvr/z5089358/postgresql-10.4/src/backend/commands/vacuumlazy.c:	ItemPointer dead_tuples;	/* array of ItemPointerData */
/srvr/z5089358/postgresql-10.4/src/backend/commands/vacuumlazy.c:	 * The array shouldn't overflow under normal behavior, but perhaps it
/srvr/z5089358/postgresql-10.4/src/backend/commands/vacuumlazy.c: *		Assumes dead_tuples array is in sorted order.
Binary file /srvr/z5089358/postgresql-10.4/src/backend/commands/event_trigger.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/commands/analyze.o matches
/srvr/z5089358/postgresql-10.4/src/backend/commands/publicationcmds.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/commands/async.c: *	  entering its PID into the array in AsyncQueueControl. It then scans all
/srvr/z5089358/postgresql-10.4/src/backend/commands/async.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/commands/async.c: * Each backend uses the backend[] array entry with index equal to its
/srvr/z5089358/postgresql-10.4/src/backend/commands/async.c:	 * The used entries in the backend[] array run from 1 to MaxBackends; the
/srvr/z5089358/postgresql-10.4/src/backend/commands/async.c: *		shared-memory listener array.  This must happen before commit to
/srvr/z5089358/postgresql-10.4/src/backend/commands/async.c:	/* If no longer listening to anything, get out of listener array */
/srvr/z5089358/postgresql-10.4/src/backend/commands/async.c:	/* Now we are listed in the global array, so remember we're listening */
/srvr/z5089358/postgresql-10.4/src/backend/commands/async.c: * array so we can binary-search it.  In practice the list is likely to be
/srvr/z5089358/postgresql-10.4/src/backend/commands/async.c: * Remove our entry from the listeners array when we are no longer listening
/srvr/z5089358/postgresql-10.4/src/backend/commands/async.c:	/* mark ourselves as no longer listed in the global array */
/srvr/z5089358/postgresql-10.4/src/backend/commands/async.c:	 * preallocate the arrays?	But in practice this is only run in trivial
/srvr/z5089358/postgresql-10.4/src/backend/commands/copy.c:	FmgrInfo   *in_functions;	/* array of input functions for each attrs */
/srvr/z5089358/postgresql-10.4/src/backend/commands/copy.c:	Oid		   *typioparams;	/* array of element types for in_functions */
/srvr/z5089358/postgresql-10.4/src/backend/commands/copy.c:	int		   *defmap;			/* array of default att numbers */
/srvr/z5089358/postgresql-10.4/src/backend/commands/copy.c:	ExprState **defexprs;		/* array of default att expressions */
/srvr/z5089358/postgresql-10.4/src/backend/commands/copy.c:	int			num_dispatch;	/* Number of entries in the above array */
/srvr/z5089358/postgresql-10.4/src/backend/commands/copy.c:	int			num_partitions; /* Number of members in the following arrays */
/srvr/z5089358/postgresql-10.4/src/backend/commands/copy.c:	 * the current line.  The CopyReadAttributes functions return arrays of
/srvr/z5089358/postgresql-10.4/src/backend/commands/copy.c:			 * arrays mt_partitions[] and mt_partition_tupconv_maps[] that
/srvr/z5089358/postgresql-10.4/src/backend/commands/copy.c: * 'values' and 'nulls' arrays must be the same length as columns of the
/srvr/z5089358/postgresql-10.4/src/backend/commands/copy.c: * relation passed to BeginCopyFrom. This function fills the arrays.
/srvr/z5089358/postgresql-10.4/src/backend/commands/copy.c: * This array is expanded as necessary.
Binary file /srvr/z5089358/postgresql-10.4/src/backend/commands/policy.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/backend/commands/foreigncmds.o matches
/srvr/z5089358/postgresql-10.4/src/backend/commands/vacuum.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/commands/vacuum.c: * specified kind of lock on each.  Return an array of Relation pointers for
/srvr/z5089358/postgresql-10.4/src/backend/commands/event_trigger.c:static Datum filter_list_to_array(List *filterlist);
/srvr/z5089358/postgresql-10.4/src/backend/commands/event_trigger.c:			filter_list_to_array(taglist);
/srvr/z5089358/postgresql-10.4/src/backend/commands/event_trigger.c: * store the list of strings as a text array.  This function transforms the
/srvr/z5089358/postgresql-10.4/src/backend/commands/event_trigger.c:filter_list_to_array(List *filterlist)
/srvr/z5089358/postgresql-10.4/src/backend/commands/event_trigger.c:	return PointerGetDatum(construct_array(data, l, TEXTOID, -1, false, 'i'));
/srvr/z5089358/postgresql-10.4/src/backend/commands/event_trigger.c:			values[i++] = PointerGetDatum(strlist_to_textarray(obj->addrnames));
/srvr/z5089358/postgresql-10.4/src/backend/commands/event_trigger.c:				values[i++] = PointerGetDatum(strlist_to_textarray(obj->addrargs));
/srvr/z5089358/postgresql-10.4/src/backend/commands/event_trigger.c:				values[i++] = PointerGetDatum(construct_empty_array(TEXTOID));
/srvr/z5089358/postgresql-10.4/src/backend/commands/alter.c: * such as not wanting to process array types --- those should never
Binary file /srvr/z5089358/postgresql-10.4/src/backend/commands/subscriptioncmds.o matches
/srvr/z5089358/postgresql-10.4/src/backend/commands/indexcmds.c:#include "storage/procarray.h"
/srvr/z5089358/postgresql-10.4/src/backend/commands/indexcmds.c:	 * Parse AM-specific options, convert to text array form, validate.
/srvr/z5089358/postgresql-10.4/src/backend/commands/explain.c: * as arrays of targetlist indexes.  If it's a sort key rather than a group
/srvr/z5089358/postgresql-10.4/src/backend/commands/explain.c: * key, also pass sort operators/collations/nullsFirst arrays.
/srvr/z5089358/postgresql-10.4/src/backend/commands/explain.c: * we need the list in order to determine the length of the PlanState array.
/srvr/z5089358/postgresql-10.4/src/backend/commands/explain.c:			/* top-level structure is an array of plans */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:Oid			binary_upgrade_next_array_pg_type_oid = InvalidOid;
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	char	   *array_type;
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	Oid			array_oid;
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	 * If it's not a shell, see if it's an autogenerated array type, and if so
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:		/* disallow arrays of pseudotypes */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:					 errmsg("array element type cannot be %s",
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	 * array type OID ahead of calling TypeCreate, since the base type and
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	 * array type each refer to the other.
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	array_oid = AssignTypeArrayOid();
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	 * Note: the pg_type.oid is stored in user tables as array elements (base
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:				   delimiter,	/* array element delimiter */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:				   false,		/* this is not an array type */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:				   array_oid,	/* array type we are about to create */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	 * Create the array type that goes with it.
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	array_type = makeArrayTypeName(typeName, typeNamespace);
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	/* alignment must be 'i' or 'd' for arrays */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	TypeCreate(array_oid,		/* force assignment of this type OID */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:			   array_type,		/* type name */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:			   TYPCATEGORY_ARRAY,	/* type-category (array) */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:			   false,			/* array types are never preferred */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:			   delimiter,		/* array element delimiter */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:			   true,			/* yes this is an array type */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:			   InvalidOid,		/* no further array type */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	pfree(array_type);
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	int32		typNDims = list_length(stmt->typeName->arrayBounds);
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	 * it's an autogenerated array, we can rename it out of the way.
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:				   delimiter,	/* array element delimiter */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:				   InvalidOid,	/* no array element type */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:				   false,		/* this isn't an array */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:				   InvalidOid,	/* no arrays for domains (yet) */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	 * it's an autogenerated array, we can rename it out of the way.
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:				   DEFAULT_TYPDELIM,	/* array element delimiter */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:				   false,		/* this is not an array type */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:				   enumArrayOid,	/* array type we are about to create */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	 * Create the array type that goes with it.
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:			   TYPCATEGORY_ARRAY,	/* type-category (array) */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:			   false,			/* array types are never preferred */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:			   DEFAULT_TYPDELIM,	/* array element delimiter */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:			   true,			/* yes this is an array type */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:			   InvalidOid,		/* no further array type */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:			   'i',				/* enums have align i, so do their arrays */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	 * If it's not a shell, see if it's an autogenerated array type, and if so
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	/* Allocate OID for array type */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:				   DEFAULT_TYPDELIM,	/* array element delimiter */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:				   false,		/* this is not an array type */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:				   rangeArrayOid,	/* array type we are about to create */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	 * Create the array type that goes with it.
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:			   TYPCATEGORY_ARRAY,	/* type-category (array) */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:			   false,			/* array types are never preferred */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:			   DEFAULT_TYPDELIM,	/* array element delimiter */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:			   true,			/* yes this is an array type */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:			   InvalidOid,		/* no further array type */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c: *	Pre-assign the type's array OID for use in pg_type.typarray
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	Oid			type_array_oid;
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	/* Use binary-upgrade override for pg_type.typarray? */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:		if (!OidIsValid(binary_upgrade_next_array_pg_type_oid))
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:					 errmsg("pg_type array OID value not set when in binary upgrade mode")));
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:		type_array_oid = binary_upgrade_next_array_pg_type_oid;
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:		binary_upgrade_next_array_pg_type_oid = InvalidOid;
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:		type_array_oid = GetNewOid(pg_type);
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	return type_array_oid;
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	 * it's an autogenerated array, we can rename it out of the way.  This
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:							 false, /* a domain isn't an implicit array */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c: * that are inside container types, such as composite types, arrays, or
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	/* don't allow direct alteration of array types, either */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:		get_array_type(typTup->typelem) == typeOid)
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:				 errmsg("cannot alter array type %s",
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:				 errhint("You can alter type %s, which will alter the array type as well.",
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	/* don't allow direct alteration of array types, either */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:		get_array_type(typTup->typelem) == typeOid)
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:				 errmsg("cannot alter array type %s",
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:				 errhint("You can alter type %s, which will alter the array type as well.",
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c: * passed as FALSE only for table rowtypes and array types).
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c: * to handle a possible array type.
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	/* If it has an array type, update that too */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	if (OidIsValid(typTup->typarray))
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:		AlterTypeOwnerInternal(typTup->typarray, newOwnerId);
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	/* don't allow direct alteration of array types */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	if (OidIsValid(elemOid) && get_array_type(elemOid) == typeOid)
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:				 errmsg("cannot alter array type %s",
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:				 errhint("You can alter type %s, which will alter the array type as well.",
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c: * The function automatically recurses to process the type's array type,
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c: * recursion (outside callers must never try to move an array type directly).
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	Oid			arrayOid;
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	arrayOid = typform->typarray;
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	 * one, and neither does an implicit array.
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	/* Recursively alter the associated array type, if any */
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:	if (OidIsValid(arrayOid))
/srvr/z5089358/postgresql-10.4/src/backend/commands/typecmds.c:		AlterTypeNamespaceInternal(arrayOid, nspOid, true, true, objsMoved);
Binary file /srvr/z5089358/postgresql-10.4/src/backend/commands/prepare.o matches
/srvr/z5089358/postgresql-10.4/src/backend/commands/foreigncmds.c: * Convert a DefElem list to the text array format that is used in
/srvr/z5089358/postgresql-10.4/src/backend/commands/foreigncmds.c: * Returns the array in the form of a Datum, or PointerGetDatum(NULL)
/srvr/z5089358/postgresql-10.4/src/backend/commands/foreigncmds.c: * Note: The array is usually stored to database without further
/srvr/z5089358/postgresql-10.4/src/backend/commands/foreigncmds.c: * Transform a list of DefElem into text array format.  This is substantially
/srvr/z5089358/postgresql-10.4/src/backend/commands/foreigncmds.c: * Returns the array in the form of a Datum, or PointerGetDatum(NULL)
/srvr/z5089358/postgresql-10.4/src/backend/commands/foreigncmds.c:		 * Pass a null options list as an empty array, so that validators
/srvr/z5089358/postgresql-10.4/src/backend/commands/foreigncmds.c:			valarg = PointerGetDatum(construct_empty_array(TEXTOID));
/srvr/z5089358/postgresql-10.4/src/backend/commands/foreigncmds.c:		/* Prepare the options array */
/srvr/z5089358/postgresql-10.4/src/backend/commands/foreigncmds.c:		/* Prepare the options array */
Binary file /srvr/z5089358/postgresql-10.4/src/backend/commands/tablecmds.o matches
/srvr/z5089358/postgresql-10.4/src/backend/commands/policy.c:#include "utils/array.h"
/srvr/z5089358/postgresql-10.4/src/backend/commands/policy.c:static Datum *policy_role_list_to_array(List *roles, int *num_roles);
/srvr/z5089358/postgresql-10.4/src/backend/commands/policy.c: * policy_role_list_to_array
/srvr/z5089358/postgresql-10.4/src/backend/commands/policy.c: *	 helper function to convert a list of RoleSpecs to an array of
/srvr/z5089358/postgresql-10.4/src/backend/commands/policy.c:policy_role_list_to_array(List *roles, int *num_roles)
/srvr/z5089358/postgresql-10.4/src/backend/commands/policy.c:	/* We should be removing exactly one entry from the roles array */
/srvr/z5089358/postgresql-10.4/src/backend/commands/policy.c:		/* Rebuild the roles array to then update the pg_policy tuple with */
/srvr/z5089358/postgresql-10.4/src/backend/commands/policy.c:		/* This is the array for the new tuple */
/srvr/z5089358/postgresql-10.4/src/backend/commands/policy.c:		role_ids = construct_array(role_oids, num_roles, OIDOID,
/srvr/z5089358/postgresql-10.4/src/backend/commands/policy.c:	role_oids = policy_role_list_to_array(stmt->roles, &nitems);
/srvr/z5089358/postgresql-10.4/src/backend/commands/policy.c:	role_ids = construct_array(role_oids, nitems, OIDOID,
/srvr/z5089358/postgresql-10.4/src/backend/commands/policy.c:		role_oids = policy_role_list_to_array(stmt->roles, &nitems);
/srvr/z5089358/postgresql-10.4/src/backend/commands/policy.c:		role_ids = construct_array(role_oids, nitems, OIDOID,
/srvr/z5089358/postgresql-10.4/src/backend/commands/cluster.c:	/* Preallocate values/isnull arrays */
Binary file /srvr/z5089358/postgresql-10.4/src/backend/commands/functioncmds.o matches
/srvr/z5089358/postgresql-10.4/src/backend/commands/tablecmds.c:static const struct dropmsgstrings dropmsgstringarray[] = {
/srvr/z5089358/postgresql-10.4/src/backend/commands/tablecmds.c:		/* Protect fixed-size arrays here and in executor */
/srvr/z5089358/postgresql-10.4/src/backend/commands/tablecmds.c:	for (rentry = dropmsgstringarray; rentry->kind != '\0'; rentry++)
/srvr/z5089358/postgresql-10.4/src/backend/commands/tablecmds.c:	for (rentry = dropmsgstringarray; rentry->kind != '\0'; rentry++)
/srvr/z5089358/postgresql-10.4/src/backend/commands/tablecmds.c:	for (wentry = dropmsgstringarray; wentry->kind != '\0'; wentry++)
/srvr/z5089358/postgresql-10.4/src/backend/commands/tablecmds.c:		/* Preallocate values/isnull arrays */
/srvr/z5089358/postgresql-10.4/src/backend/commands/tablecmds.c: * (possibly nested several levels deep in composite types, arrays, etc!).
/srvr/z5089358/postgresql-10.4/src/backend/commands/tablecmds.c: * another container type such as an array or range, or a domain over one of
/srvr/z5089358/postgresql-10.4/src/backend/commands/tablecmds.c:			 * This must be an array, domain, or range containing the given
/srvr/z5089358/postgresql-10.4/src/backend/commands/tablecmds.c:	attribute.attndims = list_length(colDef->typeName->arrayBounds);
/srvr/z5089358/postgresql-10.4/src/backend/commands/tablecmds.c:	/* Generate new proposed attoptions (text array) */
/srvr/z5089358/postgresql-10.4/src/backend/commands/tablecmds.c:	attTup->attndims = list_length(typeName->arrayBounds);
/srvr/z5089358/postgresql-10.4/src/backend/commands/tablecmds.c:		elog(ERROR, "conpfeqop is not a 1-D Oid array");
/srvr/z5089358/postgresql-10.4/src/backend/commands/tablecmds.c:	/* Generate new proposed reloptions (text array) */
/srvr/z5089358/postgresql-10.4/src/backend/commands/tablecmds.c:	 * char[] array, the compiler might align it on any byte boundary, which
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: storage/file/fd.c:2044 storage/ipc/procarray.c:1058
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: storage/ipc/procarray.c:1546 storage/ipc/procarray.c:1553
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: storage/ipc/procarray.c:1970 storage/ipc/procarray.c:2581
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:3803 utils/adt/arrayfuncs.c:6323
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "cannot set privileges of array types"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "non  possibile impostare privilegi su tipi array"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "could not form array type name for type \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "creazione del nome per il tipo array del tipo \"%s\" fallita"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "VARIADIC parameter must be an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "il parametro VARIADIC dev'essere un array"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "array data types are not binary-compatible"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "i tipi di dati array non sono compatibili a livello binario"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "array element type cannot be %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "il tipo di elemento dell'array non pu essere %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "pg_type array OID value not set when in binary upgrade mode"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "valore di OID array di pg_type non impostato in modalit di aggiornamento binaria"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "cannot alter array type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "non  possibile modificare il tipo di array %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "You can alter type %s, which will alter the array type as well."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "puoi modificare il tipo %s, il che modificher il tipo dell'array come conseguenza."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "target type is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "il tipo di destinazione non  un array"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: executor/execExprInterp.c:2226 utils/adt/arrayfuncs.c:260
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:558 utils/adt/arrayfuncs.c:1288
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:3361 utils/adt/arrayfuncs.c:5239
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:5756
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "il numero di dimensioni dell'array (%d) eccede il massimo consentito (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "cannot merge incompatible arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "non  possibile unire array non compatibili"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "Un array con tipo di elementi %s non pu essere incluso nel costrutto ARRAY con elementi di tipo %s."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "gli array multidimensionali devono avere espressioni array di dimensioni corrispondenti"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "l'indice di un array nell'assegnamento non pu essere nullo"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/array_userfuncs.c:724 utils/adt/array_userfuncs.c:863
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:3639 utils/adt/arrayfuncs.c:4077
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:6037 utils/adt/rowtypes.c:1167
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:1457 utils/adt/rowtypes.c:563
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "could not find array type for data type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "non  stato possibile trovare il tipo di array per il tipo di dati %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "arguments declared \"anyarray\" are not all alike"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "gli argomenti dichiarati \"anyarray\" non sono tutti simili"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "argument declared %s is not an array but type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "l'argomento dichiarato %s non  un array ma di tipo %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "type matched to anynonarray is an array type: %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "il tipo associato ad anynonarray  di tipo array: %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "cannot determine type of empty array"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "non  possibile determinare il tipo di un array vuoto"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "VARIADIC argument must be an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "l'argomento VARIADIC deve essere un array"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "cannot subscript type %s because it is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "non  possibile usare un indice su %s perch non  un array"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "array subscript must have type integer"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "l'indice di un array dev'essere di tipo intero"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "array assignment requires type %s but expression is of type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "l'assegnamento all'array richiede il tipo %s ma l'espressione  di tipo %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "op ANY/ALL (array) requires array on right side"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "op ANY/ALL (array) richiede un array sul lato destro"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "op ANY/ALL (array) requires operator to yield boolean"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "op ANY/ALL (array) richiede che l'operatore restituisca un valore booleano"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "op ANY/ALL (array) requires operator not to return a set"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "op ANY/ALL (array) richiede che l'operatore non restituisca un insieme"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "cannot set an array element to DEFAULT"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "non  possibile impostare gli elementi di un array a DEFAULT"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "array assignment to \"%s\" requires type %s but expression is of type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "l'assegnamento array a \"%s\" richiede il tipo %s ma l'espressione  di tipo %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "array of serial is not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "gli array di serial non sono implementati"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: postmaster/postmaster.c:2249 storage/ipc/procarray.c:292
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "options array must not be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "l'array di opzioni non pu essere nullo"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "array must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "l'array deve essere monodimensionale"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "l'array non deve contenere NULL"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "array must have even number of elements"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "l'array deve avere un numero pari di elementi"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "invalid zero-length item array in MVDependencies"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "elemento array a lunghezza zero non valido in MVDependencies"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "invalid zero-length item array in MVNDistinct"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "elemento array a lunghezza zero non valido in MVDistinct"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "ACL array contains wrong data type"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "l'array di ACL array contiene tipi di dati errati"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "ACL arrays must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "gli array di ACL devono avere una sola dimensione"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "ACL arrays must not contain null values"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "gli array di ACL non possono contenere valori nulli"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/array_expanded.c:274 utils/adt/arrayfuncs.c:931
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:1519 utils/adt/arrayfuncs.c:3251
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:3389 utils/adt/arrayfuncs.c:5846
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:6157 utils/adt/arrayutils.c:93
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayutils.c:102 utils/adt/arrayutils.c:109
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "array size exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "la dimensione dell'array supera il massimo consentito (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/array_userfuncs.c:79 utils/adt/array_userfuncs.c:471
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/array_userfuncs.c:551 utils/adt/json.c:1765 utils/adt/json.c:1860
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/array_userfuncs.c:84
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "input data type is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "il tipo di dati in input non  un array"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/array_userfuncs.c:132 utils/adt/array_userfuncs.c:186
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:1322 utils/adt/float.c:1228 utils/adt/float.c:1287
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/array_userfuncs.c:139 utils/adt/array_userfuncs.c:196
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "argument must be empty or one-dimensional array"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "l'argomento deve essere vuoto o un array con una sola dimensione"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/array_userfuncs.c:278 utils/adt/array_userfuncs.c:317
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/array_userfuncs.c:354 utils/adt/array_userfuncs.c:383
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/array_userfuncs.c:411
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "cannot concatenate incompatible arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "non  possibile concatenare array non compatibili"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/array_userfuncs.c:279
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/array_userfuncs.c:318
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/array_userfuncs.c:355
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/array_userfuncs.c:384 utils/adt/array_userfuncs.c:412
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/array_userfuncs.c:667 utils/adt/array_userfuncs.c:819
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "searching for elements in multidimensional arrays is not supported"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "la ricerca di elementi in array multidimensionali non  supportata"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/array_userfuncs.c:691
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:268 utils/adt/arrayfuncs.c:282
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:293 utils/adt/arrayfuncs.c:315
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:330 utils/adt/arrayfuncs.c:344
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:350 utils/adt/arrayfuncs.c:357
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:488 utils/adt/arrayfuncs.c:504
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:515 utils/adt/arrayfuncs.c:530
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:551 utils/adt/arrayfuncs.c:581
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:588 utils/adt/arrayfuncs.c:596
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:630 utils/adt/arrayfuncs.c:653
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:673 utils/adt/arrayfuncs.c:785
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:794 utils/adt/arrayfuncs.c:824
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:839 utils/adt/arrayfuncs.c:892
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "malformed array literal: \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "il letterale array non  definito in modo corretto: \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:269
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "\"[\" must introduce explicitly-specified array dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "\"[\" deve introdurre un array con dimensioni specificate esplicitamente."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:283
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "Missing array dimension value."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "Valore delle dimensioni dell'array mancante."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:294 utils/adt/arrayfuncs.c:331
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "Missing \"%s\" after array dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "Manca \"%s\" dopo le dimensioni dell'array."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:303 utils/adt/arrayfuncs.c:2870
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:2902 utils/adt/arrayfuncs.c:2917
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:316
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "L'array deve iniziare con \"{\" oppure con le informazioni di dimensione."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:345
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "Il contenuto dell'array deve cominciare con \"{\"."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:351 utils/adt/arrayfuncs.c:358
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "Specified array dimensions do not match array contents."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "Le dimensioni specificate per l'array non combaciano con il contenuto."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:489 utils/adt/arrayfuncs.c:516
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:505 utils/adt/arrayfuncs.c:552
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:582 utils/adt/arrayfuncs.c:631
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:531 utils/adt/arrayfuncs.c:654
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "Unexpected array element."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "Elemento dell'array inatteso."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:589
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:597 utils/adt/jsonfuncs.c:2381
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "Multidimensional arrays must have sub-arrays with matching dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "Gli array multidimensionali devono avere sotto-array con dimensioni corrispondenti."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:674
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:1284 utils/adt/arrayfuncs.c:3357
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:5752
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:1295
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "invalid array flags"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "i flag dell'array non sono validi"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:1303
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:1353 utils/adt/rangetypes.c:334
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:1493
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "improper binary format in array element %d"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "il formato binario nell'elemento dell'array %d non  corretto"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:1574 utils/adt/rangetypes.c:339
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:2052
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "slices of fixed-length arrays not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "le sezioni di array a lunghezza fissa non sono implementate"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:2230 utils/adt/arrayfuncs.c:2252
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:2301 utils/adt/arrayfuncs.c:2537
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:2848 utils/adt/arrayfuncs.c:5738
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:5764 utils/adt/arrayfuncs.c:5775
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "wrong number of array subscripts"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "il numero di indici di array  errato"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:2235 utils/adt/arrayfuncs.c:2343
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:2601 utils/adt/arrayfuncs.c:2907
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "array subscript out of range"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "indice dell'array fuori dall'intervallo"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:2240
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "cannot assign null value to an element of a fixed-length array"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "non  possibile assegnare un valore nullo a un elemento di un array a dimensione fissa"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:2795
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "updates on slices of fixed-length arrays not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "la modifica di sezioni di array a lunghezza fissa non  implementate"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:2826
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "array slice subscript must provide both boundaries"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "l'indice della sezione dell'array deve fornire entrambi i limiti"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:2827
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "When assigning to a slice of an empty array value, slice boundaries must be fully specified."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "Quando si assegna ad una sezione di un array vuoto, i limiti della sezione devono essere specificati interamente."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:2838 utils/adt/arrayfuncs.c:2933
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "source array too small"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "l'array di origine  troppo piccolo"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:3513
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "null array element not allowed in this context"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "in questo contesto non  consentito un elemento di array nullo"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:3615 utils/adt/arrayfuncs.c:3786
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:4060
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "cannot compare arrays of different element types"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "non  possibile confrontare array con elementi di tipo diverso"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:3962 utils/adt/rangetypes.c:1253
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:5152
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "data type %s is not an array type"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "il tipo di dati %s non  un tipo array"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:5207
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "cannot accumulate null arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "non  possibile accumulare array nulli"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:5235
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "cannot accumulate empty arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "non  possibile accumulare array vuoti"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:5264 utils/adt/arrayfuncs.c:5270
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "cannot accumulate arrays of different dimensionality"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "non  possibile accumulare array di dimensioni diverse"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:5636 utils/adt/arrayfuncs.c:5676
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "dimension array or low bound array cannot be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "la dimensione dell'array o il suo limite inferiore non possono essere nulli"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:5739 utils/adt/arrayfuncs.c:5765
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "Dimension array must be one dimensional."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "L'array delle dimensioni deve avere una sola dimensione."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:5744 utils/adt/arrayfuncs.c:5770
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:5776
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "Low bound array has different size than dimensions array."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "L'array dei valori inferiori ha dimensione differente dal numero di dimensioni dell'array."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:6022
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "removing elements from multidimensional arrays is not supported"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "la rimozione di elementi da array multidimensionali non  supportata"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:6299
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "thresholds must be one-dimensional array"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "la soglia dev'essere un array monodimensionale"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayfuncs.c:6304
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "thresholds array must not contain NULLs"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "l'array delle soglie non pu contenere NULL"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayutils.c:209
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "typmod array must be type cstring[]"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "il typmod dell'array deve essere di tipo cstring[]"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayutils.c:214
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "typmod array must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "il typmod dell'array deve avere una sola dimensione"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:#: utils/adt/arrayutils.c:219
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "typmod array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "il typmod dell'array non pu contenere valori nulli"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "Expected array element or \"]\", but found \"%s\"."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "Era previsto un elemento di array oppure \"]\", trovato \"%s\" invece."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "key value must be scalar, not array, composite, or json"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "la chiave deve essere uno scalare, non array, composito n json"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "array must have two columns"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "l'array deve avere due colonne"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "mismatched array dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "le dimensioni degli array non combaciano"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "number of jsonb array elements exceeds the maximum allowed (%zu)"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "il numero di elementi dell'array jsonb supera il massimo consentito (%zu)"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "total size of jsonb array elements exceeds the maximum of %u bytes"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "la dimensione totale degli elementi dell'array jsonb supera il massimo di %u byte"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "cannot call %s on an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "non  possibile eseguire %s su un array"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "cannot get array length of a scalar"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "cannot get array length of a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "non  possibile ottenere la lunghezza di un oggetto che non  un array"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "cannot deconstruct an array as an object"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "non  possibile decostruire un array come un oggetto"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "cannot call %s on a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "non  possibile eseguire %s su un argomento che non  un array"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "expected json array"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "atteso un array json"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "See the array element %s of key \"%s\"."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "Vedi l'elemento dell'array %s della chiave \"%s\"."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "See the array element %s."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "Vedi l'elemento dell'array %s."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "malformed json array"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "array json non valido"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "argument of %s must be an array of objects"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "l'argomento di %s deve essere un array di oggetti"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "regexp_split_to_array does not support the global option"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "regexp_split_to_array non supporta l'opzione globale"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "array of weight must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "l'array dei pesi deve avere una sola dimensione"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "array of weight is too short"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "l'array dei pesi  troppo corto"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "array of weight must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "l'array dei pesi non pu contenere valori nulli"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "lexeme array may not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "l'array di lessemi non pu contenere null"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "weight array may not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "l'array dei pesi non pu contenere null"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "invalid array for XML namespace mapping"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "l'array per il mapping del namespace XML non  valido"
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "The array must be two-dimensional with length of the second axis equal to 2."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "L'array deve avere due dimensioni e la lunghezza del secondo asse deve essere pari a 2."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "Enable input of NULL elements in arrays."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "Abilita l'input di elementi NULL negli array."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "When turned on, unquoted NULL in an array input value means a null value; otherwise it is taken literally."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "Se abilitato, un NULL senza apici come valore di input in un array indica un valore nullo; altrimenti  preso letteralmente."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgid "For RAID arrays, this should be approximately the number of drive spindles in the array."
/srvr/z5089358/postgresql-10.4/src/backend/po/it.po:msgstr "Per i sistemi RAID, questo valore  pari all'incirca al numero di dischi fisici nell'array."
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: storage/file/fd.c:2049 storage/ipc/procarray.c:1058
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: storage/ipc/procarray.c:1546 storage/ipc/procarray.c:1553
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: storage/ipc/procarray.c:1970 storage/ipc/procarray.c:2581
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:3803 utils/adt/arrayfuncs.c:6323
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "cannot set privileges of array types"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "could not form array type name for type \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "VARIADIC parameter must be an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "array data types are not binary-compatible"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "array element type cannot be %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "pg_type array OID value not set when in binary upgrade mode"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "cannot alter array type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "You can alter type %s, which will alter the array type as well."
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "target type is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: executor/execExprInterp.c:2226 utils/adt/arrayfuncs.c:260
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:558 utils/adt/arrayfuncs.c:1288
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:3361 utils/adt/arrayfuncs.c:5239
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:5756
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "cannot merge incompatible arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/array_userfuncs.c:724 utils/adt/array_userfuncs.c:863
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:3639 utils/adt/arrayfuncs.c:4077
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:6037 utils/adt/rowtypes.c:1167
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:1457 utils/adt/rowtypes.c:563
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "could not find array type for data type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "arguments declared \"anyarray\" are not all alike"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgstr "\"anyarray\""
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "argument declared %s is not an array but type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "type matched to anynonarray is an array type: %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgstr "anynonarray: %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "cannot determine type of empty array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "VARIADIC argument must be an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "cannot subscript type %s because it is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "array subscript must have type integer"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "array assignment requires type %s but expression is of type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "op ANY/ALL (array) requires array on right side"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "op ANY/ALL (array) requires operator to yield boolean"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "op ANY/ALL (array) requires operator not to return a set"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "cannot set an array element to DEFAULT"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "array assignment to \"%s\" requires type %s but expression is of type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "array of serial is not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: postmaster/postmaster.c:2269 storage/ipc/procarray.c:292
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "options array must not be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "array must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "array must have even number of elements"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "invalid zero-length item array in MVDependencies"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "invalid zero-length item array in MVNDistinct"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "ACL array contains wrong data type"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "ACL arrays must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "ACL arrays must not contain null values"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/array_expanded.c:274 utils/adt/arrayfuncs.c:931
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:1519 utils/adt/arrayfuncs.c:3251
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:3389 utils/adt/arrayfuncs.c:5846
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:6157 utils/adt/arrayutils.c:93
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayutils.c:102 utils/adt/arrayutils.c:109
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "array size exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/array_userfuncs.c:79 utils/adt/array_userfuncs.c:471
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/array_userfuncs.c:551 utils/adt/json.c:1765 utils/adt/json.c:1860
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/array_userfuncs.c:84
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "input data type is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/array_userfuncs.c:132 utils/adt/array_userfuncs.c:186
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:1322 utils/adt/float.c:1228 utils/adt/float.c:1287
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/array_userfuncs.c:139 utils/adt/array_userfuncs.c:196
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "argument must be empty or one-dimensional array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/array_userfuncs.c:278 utils/adt/array_userfuncs.c:317
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/array_userfuncs.c:354 utils/adt/array_userfuncs.c:383
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/array_userfuncs.c:411
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "cannot concatenate incompatible arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/array_userfuncs.c:279
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/array_userfuncs.c:318
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/array_userfuncs.c:355
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/array_userfuncs.c:384 utils/adt/array_userfuncs.c:412
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/array_userfuncs.c:667 utils/adt/array_userfuncs.c:819
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "searching for elements in multidimensional arrays is not supported"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/array_userfuncs.c:691
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:268 utils/adt/arrayfuncs.c:282
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:293 utils/adt/arrayfuncs.c:315
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:330 utils/adt/arrayfuncs.c:344
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:350 utils/adt/arrayfuncs.c:357
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:488 utils/adt/arrayfuncs.c:504
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:515 utils/adt/arrayfuncs.c:530
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:551 utils/adt/arrayfuncs.c:581
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:588 utils/adt/arrayfuncs.c:596
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:630 utils/adt/arrayfuncs.c:653
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:673 utils/adt/arrayfuncs.c:785
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:794 utils/adt/arrayfuncs.c:824
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:839 utils/adt/arrayfuncs.c:892
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "malformed array literal: \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:269
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "\"[\" must introduce explicitly-specified array dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:283
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "Missing array dimension value."
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:294 utils/adt/arrayfuncs.c:331
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "Missing \"%s\" after array dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:303 utils/adt/arrayfuncs.c:2870
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:2902 utils/adt/arrayfuncs.c:2917
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:316
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:345
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:351 utils/adt/arrayfuncs.c:358
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "Specified array dimensions do not match array contents."
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:489 utils/adt/arrayfuncs.c:516
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:505 utils/adt/arrayfuncs.c:552
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:582 utils/adt/arrayfuncs.c:631
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:531 utils/adt/arrayfuncs.c:654
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "Unexpected array element."
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:589
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:597 utils/adt/jsonfuncs.c:2381
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "Multidimensional arrays must have sub-arrays with matching dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:674
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:1284 utils/adt/arrayfuncs.c:3357
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:5752
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:1295
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "invalid array flags"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:1303
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:1353 utils/adt/rangetypes.c:334
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:1493
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "improper binary format in array element %d"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:1574 utils/adt/rangetypes.c:339
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:2052
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "slices of fixed-length arrays not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:2230 utils/adt/arrayfuncs.c:2252
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:2301 utils/adt/arrayfuncs.c:2537
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:2848 utils/adt/arrayfuncs.c:5738
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:5764 utils/adt/arrayfuncs.c:5775
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "wrong number of array subscripts"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:2235 utils/adt/arrayfuncs.c:2343
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:2601 utils/adt/arrayfuncs.c:2907
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "array subscript out of range"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:2240
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "cannot assign null value to an element of a fixed-length array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:2795
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "updates on slices of fixed-length arrays not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:2826
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "array slice subscript must provide both boundaries"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:2827
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "When assigning to a slice of an empty array value, slice boundaries must be fully specified."
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:2838 utils/adt/arrayfuncs.c:2933
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "source array too small"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:3513
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "null array element not allowed in this context"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:3615 utils/adt/arrayfuncs.c:3786
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:4060
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "cannot compare arrays of different element types"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:3962 utils/adt/rangetypes.c:1253
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:5152
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "data type %s is not an array type"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:5207
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "cannot accumulate null arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:5235
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "cannot accumulate empty arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:5264 utils/adt/arrayfuncs.c:5270
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "cannot accumulate arrays of different dimensionality"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:5636 utils/adt/arrayfuncs.c:5676
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "dimension array or low bound array cannot be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:5739 utils/adt/arrayfuncs.c:5765
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "Dimension array must be one dimensional."
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:5744 utils/adt/arrayfuncs.c:5770
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:5776
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "Low bound array has different size than dimensions array."
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:6022
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "removing elements from multidimensional arrays is not supported"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:6299
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "thresholds must be one-dimensional array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayfuncs.c:6304
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "thresholds array must not contain NULLs"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayutils.c:209
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "typmod array must be type cstring[]"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayutils.c:214
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "typmod array must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:#: utils/adt/arrayutils.c:219
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "typmod array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "Expected array element or \"]\", but found \"%s\"."
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "key value must be scalar, not array, composite, or json"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "array must have two columns"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "mismatched array dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "number of jsonb array elements exceeds the maximum allowed (%zu)"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "total size of jsonb array elements exceeds the maximum of %u bytes"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "cannot call %s on an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "cannot get array length of a scalar"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "cannot get array length of a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "cannot deconstruct an array as an object"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "cannot call %s on a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "expected json array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "See the array element %s of key \"%s\"."
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "See the array element %s."
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "malformed json array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "argument of %s must be an array of objects"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "regexp_split_to_array does not support the global option"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgstr "regexp_split_to_arrayglobal"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "array of weight must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "array of weight is too short"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "array of weight must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "lexeme array may not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "weight array may not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "invalid array for XML namespace mapping"
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "The array must be two-dimensional with length of the second axis equal to 2."
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "Enable input of NULL elements in arrays."
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "When turned on, unquoted NULL in an array input value means a null value; otherwise it is taken literally."
/srvr/z5089358/postgresql-10.4/src/backend/po/ja.po:msgid "For RAID arrays, this should be approximately the number of drive spindles in the array."
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: postmaster/postmaster.c:4683 postmaster/postmaster.c:4758 postmaster/postmaster.c:5436 postmaster/postmaster.c:5773 replication/libpqwalreceiver/libpqwalreceiver.c:256 replication/logical/logical.c:170 storage/buffer/localbuf.c:436 storage/file/fd.c:773 storage/file/fd.c:1201 storage/file/fd.c:1319 storage/file/fd.c:2044 storage/ipc/procarray.c:1058 storage/ipc/procarray.c:1546
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: storage/ipc/procarray.c:1553 storage/ipc/procarray.c:1970 storage/ipc/procarray.c:2581 utils/adt/formatting.c:1579 utils/adt/formatting.c:1703 utils/adt/formatting.c:1828 utils/adt/pg_locale.c:468 utils/adt/pg_locale.c:652 utils/adt/regexp.c:219 utils/adt/varlena.c:4589 utils/adt/varlena.c:4610 utils/fmgr/dfmgr.c:221 utils/hash/dynahash.c:444 utils/hash/dynahash.c:553
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: access/gin/ginutil.c:134 executor/execExpr.c:1780 utils/adt/arrayfuncs.c:3803 utils/adt/arrayfuncs.c:6323 utils/adt/rowtypes.c:927
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "cannot set privileges of array types"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "dizi (array) tiplerinin haklar ayarlanamaz"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "could not form array type name for type \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "\"%s\" tipi iin array tipi bulunamyor"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "VARIADIC parameter must be an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "VARIADIC parametresi bir dizi (array) olmaldr"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "array data types are not binary-compatible"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "dizi (array)  veri tipleri ikili-uyumlu deil"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "array element type cannot be %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "array element veri tipi %s olamaz"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "pg_type array OID value not set when in binary upgrade mode"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "cannot alter array type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "%s array tipi deitirilemez"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "You can alter type %s, which will alter the array type as well."
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "%s tipini deitirebilirsiniz, ayn zamanda array type de deitirilecektir."
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "target type is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "hedef tipi array deildir"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: executor/execExpr.c:2371 executor/execExpr.c:2377 executor/execExprInterp.c:2226 utils/adt/arrayfuncs.c:260 utils/adt/arrayfuncs.c:558 utils/adt/arrayfuncs.c:1288 utils/adt/arrayfuncs.c:3361 utils/adt/arrayfuncs.c:5239 utils/adt/arrayfuncs.c:5756
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "cannot merge incompatible arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "atamada array subscript null olamaz"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: executor/execReplication.c:256 parser/parse_oper.c:228 utils/adt/array_userfuncs.c:724 utils/adt/array_userfuncs.c:863 utils/adt/arrayfuncs.c:3639 utils/adt/arrayfuncs.c:4077 utils/adt/arrayfuncs.c:6037 utils/adt/rowtypes.c:1167
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: libpq/pqformat.c:557 libpq/pqformat.c:575 libpq/pqformat.c:596 utils/adt/arrayfuncs.c:1457 utils/adt/rowtypes.c:563
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "could not find array type for data type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "%s veri tipi iin array tipi bulunamyor"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "arguments declared \"anyarray\" are not all alike"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "\"anyarray\" olarak tanmlanan argmanlar birbirine benzemiyor"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "argument declared %s is not an array but type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "%s olarak tanmlanm argman bir dizi (array) deil, %s tipidir"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "type matched to anynonarray is an array type: %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "anynonarray ile eletirilen tip bir array tipidir: %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "cannot determine type of empty array"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "bo dizi'nin (array) tipi belirlenemiyor"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "VARIADIC argument must be an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "VARIADIC argman bir dizi (array) olmaldr"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "cannot subscript type %s because it is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "%s tipi bir array olmad iin ona subscript yaplamaz "
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "array subscript must have type integer"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "array subscript tamsy tipinde olmaldr"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "array assignment requires type %s but expression is of type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "array atamas %s tipini gerektirmektedir ancak ifade %s tipindedir"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "op ANY/ALL (array) requires array on right side"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "op ANY/ALL (array) sa tarafta bir array gerektiri"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "op ANY/ALL (array) requires operator to yield boolean"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "op ANY/ALL (array) operatorun boolean tipinde deer getirilmesi gerekir"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "op ANY/ALL (array) requires operator not to return a set"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "op ANY/ALL (array) operatorun set tipinde deer getirilmesi gerekir"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "cannot set an array element to DEFAULT"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "array esine DEFAULT deeri atanamyor"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "array assignment to \"%s\" requires type %s but expression is of type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "array of serial is not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "seri dizisi (array of serial) implement edilmemitir"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: postmaster/postmaster.c:2249 storage/ipc/procarray.c:292 storage/ipc/sinvaladt.c:298 storage/lmgr/proc.c:338
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "options array must not be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "seenekler dizisi (optionns array) null olmamal"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "array must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "dizi (array) tek boyutlu olmaldr"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "array null iermemeli"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "array must have even number of elements"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "dizinin (array) ift sayda eleman olmal"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "invalid zero-length item array in MVDependencies"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "invalid zero-length item array in MVNDistinct"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "array size exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "ACL array contains wrong data type"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "ACL array yanl veri tipini iermektedir"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "ACL arrays must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "ACL array tek boyutlu olmaldr"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "ACL arrays must not contain null values"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "ACL array null kaytlar ieremez"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/array_expanded.c:274 utils/adt/arrayfuncs.c:931 utils/adt/arrayfuncs.c:1519 utils/adt/arrayfuncs.c:3251 utils/adt/arrayfuncs.c:3389 utils/adt/arrayfuncs.c:5846 utils/adt/arrayfuncs.c:6157 utils/adt/arrayutils.c:93 utils/adt/arrayutils.c:102 utils/adt/arrayutils.c:109
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "array size exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/array_userfuncs.c:79 utils/adt/array_userfuncs.c:471 utils/adt/array_userfuncs.c:551 utils/adt/json.c:1765 utils/adt/json.c:1860 utils/adt/json.c:1898 utils/adt/jsonb.c:1128 utils/adt/jsonb.c:1157 utils/adt/jsonb.c:1549 utils/adt/jsonb.c:1713 utils/adt/jsonb.c:1723
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/array_userfuncs.c:84
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "target type is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "input data type is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "hedef tipi array deildir"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/array_userfuncs.c:132 utils/adt/array_userfuncs.c:186 utils/adt/arrayfuncs.c:1322 utils/adt/float.c:1228 utils/adt/float.c:1287 utils/adt/float.c:3556 utils/adt/float.c:3572 utils/adt/int.c:608 utils/adt/int.c:637 utils/adt/int.c:658 utils/adt/int.c:689 utils/adt/int.c:722 utils/adt/int.c:744 utils/adt/int.c:892 utils/adt/int.c:913 utils/adt/int.c:940 utils/adt/int.c:980
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/array_userfuncs.c:139 utils/adt/array_userfuncs.c:196
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "argument must be empty or one-dimensional array"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/array_userfuncs.c:278 utils/adt/array_userfuncs.c:317 utils/adt/array_userfuncs.c:354 utils/adt/array_userfuncs.c:383 utils/adt/array_userfuncs.c:411
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "cannot concatenate incompatible arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "uyumsuz arraylar birletirilemez"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/array_userfuncs.c:279
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/array_userfuncs.c:318
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/array_userfuncs.c:355
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/array_userfuncs.c:384 utils/adt/array_userfuncs.c:412
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/array_userfuncs.c:667 utils/adt/array_userfuncs.c:819
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "multidimensional arrays are not supported"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "searching for elements in multidimensional arrays is not supported"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/array_userfuncs.c:691
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:268 utils/adt/arrayfuncs.c:282 utils/adt/arrayfuncs.c:293 utils/adt/arrayfuncs.c:315 utils/adt/arrayfuncs.c:330 utils/adt/arrayfuncs.c:344 utils/adt/arrayfuncs.c:350 utils/adt/arrayfuncs.c:357 utils/adt/arrayfuncs.c:488 utils/adt/arrayfuncs.c:504 utils/adt/arrayfuncs.c:515 utils/adt/arrayfuncs.c:530 utils/adt/arrayfuncs.c:551 utils/adt/arrayfuncs.c:581
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:588 utils/adt/arrayfuncs.c:596 utils/adt/arrayfuncs.c:630 utils/adt/arrayfuncs.c:653 utils/adt/arrayfuncs.c:673 utils/adt/arrayfuncs.c:785 utils/adt/arrayfuncs.c:794 utils/adt/arrayfuncs.c:824 utils/adt/arrayfuncs.c:839 utils/adt/arrayfuncs.c:892
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "malformed array literal: \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "array literal bozuk: \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:269
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "\"[\" must introduce explicitly-specified array dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:283
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "Missing array dimension value."
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:294 utils/adt/arrayfuncs.c:331
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "missing \"]\" in array dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "Missing \"%s\" after array dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "array tanmnda \"]\" eksik"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:303 utils/adt/arrayfuncs.c:2870 utils/adt/arrayfuncs.c:2902 utils/adt/arrayfuncs.c:2917
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:316
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "array value must start with \"{\" or dimension information"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "array deeri ya \"{\" ile ya da boyut bilgisi ile balamaldr"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:345
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:351 utils/adt/arrayfuncs.c:358
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "array dimensions incompatible with array literal"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "Specified array dimensions do not match array contents."
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "array boyutlar array deimezi ile uyumsuz"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:489 utils/adt/arrayfuncs.c:516 utils/adt/rangetypes.c:2114 utils/adt/rangetypes.c:2122 utils/adt/rowtypes.c:208 utils/adt/rowtypes.c:216
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:505 utils/adt/arrayfuncs.c:552 utils/adt/arrayfuncs.c:582 utils/adt/arrayfuncs.c:631
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:531 utils/adt/arrayfuncs.c:654
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "Unexpected array element."
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:589
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:597 utils/adt/jsonfuncs.c:2381
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "Multidimensional arrays must have sub-arrays with matching dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:674
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:1284 utils/adt/arrayfuncs.c:3357 utils/adt/arrayfuncs.c:5752
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:1295
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "invalid array flags"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "array flags geersiz"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:1303
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:1353 utils/adt/rangetypes.c:334 utils/cache/lsyscache.c:2683
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:1493
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "improper binary format in array element %d"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:1574 utils/adt/rangetypes.c:339 utils/cache/lsyscache.c:2716
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:2052
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "slices of fixed-length arrays not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:2230 utils/adt/arrayfuncs.c:2252 utils/adt/arrayfuncs.c:2301 utils/adt/arrayfuncs.c:2537 utils/adt/arrayfuncs.c:2848 utils/adt/arrayfuncs.c:5738 utils/adt/arrayfuncs.c:5764 utils/adt/arrayfuncs.c:5775 utils/adt/json.c:2259 utils/adt/json.c:2334 utils/adt/jsonb.c:1327 utils/adt/jsonb.c:1413 utils/adt/jsonfuncs.c:4141 utils/adt/jsonfuncs.c:4292
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "wrong number of array subscripts"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "array subscript says yanl"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:2235 utils/adt/arrayfuncs.c:2343 utils/adt/arrayfuncs.c:2601 utils/adt/arrayfuncs.c:2907
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "array subscript out of range"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "array subscript kapsam dsdr"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:2240
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "cannot assign null value to an element of a fixed-length array"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "sabit uzunluklu array elementine null deeri atanamaz"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:2795
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "updates on slices of fixed-length arrays not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:2826
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "array subscript must have type integer"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "array slice subscript must provide both boundaries"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "array subscript tamsy tipinde olmaldr"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:2827
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "When assigning to a slice of an empty array value, slice boundaries must be fully specified."
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:2838 utils/adt/arrayfuncs.c:2933
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "source array too small"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "kaynak array kk"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:3513
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "null array element not allowed in this context"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "bu ortamda null array elementi kabul edilmemektedir"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:3615 utils/adt/arrayfuncs.c:3786 utils/adt/arrayfuncs.c:4060
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "cannot compare arrays of different element types"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:3962 utils/adt/rangetypes.c:1253
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:5152
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "target type is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "data type %s is not an array type"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "hedef tipi array deildir"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:5207
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "cannot concatenate incompatible arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "cannot accumulate null arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "uyumsuz arraylar birletirilemez"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:5235
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "cannot concatenate incompatible arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "cannot accumulate empty arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "uyumsuz arraylar birletirilemez"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:5264 utils/adt/arrayfuncs.c:5270
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "cannot compare arrays of different element types"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "cannot accumulate arrays of different dimensionality"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:5636 utils/adt/arrayfuncs.c:5676
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "dimension array or low bound array cannot be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:5739 utils/adt/arrayfuncs.c:5765
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "Dimension array must be one dimensional."
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "typmod array tek boyutlu olmaldr"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:5744 utils/adt/arrayfuncs.c:5770
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:5776
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "Low bound array has different size than dimensions array."
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:6022
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "multidimensional arrays are not supported"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "removing elements from multidimensional arrays is not supported"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:6299
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "argument must be empty or one-dimensional array"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "thresholds must be one-dimensional array"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayfuncs.c:6304
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "typmod array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "thresholds array must not contain NULLs"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "typmod array null kaytlar ieremez"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayutils.c:209
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "typmod array must be type cstring[]"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "typmod array tamsy tipinde olmaldr"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayutils.c:214
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "typmod array must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "typmod array tek boyutlu olmaldr"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#: utils/adt/arrayutils.c:219
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "typmod array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "typmod array null kaytlar ieremez"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "Expected array element or \"]\", but found \"%s\"."
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "key value must be scalar, not array, composite, or json"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "array must have two columns"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "null array element not allowed in this context"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "bu ortamda null array elementi kabul edilmemektedir"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "mismatched array dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "number of jsonb array elements exceeds the maximum allowed (%zu)"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "total size of jsonb array elements exceeds the maximum of %u bytes"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "cannot accept a value of type anyarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "cannot call %s on an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "anyarray tipinde deer alnamaz"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "cannot set an array element to DEFAULT"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "cannot get array length of a scalar"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "array esine DEFAULT deeri atanamyor"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "cannot get array length of a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "anyarray tipinde deer alnamaz"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "cannot deconstruct an array as an object"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "cannot call %s on a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "anyarray tipinde deer alnamaz"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "expected json array"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "array element type cannot be %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "See the array element %s of key \"%s\"."
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "array element veri tipi %s olamaz"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "See the array element %s."
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "malformed array literal: \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "malformed json array"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "array literal bozuk: \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "argument of %s must be an array of objects"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "atamada array subscript null olamaz"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "invalid array flags"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "array flags geersiz"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "malformed array literal: \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "array literal bozuk: \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "regexp_split_to_array does not support the global option"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "array of weight must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "ACL array tek boyutlu olmaldr"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "array of weight is too short"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "array of weight must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "array null kaytlar ieremez"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "typmod array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "lexeme array may not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "typmod array null kaytlar ieremez"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "typmod array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "weight array may not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "typmod array null kaytlar ieremez"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#| msgid "array size exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "invalid array for XML namespace mapping"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "The array must be two-dimensional with length of the second axis equal to 2."
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "Enable input of NULL elements in arrays."
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "When turned on, unquoted NULL in an array input value means a null value; otherwise it is taken literally."
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgstr "Ak olduunda, array girdisinde trnak iinde alnmam NULL deeri null anlamna gelir; aksi taktirde deer, olduu gibi kabul edilir."
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:msgid "For RAID arrays, this should be approximately the number of drive spindles in the array."
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#~ msgid "op ANY/ALL (array) does not support set arguments"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#~ msgstr "op ANY/ALL (array) set parametreleri desteklememektedir"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#~ msgid "cannot display a value of type anynonarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#~ msgid "wrong range of array subscripts"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#~ msgstr "array subscript says yanl"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#~ msgid "neither input type is an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/tr.po:#~ msgstr "giri tiplerinin hibiri array deildir"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: storage/file/fd.c:2044 storage/ipc/procarray.c:1058
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: storage/ipc/procarray.c:1546 storage/ipc/procarray.c:1553
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: storage/ipc/procarray.c:1970 storage/ipc/procarray.c:2581
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:3803 utils/adt/arrayfuncs.c:6323
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "cannot set privileges of array types"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "could not form array type name for type \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "VARIADIC parameter must be an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "array data types are not binary-compatible"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "array element type cannot be %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "pg_type array OID value not set when in binary upgrade mode"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "cannot alter array type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "You can alter type %s, which will alter the array type as well."
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "target type is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: executor/execExprInterp.c:2226 utils/adt/arrayfuncs.c:260
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:558 utils/adt/arrayfuncs.c:1288
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:3361 utils/adt/arrayfuncs.c:5239
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:5756
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "cannot merge incompatible arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:"multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/array_userfuncs.c:724 utils/adt/array_userfuncs.c:863
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:3639 utils/adt/arrayfuncs.c:4077
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:6037 utils/adt/rowtypes.c:1167
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:1457 utils/adt/rowtypes.c:563
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "could not find array type for data type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "arguments declared \"anyarray\" are not all alike"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgstr "\"anyarray\"      ."
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgstr "\"anyarray\"      ."
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "argument declared %s is not an array but type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgstr "%s    array , %s "
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "type matched to anynonarray is an array type: %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgstr "anynonarray    : %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "cannot determine type of empty array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "VARIADIC argument must be an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "cannot subscript type %s because it is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "array subscript must have type integer"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "array assignment requires type %s but expression is of type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "op ANY/ALL (array) requires array on right side"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgstr "op ANY/ALL (array)     ."
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "op ANY/ALL (array) requires operator to yield boolean"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgstr "op ANY/ALL (array)  boolean     ."
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "op ANY/ALL (array) requires operator not to return a set"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgstr "op ANY/ALL (array)  set  return     ."
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "cannot set an array element to DEFAULT"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:"array assignment to \"%s\" requires type %s but expression is of type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "array of serial is not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: postmaster/postmaster.c:2249 storage/ipc/procarray.c:292
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "options array must not be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "array must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "array must have even number of elements"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "invalid zero-length item array in MVDependencies"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "invalid zero-length item array in MVNDistinct"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "ACL array contains wrong data type"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "ACL arrays must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "ACL arrays must not contain null values"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/array_expanded.c:274 utils/adt/arrayfuncs.c:931
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:1519 utils/adt/arrayfuncs.c:3251
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:3389 utils/adt/arrayfuncs.c:5846
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:6157 utils/adt/arrayutils.c:93
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayutils.c:102 utils/adt/arrayutils.c:109
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "array size exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/array_userfuncs.c:79 utils/adt/array_userfuncs.c:471
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/array_userfuncs.c:551 utils/adt/json.c:1764 utils/adt/json.c:1859
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/array_userfuncs.c:84
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "input data type is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/array_userfuncs.c:132 utils/adt/array_userfuncs.c:186
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:1322 utils/adt/float.c:1228 utils/adt/float.c:1287
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/array_userfuncs.c:139 utils/adt/array_userfuncs.c:196
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "argument must be empty or one-dimensional array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/array_userfuncs.c:278 utils/adt/array_userfuncs.c:317
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/array_userfuncs.c:354 utils/adt/array_userfuncs.c:383
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/array_userfuncs.c:411
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "cannot concatenate incompatible arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/array_userfuncs.c:279
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/array_userfuncs.c:318
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/array_userfuncs.c:355
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/array_userfuncs.c:384 utils/adt/array_userfuncs.c:412
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/array_userfuncs.c:667 utils/adt/array_userfuncs.c:819
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "searching for elements in multidimensional arrays is not supported"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/array_userfuncs.c:691
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:268 utils/adt/arrayfuncs.c:282
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:293 utils/adt/arrayfuncs.c:315
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:330 utils/adt/arrayfuncs.c:344
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:350 utils/adt/arrayfuncs.c:357
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:488 utils/adt/arrayfuncs.c:504
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:515 utils/adt/arrayfuncs.c:530
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:551 utils/adt/arrayfuncs.c:581
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:588 utils/adt/arrayfuncs.c:596
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:630 utils/adt/arrayfuncs.c:653
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:673 utils/adt/arrayfuncs.c:785
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:794 utils/adt/arrayfuncs.c:824
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:839 utils/adt/arrayfuncs.c:892
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "malformed array literal: \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:269
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "\"[\" must introduce explicitly-specified array dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:283
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "Missing array dimension value."
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:294 utils/adt/arrayfuncs.c:331
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "Missing \"%s\" after array dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:303 utils/adt/arrayfuncs.c:2870
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:2902 utils/adt/arrayfuncs.c:2917
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:316
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:345
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:351 utils/adt/arrayfuncs.c:358
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "Specified array dimensions do not match array contents."
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:489 utils/adt/arrayfuncs.c:516
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:505 utils/adt/arrayfuncs.c:552
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:582 utils/adt/arrayfuncs.c:631
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:531 utils/adt/arrayfuncs.c:654
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "Unexpected array element."
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:589
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:597 utils/adt/jsonfuncs.c:2381
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "Multidimensional arrays must have sub-arrays with matching dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:674
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:1284 utils/adt/arrayfuncs.c:3357
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:5752
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:1295
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "invalid array flags"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:1303
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:1353 utils/adt/rangetypes.c:334
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:1493
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "improper binary format in array element %d"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:1574 utils/adt/rangetypes.c:339
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:2052
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "slices of fixed-length arrays not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:2230 utils/adt/arrayfuncs.c:2252
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:2301 utils/adt/arrayfuncs.c:2537
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:2848 utils/adt/arrayfuncs.c:5738
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:5764 utils/adt/arrayfuncs.c:5775
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "wrong number of array subscripts"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:2235 utils/adt/arrayfuncs.c:2343
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:2601 utils/adt/arrayfuncs.c:2907
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "array subscript out of range"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:2240
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "cannot assign null value to an element of a fixed-length array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:2795
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "updates on slices of fixed-length arrays not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:2826
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "array slice subscript must provide both boundaries"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:2827
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:"When assigning to a slice of an empty array value, slice boundaries must be "
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:2838 utils/adt/arrayfuncs.c:2933
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "source array too small"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:3513
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "null array element not allowed in this context"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:3615 utils/adt/arrayfuncs.c:3786
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:4060
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "cannot compare arrays of different element types"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:3962 utils/adt/rangetypes.c:1253
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:5152
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "data type %s is not an array type"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:5207
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "cannot accumulate null arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:5235
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "cannot accumulate empty arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:5264 utils/adt/arrayfuncs.c:5270
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "cannot accumulate arrays of different dimensionality"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:5636 utils/adt/arrayfuncs.c:5676
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "dimension array or low bound array cannot be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:5739 utils/adt/arrayfuncs.c:5765
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "Dimension array must be one dimensional."
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:5744 utils/adt/arrayfuncs.c:5770
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:5776
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "Low bound array has different size than dimensions array."
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:6022
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "removing elements from multidimensional arrays is not supported"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:6299
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "thresholds must be one-dimensional array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayfuncs.c:6304
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "thresholds array must not contain NULLs"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayutils.c:209
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "typmod array must be type cstring[]"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayutils.c:214
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "typmod array must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:#: utils/adt/arrayutils.c:219
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "typmod array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "Expected array element or \"]\", but found \"%s\"."
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "key value must be scalar, not array, composite, or json"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "array must have two columns"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "mismatched array dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "number of jsonb array elements exceeds the maximum allowed (%zu)"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "total size of jsonb array elements exceeds the maximum of %u bytes"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "cannot call %s on an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "cannot get array length of a scalar"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "cannot get array length of a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "cannot deconstruct an array as an object"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "cannot call %s on a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "expected json array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "See the array element %s of key \"%s\"."
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "See the array element %s."
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "malformed json array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "argument of %s must be an array of objects"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "regexp_split_to_array does not support the global option"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgstr "regexp_splitto_array    "
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "array of weight must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "array of weight is too short"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "array of weight must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "lexeme array may not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "weight array may not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "invalid array for XML namespace mapping"
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:"The array must be two-dimensional with length of the second axis equal to 2."
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:msgid "Enable input of NULL elements in arrays."
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:"When turned on, unquoted NULL in an array input value means a null value; "
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:"For RAID arrays, this should be approximately the number of drive spindles "
/srvr/z5089358/postgresql-10.4/src/backend/po/ko.po:"in the array."
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: storage/file/fd.c:2049 storage/ipc/procarray.c:1058
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: storage/ipc/procarray.c:1546 storage/ipc/procarray.c:1553
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: storage/ipc/procarray.c:1970 storage/ipc/procarray.c:2581
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:3803 utils/adt/arrayfuncs.c:6323
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "cannot set privileges of array types"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "could not form array type name for type \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "VARIADIC parameter must be an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "array data types are not binary-compatible"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "array element type cannot be %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "pg_type array OID value not set when in binary upgrade mode"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "cannot alter array type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "You can alter type %s, which will alter the array type as well."
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "target type is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: executor/execExprInterp.c:2226 utils/adt/arrayfuncs.c:260
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:558 utils/adt/arrayfuncs.c:1288
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:3361 utils/adt/arrayfuncs.c:5239
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:5756
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "cannot merge incompatible arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:"multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/array_userfuncs.c:724 utils/adt/array_userfuncs.c:863
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:3639 utils/adt/arrayfuncs.c:4077
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:6037 utils/adt/rowtypes.c:1167
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:1457 utils/adt/rowtypes.c:563
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "could not find array type for data type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "arguments declared \"anyarray\" are not all alike"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgstr ",   \"anyarray\",   "
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "argument declared %s is not an array but type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "type matched to anynonarray is an array type: %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:"   \"anynonarray\"    "
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "cannot determine type of empty array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "VARIADIC argument must be an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "cannot subscript type %s because it is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "array subscript must have type integer"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "array assignment requires type %s but expression is of type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "op ANY/ALL (array) requires array on right side"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "op ANY/ALL (array) requires operator to yield boolean"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "op ANY/ALL (array) requires operator not to return a set"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "cannot set an array element to DEFAULT"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:"array assignment to \"%s\" requires type %s but expression is of type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "array of serial is not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: postmaster/postmaster.c:2269 storage/ipc/procarray.c:292
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "options array must not be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "array must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "array must have even number of elements"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "invalid zero-length item array in MVDependencies"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "invalid zero-length item array in MVNDistinct"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "ACL array contains wrong data type"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "ACL arrays must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "ACL arrays must not contain null values"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/array_expanded.c:274 utils/adt/arrayfuncs.c:931
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:1519 utils/adt/arrayfuncs.c:3251
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:3389 utils/adt/arrayfuncs.c:5846
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:6157 utils/adt/arrayutils.c:93
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayutils.c:102 utils/adt/arrayutils.c:109
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "array size exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/array_userfuncs.c:79 utils/adt/array_userfuncs.c:471
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/array_userfuncs.c:551 utils/adt/json.c:1765 utils/adt/json.c:1860
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/array_userfuncs.c:84
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "input data type is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/array_userfuncs.c:132 utils/adt/array_userfuncs.c:186
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:1322 utils/adt/float.c:1228 utils/adt/float.c:1287
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/array_userfuncs.c:139 utils/adt/array_userfuncs.c:196
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "argument must be empty or one-dimensional array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/array_userfuncs.c:278 utils/adt/array_userfuncs.c:317
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/array_userfuncs.c:354 utils/adt/array_userfuncs.c:383
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/array_userfuncs.c:411
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "cannot concatenate incompatible arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/array_userfuncs.c:279
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/array_userfuncs.c:318
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/array_userfuncs.c:355
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/array_userfuncs.c:384 utils/adt/array_userfuncs.c:412
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/array_userfuncs.c:667 utils/adt/array_userfuncs.c:819
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "searching for elements in multidimensional arrays is not supported"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/array_userfuncs.c:691
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:268 utils/adt/arrayfuncs.c:282
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:293 utils/adt/arrayfuncs.c:315
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:330 utils/adt/arrayfuncs.c:344
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:350 utils/adt/arrayfuncs.c:357
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:488 utils/adt/arrayfuncs.c:504
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:515 utils/adt/arrayfuncs.c:530
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:551 utils/adt/arrayfuncs.c:581
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:588 utils/adt/arrayfuncs.c:596
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:630 utils/adt/arrayfuncs.c:653
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:673 utils/adt/arrayfuncs.c:785
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:794 utils/adt/arrayfuncs.c:824
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:839 utils/adt/arrayfuncs.c:892
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "malformed array literal: \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:269
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "\"[\" must introduce explicitly-specified array dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:283
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "Missing array dimension value."
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:294 utils/adt/arrayfuncs.c:331
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "Missing \"%s\" after array dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:303 utils/adt/arrayfuncs.c:2870
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:2902 utils/adt/arrayfuncs.c:2917
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:316
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:345
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:351 utils/adt/arrayfuncs.c:358
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "Specified array dimensions do not match array contents."
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:489 utils/adt/arrayfuncs.c:516
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:505 utils/adt/arrayfuncs.c:552
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:582 utils/adt/arrayfuncs.c:631
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:531 utils/adt/arrayfuncs.c:654
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "Unexpected array element."
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:589
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:597 utils/adt/jsonfuncs.c:2381
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "Multidimensional arrays must have sub-arrays with matching dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:674
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:1284 utils/adt/arrayfuncs.c:3357
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:5752
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:1295
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "invalid array flags"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:1303
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:1353 utils/adt/rangetypes.c:334
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:1493
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "improper binary format in array element %d"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:1574 utils/adt/rangetypes.c:339
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:2052
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "slices of fixed-length arrays not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:2230 utils/adt/arrayfuncs.c:2252
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:2301 utils/adt/arrayfuncs.c:2537
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:2848 utils/adt/arrayfuncs.c:5738
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:5764 utils/adt/arrayfuncs.c:5775
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "wrong number of array subscripts"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:2235 utils/adt/arrayfuncs.c:2343
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:2601 utils/adt/arrayfuncs.c:2907
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "array subscript out of range"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:2240
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "cannot assign null value to an element of a fixed-length array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:2795
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "updates on slices of fixed-length arrays not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:2826
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "array slice subscript must provide both boundaries"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:2827
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:"When assigning to a slice of an empty array value, slice boundaries must be "
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:2838 utils/adt/arrayfuncs.c:2933
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "source array too small"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:3513
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "null array element not allowed in this context"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:3615 utils/adt/arrayfuncs.c:3786
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:4060
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "cannot compare arrays of different element types"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:3962 utils/adt/rangetypes.c:1253
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:5152
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "data type %s is not an array type"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:5207
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "cannot accumulate null arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:5235
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "cannot accumulate empty arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:5264 utils/adt/arrayfuncs.c:5270
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "cannot accumulate arrays of different dimensionality"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:5636 utils/adt/arrayfuncs.c:5676
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "dimension array or low bound array cannot be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:5739 utils/adt/arrayfuncs.c:5765
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "Dimension array must be one dimensional."
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:5744 utils/adt/arrayfuncs.c:5770
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:5776
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "Low bound array has different size than dimensions array."
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:6022
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "removing elements from multidimensional arrays is not supported"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:6299
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "thresholds must be one-dimensional array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayfuncs.c:6304
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "thresholds array must not contain NULLs"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayutils.c:209
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "typmod array must be type cstring[]"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayutils.c:214
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "typmod array must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#: utils/adt/arrayutils.c:219
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "typmod array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "Expected array element or \"]\", but found \"%s\"."
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "key value must be scalar, not array, composite, or json"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "array must have two columns"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "mismatched array dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "number of jsonb array elements exceeds the maximum allowed (%zu)"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "total size of jsonb array elements exceeds the maximum of %u bytes"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "cannot call %s on an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "cannot get array length of a scalar"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "cannot get array length of a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "cannot deconstruct an array as an object"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "cannot call %s on a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "expected json array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "See the array element %s of key \"%s\"."
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "See the array element %s."
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "malformed json array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "argument of %s must be an array of objects"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "regexp_split_to_array does not support the global option"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgstr "regexp_split_to_array    "
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "array of weight must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "array of weight is too short"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "array of weight must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "lexeme array may not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "weight array may not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "invalid array for XML namespace mapping"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:"The array must be two-dimensional with length of the second axis equal to 2."
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:msgid "Enable input of NULL elements in arrays."
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:"When turned on, unquoted NULL in an array input value means a null value; "
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:"For RAID arrays, this should be approximately the number of drive spindles "
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:"in the array."
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#~ msgid "op ANY/ALL (array) does not support set arguments"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#~ msgid "cannot accept a value of type anyarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#~ msgstr "  anyarray  "
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#~ msgid "cannot accept a value of type anynonarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#~ msgstr "  anynonarray  "
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#~ msgid "cannot display a value of type anynonarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#~ msgstr "  anynonarray  "
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#~ msgid "wrong range of array subscripts"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#~ msgid "Lower bound of dimension array must be one."
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#~ msgid "key value must be scalar, not array, composite or json"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#~ msgid "neither input type is an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#~ msgid "cannot extract array element from a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#~ msgid "cannot call json_object_keys on an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#~ msgid "cannot call json_array_elements on a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#~ msgstr "json_array_elements     "
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#~ msgid "cannot call json_array_elements on a scalar"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#~ msgstr " json_array_elements   "
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#~ msgid "must call json_populate_recordset on an array of objects"
/srvr/z5089358/postgresql-10.4/src/backend/po/ru.po:#~ msgid "cannot call json_populate_recordset with nested arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: storage/file/fd.c:2044 storage/ipc/procarray.c:1057
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: storage/ipc/procarray.c:1545 storage/ipc/procarray.c:1552
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: storage/ipc/procarray.c:1969 storage/ipc/procarray.c:2580
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:3803 utils/adt/arrayfuncs.c:6323
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "cannot set privileges of array types"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "no se puede definir privilegios para tipos de array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "could not form array type name for type \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "no se pudo formar un nombre de tipo de array para el tipo %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "VARIADIC parameter must be an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el parmetro VARIADIC debe ser un array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "array data types are not binary-compatible"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "los tipos de datos de array no son binario-compatibles"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "array element type cannot be %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el tipo de elemento de array no puede ser %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "pg_type array OID value not set when in binary upgrade mode"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "cannot alter array type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "no se puede alterar el tipo de array %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "You can alter type %s, which will alter the array type as well."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "Puede alterar el tipo %s, lo cual alterar el tipo de array tambin."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "target type is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el tipo de destino no es un array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: executor/execExprInterp.c:2210 utils/adt/arrayfuncs.c:260
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:558 utils/adt/arrayfuncs.c:1288
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:3361 utils/adt/arrayfuncs.c:5239
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:5756
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el nmero de dimensiones del array (%d) excede el mximo permitido (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "cannot merge incompatible arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "no se puede mezclar arrays incompatibles"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "El array con tipo de elemento %s no puede ser incluido en una sentencia ARRAY con tipo de elemento %s."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "los arrays multidimensionales deben tener expresiones de arrays con dimensiones coincidentes"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "subndice de array en asignacin no puede ser nulo"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/array_userfuncs.c:724 utils/adt/array_userfuncs.c:863
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:3639 utils/adt/arrayfuncs.c:4077
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:6037 utils/adt/rowtypes.c:1167
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:1457 utils/adt/rowtypes.c:563
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "could not find array type for data type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "no se pudo encontrar un tipo de array para el tipo de dato %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "arguments declared \"anyarray\" are not all alike"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "los argumentos declarados anyarray no son de tipos compatibles"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "argument declared %s is not an array but type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el argumento declarado anyarray no es un array sino de tipo %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "type matched to anynonarray is an array type: %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el argumento coincidente con anynonarray es un array: %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "los arrays con elementos null no son permitidos en este contexto"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "cannot determine type of empty array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "no se puede determinar el tipo de un array vaco"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "VARIADIC argument must be an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el parmetro VARIADIC debe ser un array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "cannot subscript type %s because it is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "no se puede poner subndices al tipo %s porque no es un array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "array subscript must have type integer"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "los subndices de arrays deben tener tipo entero"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "array assignment requires type %s but expression is of type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "la asignacin de array debe tener tipo %s pero la expresin es de tipo %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "op ANY/ALL (array) requires array on right side"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "op ANY/ALL (array) requiere un array al lado derecho"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "op ANY/ALL (array) requires operator to yield boolean"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "op ANY/ALL (array) requiere un operador que entregue boolean"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "op ANY/ALL (array) requires operator not to return a set"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "op ANY/ALL (array) requiere un operador que no retorne un conjunto"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "cannot set an array element to DEFAULT"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "no se puede definir un elemento de array a DEFAULT"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "array assignment to \"%s\" requires type %s but expression is of type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "la asignacin de array a %s requiere tipo %s pero la expresin es de tipo %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "array of serial is not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "array de serial no est implementado"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: postmaster/postmaster.c:2249 storage/ipc/procarray.c:291
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "options array must not be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el array de opciones no debe ser null"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "array must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el array debe ser unidimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el array no debe contener nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "array must have even number of elements"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el array debe tener un nmero par de elementos"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "invalid zero-length item array in MVDependencies"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "invalid zero-length item array in MVNDistinct"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "ACL array contains wrong data type"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el array ACL contiene tipo de datos incorrecto"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "ACL arrays must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "los array de ACL debe ser unidimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "ACL arrays must not contain null values"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "los arrays de ACL no pueden contener valores nulos"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/array_expanded.c:274 utils/adt/arrayfuncs.c:931
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:1519 utils/adt/arrayfuncs.c:3251
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:3389 utils/adt/arrayfuncs.c:5846
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:6157 utils/adt/arrayutils.c:93
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayutils.c:102 utils/adt/arrayutils.c:109
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "array size exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el tamao del array excede el mximo permitido (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/array_userfuncs.c:79 utils/adt/array_userfuncs.c:471
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/array_userfuncs.c:551 utils/adt/json.c:1764 utils/adt/json.c:1859
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/array_userfuncs.c:84
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "input data type is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el tipo de entrada no es un array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/array_userfuncs.c:132 utils/adt/array_userfuncs.c:186
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:1322 utils/adt/float.c:1228 utils/adt/float.c:1287
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/array_userfuncs.c:139 utils/adt/array_userfuncs.c:196
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "argument must be empty or one-dimensional array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el argumento debe ser vaco o un array unidimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/array_userfuncs.c:278 utils/adt/array_userfuncs.c:317
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/array_userfuncs.c:354 utils/adt/array_userfuncs.c:383
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/array_userfuncs.c:411
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "cannot concatenate incompatible arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "no se pueden concatenar arrays incompatibles"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/array_userfuncs.c:279
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "Los arrays con elementos de tipo %s y %s son incompatibles para la concatenacin."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/array_userfuncs.c:318
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "Los arrays de dimesiones %d y %d son incompatibles para la concatenacin."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/array_userfuncs.c:355
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "Los arrays con elementos de diferentes dimensiones son incompatibles para la concatenacin."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/array_userfuncs.c:384 utils/adt/array_userfuncs.c:412
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "Los arrays con diferentes dimensiones son incompatibles para la concatenacin."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/array_userfuncs.c:667 utils/adt/array_userfuncs.c:819
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "searching for elements in multidimensional arrays is not supported"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "no est soportada la bsqueda de elementos en arrays multidimensionales"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/array_userfuncs.c:691
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:268 utils/adt/arrayfuncs.c:282
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:293 utils/adt/arrayfuncs.c:315
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:330 utils/adt/arrayfuncs.c:344
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:350 utils/adt/arrayfuncs.c:357
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:488 utils/adt/arrayfuncs.c:504
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:515 utils/adt/arrayfuncs.c:530
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:551 utils/adt/arrayfuncs.c:581
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:588 utils/adt/arrayfuncs.c:596
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:630 utils/adt/arrayfuncs.c:653
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:673 utils/adt/arrayfuncs.c:785
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:794 utils/adt/arrayfuncs.c:824
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:839 utils/adt/arrayfuncs.c:892
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "malformed array literal: \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "literal de array no es vlido: %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:269
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "\"[\" must introduce explicitly-specified array dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "Un [ debe introducir dimensiones de array especificadas explcitamente."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:283
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "Missing array dimension value."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "Falta un valor de dimensin de array."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:294 utils/adt/arrayfuncs.c:331
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "Missing \"%s\" after array dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "Falta %s luego de las dimensiones de array."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:303 utils/adt/arrayfuncs.c:2870
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:2902 utils/adt/arrayfuncs.c:2917
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:316
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "El valor de array debe comenzar con { o informacin de dimensin."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:345
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "El contenido del array debe empezar con {."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:351 utils/adt/arrayfuncs.c:358
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "Specified array dimensions do not match array contents."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "Las dimensiones del array especificadas no coinciden con el contenido del array."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:489 utils/adt/arrayfuncs.c:516
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:505 utils/adt/arrayfuncs.c:552
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:582 utils/adt/arrayfuncs.c:631
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:531 utils/adt/arrayfuncs.c:654
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "Unexpected array element."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "Elemento de array inesperado."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:589
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:597 utils/adt/jsonfuncs.c:2381
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "Multidimensional arrays must have sub-arrays with matching dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "Los arrays multidimensionales deben tener sub-arrays con dimensiones coincidentes."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:674
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:1284 utils/adt/arrayfuncs.c:3357
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:5752
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:1295
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "invalid array flags"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "opciones de array no vlidas"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:1303
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:1353 utils/adt/rangetypes.c:334
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:1493
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "improper binary format in array element %d"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el formato binario no es vlido en elemento %d de array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:1574 utils/adt/rangetypes.c:339
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:2052
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "slices of fixed-length arrays not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "no est implementada la obtencin de segmentos de arrays de largo fijo"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:2230 utils/adt/arrayfuncs.c:2252
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:2301 utils/adt/arrayfuncs.c:2537
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:2848 utils/adt/arrayfuncs.c:5738
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:5764 utils/adt/arrayfuncs.c:5775
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "wrong number of array subscripts"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "nmero incorrecto de subndices del array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:2235 utils/adt/arrayfuncs.c:2343
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:2601 utils/adt/arrayfuncs.c:2907
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "array subscript out of range"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "los subndices de arrays estn fuera de rango"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:2240
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "cannot assign null value to an element of a fixed-length array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "no se puede asignar un valor nulo a un elemento de un array de longitud fija"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:2795
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "updates on slices of fixed-length arrays not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "no estn implementadas las actualizaciones en segmentos de arrays de largo fija"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:2826
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "array slice subscript must provide both boundaries"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "los subndices del segmento de array deben especificar ambos bordes"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:2827
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "When assigning to a slice of an empty array value, slice boundaries must be fully specified."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "Cuando se asigna a un segmento de un array vaco, los bordes del segmento deben ser especificados completamente."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:2838 utils/adt/arrayfuncs.c:2933
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "source array too small"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el array de origen es demasiado pequeo"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:3513
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "null array element not allowed in this context"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "los arrays con elementos null no son permitidos en este contexto"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:3615 utils/adt/arrayfuncs.c:3786
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:4060
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "cannot compare arrays of different element types"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "no se pueden comparar arrays con elementos de distintos tipos"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:3962 utils/adt/rangetypes.c:1253
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:5152
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "data type %s is not an array type"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el tipo %s no es un array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:5207
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "cannot accumulate null arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "no se pueden acumular arrays nulos"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:5235
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "cannot accumulate empty arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "no se pueden acumular arrays vacos"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:5264 utils/adt/arrayfuncs.c:5270
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "cannot accumulate arrays of different dimensionality"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "no se pueden acumular arrays de distinta dimensionalidad"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:5636 utils/adt/arrayfuncs.c:5676
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "dimension array or low bound array cannot be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el array de dimensiones o el array de lmites inferiores debe ser no nulo"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:5739 utils/adt/arrayfuncs.c:5765
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "Dimension array must be one dimensional."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "El array de dimensiones debe ser unidimensional."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:5744 utils/adt/arrayfuncs.c:5770
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:5776
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "Low bound array has different size than dimensions array."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "El array de lmites inferiores tiene tamao diferente que el array de dimensiones."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:6022
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "removing elements from multidimensional arrays is not supported"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "la eliminacin de elementos desde arrays multidimensionales no est soportada"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:6299
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "thresholds must be one-dimensional array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "los umbrales deben ser un array unidimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayfuncs.c:6304
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "thresholds array must not contain NULLs"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el array de umbrales no debe contener nulos"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayutils.c:209
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "typmod array must be type cstring[]"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el array de typmod debe ser de tipo cstring[]"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayutils.c:214
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "typmod array must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "array de typmod debe ser unidimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#: utils/adt/arrayutils.c:219
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "typmod array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "los arrays de typmod no deben contener valores nulos"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "Expected array element or \"]\", but found \"%s\"."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "Se esperaba un elemento de array o ], se encontr %s."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "key value must be scalar, not array, composite, or json"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el valor de llave debe ser escalar, no array, composite o json"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "array must have two columns"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "un array debe tener dos columnas"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "mismatched array dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "las dimensiones de array no coinciden"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "number of jsonb array elements exceeds the maximum allowed (%zu)"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el nmero de elementos del array jsonb excede el mximo permitido (%zu)"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "total size of jsonb array elements exceeds the maximum of %u bytes"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el tamao total de los elementos del array jsonb excede el mximo de %u bytes"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "cannot call %s on an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "no se puede invocar %s en un array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "cannot get array length of a scalar"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "no se puede obtener el largo de array de un escalar"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "cannot get array length of a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "no se puede obtener el largo de array de un no-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "cannot deconstruct an array as an object"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "no se puede desconstruir un array como un objeto"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "cannot call %s on a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "no se puede invocar %s en un no-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "expected json array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "Elemento de array inesperado."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "see the array element %s of key \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el tipo de elemento de array no puede ser %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "see the array element %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "Elemento de array inesperado."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "malformed json array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "literal de array no es vlido: %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "argument of %s must be an array of objects"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el argumento de %s debe ser un array de objetos"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "regexp_split_to_array does not support the global option"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "array of weight must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el array de pesos debe ser unidimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "array of weight is too short"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el array de pesos es muy corto"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "array of weight must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "los arrays de pesos no deben contener valores nulos"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "lexeme array may not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el array de lexemas no debe contener nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "weight array may not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "el array de pesos no debe contener nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "invalid array for XML namespace mapping"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "array no vlido para mapeo de espacio de nombres XML"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "The array must be two-dimensional with length of the second axis equal to 2."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "El array debe ser bidimensional y el largo del segundo eje igual a 2."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "Enable input of NULL elements in arrays."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "Habilita el ingreso de elementos nulos en arrays."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "When turned on, unquoted NULL in an array input value means a null value; otherwise it is taken literally."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "Cuando est activo, un valor NULL sin comillas en la entrada de un array significa un valor nulo; en caso contrario es tomado literalmente."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgid "For RAID arrays, this should be approximately the number of drive spindles in the array."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:msgstr "Para arrays RAID, esto debera ser aproximadamente la cantidad de discos en el array."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#~ msgid "op ANY/ALL (array) does not support set arguments"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#~ msgstr "op ANY/ALL (array) no soporta argumentos que sean conjuntos"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#~ msgid "wrong range of array subscripts"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#~ msgstr "rango incorrecto en los subndices del array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#~ msgid "Lower bound of dimension array must be one."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#~ msgstr "El lmite inferior del array de dimensiones debe ser uno."
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#~ msgid "cannot accept a value of type anyarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#~ msgstr "no se puede aceptar un valor de tipo anyarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#~ msgid "cannot accept a value of type anynonarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#~ msgstr "no se puede aceptar un valor de tipo anynonarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#~ msgid "cannot display a value of type anynonarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#~ msgstr "no se puede desplegar un valor de tipo anynonarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#~ msgid "neither input type is an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/es.po:#~ msgstr "ninguno de los tipos de entrada es un array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: storage/file/fd.c:2049 storage/ipc/procarray.c:1058
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: storage/ipc/procarray.c:1546 storage/ipc/procarray.c:1553
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: storage/ipc/procarray.c:1970 storage/ipc/procarray.c:2581
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:3803 utils/adt/arrayfuncs.c:6323
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "cannot set privileges of array types"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "kan inte stta privilegier fr array-typer"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "could not form array type name for type \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "VARIADIC parameter must be an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "VARIADIC-parameter mste vara en array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "array data types are not binary-compatible"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "array-datatyper r inte binrkompatibla"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "array element type cannot be %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "elementtypen i array:en fr inte vara %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "pg_type array OID value not set when in binary upgrade mode"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "cannot alter array type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "kan inte ndra arraytyp %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "You can alter type %s, which will alter the array type as well."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "Du kan ndra typen %s vilket ocks kommer ndra array-typen."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "target type is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "mltypen r inte en array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: executor/execExprInterp.c:2226 utils/adt/arrayfuncs.c:260
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:558 utils/adt/arrayfuncs.c:1288
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:3361 utils/adt/arrayfuncs.c:5239
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:5756
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "antalet array-dimensioner (%d) verskrider det maximalt tilltna (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "cannot merge incompatible arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "kan inte gra merge p inkompatibla arrayer"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "flerdimensionella vektorer mste ha array-uttryck av passande dimensioner"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "array-index i tilldelning kan inte vara null"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/array_userfuncs.c:724 utils/adt/array_userfuncs.c:863
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:3639 utils/adt/arrayfuncs.c:4077
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:6037 utils/adt/rowtypes.c:1167
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:1457 utils/adt/rowtypes.c:563
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "could not find array type for data type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "kunde inte hitta array-typ fr datatyp %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "arguments declared \"anyarray\" are not all alike"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "argument deklarerade \"anyarray\" r inte alla likadana"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "argument declared %s is not an array but type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "argumentet deklarerad %s r inte en array utan typ %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "type matched to anynonarray is an array type: %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "cannot determine type of empty array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "kan inte bestmma typen av en tom array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "VARIADIC argument must be an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "VARIADIC-argument mste vara en array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "cannot subscript type %s because it is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "kan inte indexera typ %s d det inte r en array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "array subscript must have type integer"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "arrayindex mste ha typen integer"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "array assignment requires type %s but expression is of type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "array-tilldelning krver typ %s men uttrycket har typ %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "op ANY/ALL (array) requires array on right side"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "op ANY/ALL (array) krver en array p hger sida"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "op ANY/ALL (array) requires operator to yield boolean"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "op ANY/ALL (array) krver att operatorn returnerar en boolean"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "op ANY/ALL (array) requires operator not to return a set"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "op ANY/ALL (array) krver att operatorn inte returnerar en mngd"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "cannot set an array element to DEFAULT"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "kan inte stta ett array-element till DEFAULT"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "array assignment to \"%s\" requires type %s but expression is of type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "array-tilldelning till \"%s\" krver typ %s men uttrycket har typ %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "array of serial is not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "array med serial r inte implementerat"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: postmaster/postmaster.c:2269 storage/ipc/procarray.c:292
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#| msgid "array must not contain null values"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "options array must not be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "arrayen fr inte innehlla null-vrden"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "array must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "array:en mste vara endimensionell"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "array:en fr inte innehlla null"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "array must have even number of elements"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "array:en mste ha ett jmnt antal element"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "invalid zero-length item array in MVDependencies"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "invalid zero-length item array in MVNDistinct"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "ACL array contains wrong data type"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "ACL-array innehller fel datatyp"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "ACL arrays must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "ACL-array:er mste vara endimensionella"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "ACL arrays must not contain null values"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "ACL-array:er fr inte innehlla null-vrden"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/array_expanded.c:274 utils/adt/arrayfuncs.c:931
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:1519 utils/adt/arrayfuncs.c:3251
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:3389 utils/adt/arrayfuncs.c:5846
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:6157 utils/adt/arrayutils.c:93
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayutils.c:102 utils/adt/arrayutils.c:109
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "array size exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "array-storlek verskrider maximalt tilltna (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/array_userfuncs.c:79 utils/adt/array_userfuncs.c:471
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/array_userfuncs.c:551 utils/adt/json.c:1765 utils/adt/json.c:1860
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/array_userfuncs.c:84
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "input data type is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "indatatyp r inte en array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/array_userfuncs.c:132 utils/adt/array_userfuncs.c:186
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:1322 utils/adt/float.c:1228 utils/adt/float.c:1287
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/array_userfuncs.c:139 utils/adt/array_userfuncs.c:196
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "argument must be empty or one-dimensional array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "argumentet mste vara tomt eller en endimensionell array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/array_userfuncs.c:278 utils/adt/array_userfuncs.c:317
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/array_userfuncs.c:354 utils/adt/array_userfuncs.c:383
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/array_userfuncs.c:411
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "cannot concatenate incompatible arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "kan inte konkatenera inkompatibla arrayer"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/array_userfuncs.c:279
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/array_userfuncs.c:318
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/array_userfuncs.c:355
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/array_userfuncs.c:384 utils/adt/array_userfuncs.c:412
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/array_userfuncs.c:667 utils/adt/array_userfuncs.c:819
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "searching for elements in multidimensional arrays is not supported"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/array_userfuncs.c:691
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:268 utils/adt/arrayfuncs.c:282
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:293 utils/adt/arrayfuncs.c:315
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:330 utils/adt/arrayfuncs.c:344
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:350 utils/adt/arrayfuncs.c:357
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:488 utils/adt/arrayfuncs.c:504
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:515 utils/adt/arrayfuncs.c:530
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:551 utils/adt/arrayfuncs.c:581
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:588 utils/adt/arrayfuncs.c:596
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:630 utils/adt/arrayfuncs.c:653
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:673 utils/adt/arrayfuncs.c:785
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:794 utils/adt/arrayfuncs.c:824
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:839 utils/adt/arrayfuncs.c:892
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "malformed array literal: \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "felaktig array-literal: \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:269
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "\"[\" must introduce explicitly-specified array dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:283
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#| msgid "missing \"]\" in array dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "Missing array dimension value."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "saknar \"]\" i array-dimension"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:294 utils/adt/arrayfuncs.c:331
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#| msgid "missing \"]\" in array dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "Missing \"%s\" after array dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "saknar \"]\" i array-dimension"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:303 utils/adt/arrayfuncs.c:2870
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:2902 utils/adt/arrayfuncs.c:2917
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:316
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:345
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:351 utils/adt/arrayfuncs.c:358
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "Specified array dimensions do not match array contents."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "Angivna array-dimensioner matchar inte array-innehllet."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:489 utils/adt/arrayfuncs.c:516
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:505 utils/adt/arrayfuncs.c:552
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:582 utils/adt/arrayfuncs.c:631
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:531 utils/adt/arrayfuncs.c:654
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "Unexpected array element."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "Ovntat array-element."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:589
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:597 utils/adt/jsonfuncs.c:2381
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "Multidimensional arrays must have sub-arrays with matching dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "Flerdimensionella array:er mste ha underarray:er med matchande dimensioner."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:674
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:1284 utils/adt/arrayfuncs.c:3357
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:5752
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:1295
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "invalid array flags"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "ogiltiga array-flaggor"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:1303
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:1353 utils/adt/rangetypes.c:334
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:1493
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "improper binary format in array element %d"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:1574 utils/adt/rangetypes.c:339
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:2052
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "slices of fixed-length arrays not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:2230 utils/adt/arrayfuncs.c:2252
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:2301 utils/adt/arrayfuncs.c:2537
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:2848 utils/adt/arrayfuncs.c:5738
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:5764 utils/adt/arrayfuncs.c:5775
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "wrong number of array subscripts"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "fel antal array-indexeringar"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:2235 utils/adt/arrayfuncs.c:2343
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:2601 utils/adt/arrayfuncs.c:2907
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "array subscript out of range"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "array-index utanfr giltigt omrde"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:2240
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "cannot assign null value to an element of a fixed-length array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "kan inte tilldela null-vrde till ett element i en array med fast lngd"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:2795
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "updates on slices of fixed-length arrays not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:2826
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "array slice subscript must provide both boundaries"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:2827
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "When assigning to a slice of an empty array value, slice boundaries must be fully specified."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:2838 utils/adt/arrayfuncs.c:2933
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "source array too small"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:3513
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "null array element not allowed in this context"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "null-element i arrayer stds inte i detta kontext"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:3615 utils/adt/arrayfuncs.c:3786
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:4060
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "cannot compare arrays of different element types"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:3962 utils/adt/rangetypes.c:1253
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:5152
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "data type %s is not an array type"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "datatypen %s r inte en arraytyp"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:5207
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "cannot accumulate null arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "kan inte ackumulera null-array:er"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:5235
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "cannot accumulate empty arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "kan inte ackumulera tomma array:er"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:5264 utils/adt/arrayfuncs.c:5270
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "cannot accumulate arrays of different dimensionality"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:5636 utils/adt/arrayfuncs.c:5676
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "dimension array or low bound array cannot be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:5739 utils/adt/arrayfuncs.c:5765
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "Dimension array must be one dimensional."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "Dimensionsarray mste vara endimensionell."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:5744 utils/adt/arrayfuncs.c:5770
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:5776
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "Low bound array has different size than dimensions array."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:6022
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "removing elements from multidimensional arrays is not supported"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "borttagning av element frn en multidimensionell array stds inte"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:6299
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "thresholds must be one-dimensional array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "grnsvrden mste vara en endimensionell array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayfuncs.c:6304
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "thresholds array must not contain NULLs"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "grnsvrdesarray fr inte innehlla NULLL-vrden"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayutils.c:209
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "typmod array must be type cstring[]"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "typmod-array mste ha typ cstring[]"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayutils.c:214
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "typmod array must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "typmod-array mste vara endimensionell"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#: utils/adt/arrayutils.c:219
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "typmod array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "typmod-arrayen fr inte innehlla null-vrden"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "Expected array element or \"]\", but found \"%s\"."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "Frvntade array-element eller \"]\", men hittade \"%s\"."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "key value must be scalar, not array, composite, or json"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "nyckelvrde mste vara skalr, inte array, composite eller json"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "array must have two columns"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "array:en mste ha tv kolumner"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "mismatched array dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "array-dimensionerna stmmer inte"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#| msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "antalet array-dimensioner (%d) verskrider det maximalt tilltna (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#| msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "number of jsonb array elements exceeds the maximum allowed (%zu)"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "antalet array-dimensioner (%d) verskrider det maximalt tilltna (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#| msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "total size of jsonb array elements exceeds the maximum of %u bytes"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "antalet array-dimensioner (%d) verskrider det maximalt tilltna (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "cannot call %s on an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "kan inte anropa %s p en array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "cannot get array length of a scalar"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#| msgid "cannot convert Perl array to non-array type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "cannot get array length of a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "kan inte omvandla perlvektor till icke-array av typ \"%s\"."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "cannot deconstruct an array as an object"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "cannot call %s on a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "kan inte anropa %s p icke-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "expected json array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "frvntade json-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#| msgid "array element type cannot be %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "elementtypen i arrayen fr inte vara %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#| msgid "array element type cannot be %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "See the array element %s of key \"%s\"."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "elementtypen i arrayen fr inte vara %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "See the array element %s."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "Se arrayelementet %s."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "malformed json array"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "argument of %s must be an array of objects"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "argumentet till %s mste vara en array med objekt"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#| msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "array-index i tilldelning kan inte vara null"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#| msgid "invalid array flags"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "ogiltiga array-flaggor"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "regexp_split_to_array does not support the global option"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "array of weight must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "array of weight is too short"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#| msgid "array must not contain null values"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "array of weight must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "arrayen fr inte innehlla null-vrden"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "lexeme array may not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "lexem-array:en fr inte innehlla null-vrden"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "weight array may not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "vikt-array:en fr inte innehlla null-vrden"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "invalid array for XML namespace mapping"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "The array must be two-dimensional with length of the second axis equal to 2."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "Enable input of NULL elements in arrays."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgstr "Aktiverar inmatning av NULL-element i arrayer."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "When turned on, unquoted NULL in an array input value means a null value; otherwise it is taken literally."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:msgid "For RAID arrays, this should be approximately the number of drive spindles in the array."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#~ msgid "A function returning \"anyarray\" or \"anyelement\" must have at least one argument of either type."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#~ msgstr "En funktion som returnerar \"anyarray\" eller \"anyelement\" mste ha minst ett argument med sdan typ."
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#~ msgid "op ANY/ALL (array) does not support set arguments"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#~ msgstr "operatorerna ANY/ALL (array) stdjer inte mngd-argument"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#~ msgid "array subscript in assignment must not be NULL"
/srvr/z5089358/postgresql-10.4/src/backend/po/sv.po:#~ msgstr "array-index i tilldelning kan inte vara NULL"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: storage/file/fd.c:2044 storage/ipc/procarray.c:1057
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: storage/ipc/procarray.c:1545 storage/ipc/procarray.c:1552
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: storage/ipc/procarray.c:1966 storage/ipc/procarray.c:2569
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:3803 utils/adt/arrayfuncs.c:6325
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "cannot set privileges of array types"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "could not form array type name for type \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "VARIADIC parameter must be an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "array data types are not binary-compatible"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "array element type cannot be %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "pg_type array OID value not set when in binary upgrade mode"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "cannot alter array type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "You can alter type %s, which will alter the array type as well."
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "target type is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: executor/execExprInterp.c:2210 utils/adt/array_userfuncs.c:484
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:260 utils/adt/arrayfuncs.c:558
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:1288 utils/adt/arrayfuncs.c:3361
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:5241 utils/adt/arrayfuncs.c:5758
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "cannot merge incompatible arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:1457 utils/adt/rowtypes.c:563
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "could not find array type for data type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "arguments declared \"anyarray\" are not all alike"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgstr "argumenty zadeklarowane jako \"anyarray\" nie wszystkie s do siebie podobne"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#| msgid "argument declared \"anyarray\" is not an array but type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "argument declared %s is not an array but type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:"argument zadeklarowany jako \"anyarray\" nie jest tablic ale jest typu %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#| msgid "argument declared \"anyarray\" is not consistent with argument declared \"anyelement\""
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:"argument zadeklarowany jako \"anyarray\" nie jest zgodny z argumentem "
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "type matched to anynonarray is an array type: %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgstr "typ dopasowany do anynonarray jest typem tablicowym: %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#| msgid "null array element not allowed in this context"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "cannot determine type of empty array"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "VARIADIC argument must be an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "cannot subscript type %s because it is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "array subscript must have type integer"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "array assignment requires type %s but expression is of type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: parser/parse_oper.c:228 utils/adt/array_userfuncs.c:794
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/array_userfuncs.c:933 utils/adt/arrayfuncs.c:3639
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:4077 utils/adt/arrayfuncs.c:6039
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "op ANY/ALL (array) requires array on right side"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "op ANY/ALL (array) requires operator to yield boolean"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "op ANY/ALL (array) requires operator not to return a set"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "cannot set an array element to DEFAULT"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "array assignment to \"%s\" requires type %s but expression is of type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "array of serial is not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: postmaster/postmaster.c:2221 storage/ipc/procarray.c:291
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "options array must not be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "array must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "array must have even number of elements"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "invalid zero-length item array in MVDependencies"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "invalid zero-length item array in MVNDistinct"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "ACL array contains wrong data type"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "ACL arrays must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "ACL arrays must not contain null values"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/array_expanded.c:274 utils/adt/arrayfuncs.c:931
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:1519 utils/adt/arrayfuncs.c:3251
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:3389 utils/adt/arrayfuncs.c:5848
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:6159 utils/adt/arrayutils.c:93
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayutils.c:102 utils/adt/arrayutils.c:109
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "array size exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/array_userfuncs.c:79 utils/adt/array_userfuncs.c:541
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/array_userfuncs.c:621 utils/adt/json.c:1764 utils/adt/json.c:1859
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/array_userfuncs.c:84
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "input data type is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/array_userfuncs.c:132 utils/adt/array_userfuncs.c:186
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:1322 utils/adt/float.c:1228 utils/adt/float.c:1287
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/array_userfuncs.c:139 utils/adt/array_userfuncs.c:196
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "argument must be empty or one-dimensional array"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/array_userfuncs.c:278 utils/adt/array_userfuncs.c:317
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/array_userfuncs.c:354 utils/adt/array_userfuncs.c:383
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/array_userfuncs.c:411
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "cannot concatenate incompatible arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/array_userfuncs.c:279
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/array_userfuncs.c:318
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/array_userfuncs.c:355
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/array_userfuncs.c:384 utils/adt/array_userfuncs.c:412
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/array_userfuncs.c:480 utils/adt/arrayfuncs.c:1284
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:3357 utils/adt/arrayfuncs.c:5754
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/array_userfuncs.c:737 utils/adt/array_userfuncs.c:889
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "searching for elements in multidimensional arrays is not supported"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/array_userfuncs.c:761
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:268 utils/adt/arrayfuncs.c:282
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:293 utils/adt/arrayfuncs.c:315
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:330 utils/adt/arrayfuncs.c:344
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:350 utils/adt/arrayfuncs.c:357
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:488 utils/adt/arrayfuncs.c:504
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:515 utils/adt/arrayfuncs.c:530
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:551 utils/adt/arrayfuncs.c:581
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:588 utils/adt/arrayfuncs.c:596
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:630 utils/adt/arrayfuncs.c:653
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:673 utils/adt/arrayfuncs.c:785
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:794 utils/adt/arrayfuncs.c:824
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:839 utils/adt/arrayfuncs.c:892
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "malformed array literal: \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:269
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "\"[\" must introduce explicitly-specified array dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:283
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "Missing array dimension value."
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:294 utils/adt/arrayfuncs.c:331
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "Missing \"%s\" after array dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:303 utils/adt/arrayfuncs.c:2870
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:2902 utils/adt/arrayfuncs.c:2917
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:316
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:345
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:351 utils/adt/arrayfuncs.c:358
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "Specified array dimensions do not match array contents."
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:489 utils/adt/arrayfuncs.c:516
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:505 utils/adt/arrayfuncs.c:552
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:582 utils/adt/arrayfuncs.c:631
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:531 utils/adt/arrayfuncs.c:654
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "Unexpected array element."
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:589
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:597 utils/adt/jsonfuncs.c:2378
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "Multidimensional arrays must have sub-arrays with matching dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:674
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:1295
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "invalid array flags"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:1303
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:1353 utils/adt/rangetypes.c:334
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:1493
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "improper binary format in array element %d"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:1574 utils/adt/rangetypes.c:339
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:2052
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "slices of fixed-length arrays not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:2230 utils/adt/arrayfuncs.c:2252
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:2301 utils/adt/arrayfuncs.c:2537
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:2848 utils/adt/arrayfuncs.c:5740
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:5766 utils/adt/arrayfuncs.c:5777
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "wrong number of array subscripts"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:2235 utils/adt/arrayfuncs.c:2343
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:2601 utils/adt/arrayfuncs.c:2907
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "array subscript out of range"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:2240
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "cannot assign null value to an element of a fixed-length array"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:2795
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "updates on slices of fixed-length arrays not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:2826
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "array slice subscript must provide both boundaries"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:2827
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "When assigning to a slice of an empty array value, slice boundaries must be fully specified."
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:2838 utils/adt/arrayfuncs.c:2933
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "source array too small"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:3513
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "null array element not allowed in this context"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:3615 utils/adt/arrayfuncs.c:3786
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:4060
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "cannot compare arrays of different element types"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:3962 utils/adt/rangetypes.c:1253
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:5154
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "data type %s is not an array type"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:5209
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "cannot accumulate null arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:5237
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "cannot accumulate empty arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:5266 utils/adt/arrayfuncs.c:5272
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "cannot accumulate arrays of different dimensionality"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:5638 utils/adt/arrayfuncs.c:5678
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "dimension array or low bound array cannot be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:5741 utils/adt/arrayfuncs.c:5767
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "Dimension array must be one dimensional."
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:5746 utils/adt/arrayfuncs.c:5772
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:5778
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "Low bound array has different size than dimensions array."
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:6024
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "removing elements from multidimensional arrays is not supported"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:6301
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "thresholds must be one-dimensional array"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayfuncs.c:6306
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "thresholds array must not contain NULLs"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayutils.c:209
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "typmod array must be type cstring[]"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayutils.c:214
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "typmod array must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#: utils/adt/arrayutils.c:219
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "typmod array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "Expected array element or \"]\", but found \"%s\"."
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "key value must be scalar, not array, composite, or json"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "array must have two columns"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "mismatched array dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "number of jsonb array elements exceeds the maximum allowed (%zu)"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "total size of jsonb array elements exceeds the maximum of %u bytes"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "cannot call %s on an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "cannot get array length of a scalar"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "cannot get array length of a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "cannot deconstruct an array as an object"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "cannot call %s on a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#| msgid "Unexpected array element."
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "expected json array"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#| msgid "array element type cannot be %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "see the array element %s of key \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#| msgid "Unexpected array element."
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "see the array element %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#| msgid "malformed array literal: \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "malformed json array"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "argument of %s must be an array of objects"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "regexp_split_to_array does not support the global option"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgstr "regexp_split_to_array nie obsuguje opcji globalnej"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "array of weight must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "array of weight is too short"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "array of weight must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "lexeme array may not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "weight array may not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "invalid array for XML namespace mapping"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "The array must be two-dimensional with length of the second axis equal to 2."
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "Enable input of NULL elements in arrays."
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "When turned on, unquoted NULL in an array input value means a null value; otherwise it is taken literally."
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:msgid "For RAID arrays, this should be approximately the number of drive spindles in the array."
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#~ msgid "cannot display a value of type anynonarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#~ msgstr "nie mona wywietli wartoci typu anynonarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#~ msgid "cannot accept a value of type anynonarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#~ msgstr "nie mona przyj wartoci typu anynonarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#~ msgid "cannot accept a value of type anyarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#~ msgstr "nie mona przyj wartoci typu anyarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#~ msgid "Lower bound of dimension array must be one."
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#~ msgid "wrong range of array subscripts"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#~ msgid "op ANY/ALL (array) does not support set arguments"
/srvr/z5089358/postgresql-10.4/src/backend/po/pl.po:#~ msgstr "op ANY/ALL (array) nie obsuguje argumentw grupowych"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: storage/file/fd.c:2049 storage/ipc/procarray.c:1058
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: storage/ipc/procarray.c:1546 storage/ipc/procarray.c:1553
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: storage/ipc/procarray.c:1970 storage/ipc/procarray.c:2581
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:3803 utils/adt/arrayfuncs.c:6323
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "cannot set privileges of array types"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "could not form array type name for type \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "VARIADIC parameter must be an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "array data types are not binary-compatible"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "array element type cannot be %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "pg_type array OID value not set when in binary upgrade mode"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "cannot alter array type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "You can alter type %s, which will alter the array type as well."
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "target type is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: executor/execExprInterp.c:2226 utils/adt/arrayfuncs.c:260
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:558 utils/adt/arrayfuncs.c:1288
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:3361 utils/adt/arrayfuncs.c:5239
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:5756
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "cannot merge incompatible arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/array_userfuncs.c:724 utils/adt/array_userfuncs.c:863
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:3639 utils/adt/arrayfuncs.c:4077
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:6037 utils/adt/rowtypes.c:1167
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:1457 utils/adt/rowtypes.c:563
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "could not find array type for data type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "arguments declared \"anyarray\" are not all alike"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgstr "als anyarray deklarierte Argumente sind nicht alle gleich"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "argument declared %s is not an array but type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "type matched to anynonarray is an array type: %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgstr "mit anynonarray gepaarter Typ ist ein Array-Typ: %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "cannot determine type of empty array"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "VARIADIC argument must be an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "cannot subscript type %s because it is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "array subscript must have type integer"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "array assignment requires type %s but expression is of type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "op ANY/ALL (array) requires array on right side"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgstr "op ANY/ALL (array) erfordert Array auf der rechten Seite"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "op ANY/ALL (array) requires operator to yield boolean"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgstr "op ANY/ALL (array) erfordert, dass Operator boolean ergibt"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "op ANY/ALL (array) requires operator not to return a set"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgstr "op ANY/ALL (array) erfordert, dass Operator keine Ergebnismenge zurckgibt"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "cannot set an array element to DEFAULT"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "array assignment to \"%s\" requires type %s but expression is of type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "array of serial is not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: postmaster/postmaster.c:2269 storage/ipc/procarray.c:292
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "options array must not be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "array must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "array must have even number of elements"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "invalid zero-length item array in MVDependencies"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "invalid zero-length item array in MVNDistinct"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "ACL array contains wrong data type"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "ACL arrays must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "ACL arrays must not contain null values"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/array_expanded.c:274 utils/adt/arrayfuncs.c:931
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:1519 utils/adt/arrayfuncs.c:3251
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:3389 utils/adt/arrayfuncs.c:5846
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:6157 utils/adt/arrayutils.c:93
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayutils.c:102 utils/adt/arrayutils.c:109
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "array size exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/array_userfuncs.c:79 utils/adt/array_userfuncs.c:471
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/array_userfuncs.c:551 utils/adt/json.c:1765 utils/adt/json.c:1860
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/array_userfuncs.c:84
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "input data type is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/array_userfuncs.c:132 utils/adt/array_userfuncs.c:186
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:1322 utils/adt/float.c:1228 utils/adt/float.c:1287
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/array_userfuncs.c:139 utils/adt/array_userfuncs.c:196
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "argument must be empty or one-dimensional array"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/array_userfuncs.c:278 utils/adt/array_userfuncs.c:317
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/array_userfuncs.c:354 utils/adt/array_userfuncs.c:383
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/array_userfuncs.c:411
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "cannot concatenate incompatible arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/array_userfuncs.c:279
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/array_userfuncs.c:318
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/array_userfuncs.c:355
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/array_userfuncs.c:384 utils/adt/array_userfuncs.c:412
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/array_userfuncs.c:667 utils/adt/array_userfuncs.c:819
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "searching for elements in multidimensional arrays is not supported"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/array_userfuncs.c:691
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:268 utils/adt/arrayfuncs.c:282
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:293 utils/adt/arrayfuncs.c:315
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:330 utils/adt/arrayfuncs.c:344
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:350 utils/adt/arrayfuncs.c:357
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:488 utils/adt/arrayfuncs.c:504
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:515 utils/adt/arrayfuncs.c:530
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:551 utils/adt/arrayfuncs.c:581
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:588 utils/adt/arrayfuncs.c:596
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:630 utils/adt/arrayfuncs.c:653
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:673 utils/adt/arrayfuncs.c:785
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:794 utils/adt/arrayfuncs.c:824
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:839 utils/adt/arrayfuncs.c:892
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "malformed array literal: \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:269
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "\"[\" must introduce explicitly-specified array dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:283
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "Missing array dimension value."
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:294 utils/adt/arrayfuncs.c:331
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "Missing \"%s\" after array dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:303 utils/adt/arrayfuncs.c:2870
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:2902 utils/adt/arrayfuncs.c:2917
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:316
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:345
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:351 utils/adt/arrayfuncs.c:358
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "Specified array dimensions do not match array contents."
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:489 utils/adt/arrayfuncs.c:516
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:505 utils/adt/arrayfuncs.c:552
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:582 utils/adt/arrayfuncs.c:631
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:531 utils/adt/arrayfuncs.c:654
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "Unexpected array element."
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:589
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:597 utils/adt/jsonfuncs.c:2381
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "Multidimensional arrays must have sub-arrays with matching dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:674
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:1284 utils/adt/arrayfuncs.c:3357
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:5752
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:1295
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "invalid array flags"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:1303
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:1353 utils/adt/rangetypes.c:334
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:1493
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "improper binary format in array element %d"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:1574 utils/adt/rangetypes.c:339
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:2052
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "slices of fixed-length arrays not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:2230 utils/adt/arrayfuncs.c:2252
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:2301 utils/adt/arrayfuncs.c:2537
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:2848 utils/adt/arrayfuncs.c:5738
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:5764 utils/adt/arrayfuncs.c:5775
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "wrong number of array subscripts"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:2235 utils/adt/arrayfuncs.c:2343
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:2601 utils/adt/arrayfuncs.c:2907
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "array subscript out of range"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:2240
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "cannot assign null value to an element of a fixed-length array"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:2795
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "updates on slices of fixed-length arrays not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:2826
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "array slice subscript must provide both boundaries"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:2827
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "When assigning to a slice of an empty array value, slice boundaries must be fully specified."
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:2838 utils/adt/arrayfuncs.c:2933
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "source array too small"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgstr "Quellarray ist zu klein"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:3513
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "null array element not allowed in this context"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:3615 utils/adt/arrayfuncs.c:3786
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:4060
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "cannot compare arrays of different element types"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:3962 utils/adt/rangetypes.c:1253
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:5152
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "data type %s is not an array type"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:5207
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "cannot accumulate null arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:5235
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "cannot accumulate empty arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:5264 utils/adt/arrayfuncs.c:5270
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "cannot accumulate arrays of different dimensionality"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:5636 utils/adt/arrayfuncs.c:5676
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "dimension array or low bound array cannot be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:5739 utils/adt/arrayfuncs.c:5765
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "Dimension array must be one dimensional."
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:5744 utils/adt/arrayfuncs.c:5770
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:5776
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "Low bound array has different size than dimensions array."
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:6022
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "removing elements from multidimensional arrays is not supported"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:6299
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "thresholds must be one-dimensional array"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayfuncs.c:6304
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "thresholds array must not contain NULLs"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayutils.c:209
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "typmod array must be type cstring[]"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayutils.c:214
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "typmod array must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:#: utils/adt/arrayutils.c:219
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "typmod array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "Expected array element or \"]\", but found \"%s\"."
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "key value must be scalar, not array, composite, or json"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "array must have two columns"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "mismatched array dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "number of jsonb array elements exceeds the maximum allowed (%zu)"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "total size of jsonb array elements exceeds the maximum of %u bytes"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "cannot call %s on an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "cannot get array length of a scalar"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "cannot get array length of a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "cannot deconstruct an array as an object"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "cannot call %s on a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "expected json array"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "See the array element %s of key \"%s\"."
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "See the array element %s."
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "malformed json array"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "argument of %s must be an array of objects"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "regexp_split_to_array does not support the global option"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgstr "regexp_split_to_array untersttzt die Global-Option nicht"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "array of weight must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "array of weight is too short"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "array of weight must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "lexeme array may not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "weight array may not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "invalid array for XML namespace mapping"
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "The array must be two-dimensional with length of the second axis equal to 2."
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "Enable input of NULL elements in arrays."
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "When turned on, unquoted NULL in an array input value means a null value; otherwise it is taken literally."
/srvr/z5089358/postgresql-10.4/src/backend/po/de.po:msgid "For RAID arrays, this should be approximately the number of drive spindles in the array."
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: storage/file/fd.c:1244 storage/file/fd.c:1916 storage/ipc/procarray.c:1060
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: storage/ipc/procarray.c:1546 storage/ipc/procarray.c:1553
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: storage/ipc/procarray.c:1967 storage/ipc/procarray.c:2570
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "cannot set privileges of array types"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "could not form array type name for type \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "VARIADIC parameter must be an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "array data types are not binary-compatible"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "array element type cannot be %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "pg_type array OID value not set when in binary upgrade mode"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "cannot alter array type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "You can alter type %s, which will alter the array type as well."
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/array_userfuncs.c:472 utils/adt/arrayfuncs.c:260
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:558 utils/adt/arrayfuncs.c:1288
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:3361 utils/adt/arrayfuncs.c:5245
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:5768
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "op ANY/ALL (array) does not support set arguments"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "cannot merge incompatible arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:"multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "target type is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: executor/execQual.c:5052 utils/adt/arrayfuncs.c:3803
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:6341 utils/adt/rowtypes.c:927
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:1457 utils/adt/rowtypes.c:563
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "could not find array type for data type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "arguments declared \"anyarray\" are not all alike"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgstr " \"anyarray\" "
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgstr " \"anyarray\" "
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "argument declared \"anyarray\" is not an array but type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgstr " \"anyarray\" ,  %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:"argument declared \"anyarray\" is not consistent with argument declared "
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgstr " \"anyarray\"  \"anyelement\" "
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgstr " \"anyarray\" ,  %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgstr " \"anyarray\"  \"anyelement\" "
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "type matched to anynonarray is an array type: %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgstr "anynonarray:%s"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "cannot determine type of empty array"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "VARIADIC argument must be an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "cannot subscript type %s because it is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "array subscript must have type integer"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "array assignment requires type %s but expression is of type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: parser/parse_oper.c:226 utils/adt/array_userfuncs.c:782
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/array_userfuncs.c:920 utils/adt/arrayfuncs.c:3639
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:4077 utils/adt/arrayfuncs.c:6055
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "op ANY/ALL (array) requires array on right side"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgstr "ANY/ALL (array)"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "op ANY/ALL (array) requires operator to yield boolean"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgstr "ANY/ALL (array)."
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "op ANY/ALL (array) requires operator not to return a set"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgstr "ANY/ALL (array)"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "cannot set an array element to DEFAULT"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:"array assignment to \"%s\" requires type %s but expression is of type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "array of serial is not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: postmaster/postmaster.c:2181 storage/ipc/procarray.c:297
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#| msgid "typmod array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "options array must not be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "array must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "array must have even number of elements"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "ACL array contains wrong data type"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "ACL arrays must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "ACL arrays must not contain null values"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/array_expanded.c:276 utils/adt/arrayfuncs.c:931
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:1519 utils/adt/arrayfuncs.c:3251
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:3389 utils/adt/arrayfuncs.c:5864
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:6175 utils/adt/arrayutils.c:93
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayutils.c:102 utils/adt/arrayutils.c:109
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "array size exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/array_userfuncs.c:67 utils/adt/array_userfuncs.c:529
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/array_userfuncs.c:609 utils/adt/json.c:1759 utils/adt/json.c:1854
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/array_userfuncs.c:72
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "input data type is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/array_userfuncs.c:120 utils/adt/array_userfuncs.c:174
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:1322 utils/adt/float.c:1221 utils/adt/float.c:1280
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/array_userfuncs.c:127 utils/adt/array_userfuncs.c:184
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "argument must be empty or one-dimensional array"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/array_userfuncs.c:266 utils/adt/array_userfuncs.c:305
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/array_userfuncs.c:342 utils/adt/array_userfuncs.c:371
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/array_userfuncs.c:399
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "cannot concatenate incompatible arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/array_userfuncs.c:267
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/array_userfuncs.c:306
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/array_userfuncs.c:343
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/array_userfuncs.c:372 utils/adt/array_userfuncs.c:400
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/array_userfuncs.c:468 utils/adt/arrayfuncs.c:1284
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:3357 utils/adt/arrayfuncs.c:5764
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/array_userfuncs.c:725 utils/adt/array_userfuncs.c:876
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "searching for elements in multidimensional arrays is not supported"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/array_userfuncs.c:749
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:268 utils/adt/arrayfuncs.c:282
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:293 utils/adt/arrayfuncs.c:315
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:330 utils/adt/arrayfuncs.c:344
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:350 utils/adt/arrayfuncs.c:357
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:488 utils/adt/arrayfuncs.c:504
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:515 utils/adt/arrayfuncs.c:530
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:551 utils/adt/arrayfuncs.c:581
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:588 utils/adt/arrayfuncs.c:596
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:630 utils/adt/arrayfuncs.c:653
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:673 utils/adt/arrayfuncs.c:785
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:794 utils/adt/arrayfuncs.c:824
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:839 utils/adt/arrayfuncs.c:892
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "malformed array literal: \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:269
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "\"[\" must introduce explicitly-specified array dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:283
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "Missing array dimension value."
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:294 utils/adt/arrayfuncs.c:331
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "Missing \"%s\" after array dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:303 utils/adt/arrayfuncs.c:2870
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:2902 utils/adt/arrayfuncs.c:2917
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:316
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:345
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:351 utils/adt/arrayfuncs.c:358
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "Specified array dimensions do not match array contents."
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:489 utils/adt/arrayfuncs.c:516
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:505 utils/adt/arrayfuncs.c:552
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:582 utils/adt/arrayfuncs.c:631
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:531 utils/adt/arrayfuncs.c:654
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "Unexpected array element."
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:589
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:597
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "Multidimensional arrays must have sub-arrays with matching dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:674
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:1295
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "invalid array flags"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:1303
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:1353 utils/adt/rangetypes.c:334
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:1493
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "improper binary format in array element %d"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:1574 utils/adt/rangetypes.c:339
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:2052
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "slices of fixed-length arrays not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:2230 utils/adt/arrayfuncs.c:2252
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:2301 utils/adt/arrayfuncs.c:2537
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:2848 utils/adt/arrayfuncs.c:5744
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:5776 utils/adt/arrayfuncs.c:5793
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "wrong number of array subscripts"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:2235 utils/adt/arrayfuncs.c:2343
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:2601 utils/adt/arrayfuncs.c:2907
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "array subscript out of range"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:2240
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "cannot assign null value to an element of a fixed-length array"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:2795
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "updates on slices of fixed-length arrays not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:2826
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#| msgid "array subscript must have type integer"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "array slice subscript must provide both boundaries"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:2827
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:"When assigning to a slice of an empty array value, slice boundaries must be "
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:2838 utils/adt/arrayfuncs.c:2933
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "source array too small"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:3513
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "null array element not allowed in this context"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:3615 utils/adt/arrayfuncs.c:3786
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:4060
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "cannot compare arrays of different element types"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:3962 utils/adt/rangetypes.c:1253
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:5156
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "data type %s is not an array type"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:5213
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "cannot accumulate null arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:5241
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "cannot accumulate empty arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:5270 utils/adt/arrayfuncs.c:5276
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "cannot accumulate arrays of different dimensionality"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:5642 utils/adt/arrayfuncs.c:5682
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "dimension array or low bound array cannot be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:5745 utils/adt/arrayfuncs.c:5777
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "Dimension array must be one dimensional."
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:5750 utils/adt/arrayfuncs.c:5782
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "wrong range of array subscripts"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:5751 utils/adt/arrayfuncs.c:5783
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "Lower bound of dimension array must be one."
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:5756 utils/adt/arrayfuncs.c:5788
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:5794
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "Low bound array has different size than dimensions array."
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:6040
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "removing elements from multidimensional arrays is not supported"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:6317
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "thresholds must be one-dimensional array"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayfuncs.c:6322
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "thresholds array must not contain NULLs"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayutils.c:209
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "typmod array must be type cstring[]"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayutils.c:214
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "typmod array must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#: utils/adt/arrayutils.c:219
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "typmod array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "Expected array element or \"]\", but found \"%s\"."
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "key value must be scalar, not array, composite, or json"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "array must have two columns"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "mismatched array dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "number of jsonb array elements exceeds the maximum allowed (%zu)"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "total size of jsonb array elements exceeds the maximum of %u bytes"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "cannot call %s on an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "cannot get array length of a scalar"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "cannot get array length of a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "cannot deconstruct an array as an object"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "cannot call %s on a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "argument of %s must be an array of objects"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "cannot accept a value of type anyarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgstr " anyarray "
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "cannot accept a value of type anynonarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgstr "anynonarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "cannot display a value of type anynonarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgstr "anynonarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "array of weight must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "array of weight is too short"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "array of weight must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#| msgid "array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "lexeme array may not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#| msgid "array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "weight array may not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "invalid array for XML namespace mapping"
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:"The array must be two-dimensional with length of the second axis equal to 2."
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:msgid "Enable input of NULL elements in arrays."
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:"When turned on, unquoted NULL in an array input value means a null value; "
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:"For RAID arrays, this should be approximately the number of drive spindles "
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:"in the array."
/srvr/z5089358/postgresql-10.4/src/backend/po/zh_CN.po:#~ msgid "neither input type is an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: postmaster/postmaster.c:5484 postmaster/postmaster.c:5821 replication/libpqwalreceiver/libpqwalreceiver.c:256 replication/logical/logical.c:170 storage/buffer/localbuf.c:436 storage/file/fd.c:772 storage/file/fd.c:1200 storage/file/fd.c:1318 storage/file/fd.c:2049 storage/ipc/procarray.c:1058 storage/ipc/procarray.c:1546 storage/ipc/procarray.c:1553 storage/ipc/procarray.c:1970 storage/ipc/procarray.c:2581 utils/adt/formatting.c:1579
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: access/gin/ginutil.c:134 executor/execExpr.c:1780 utils/adt/arrayfuncs.c:3803 utils/adt/arrayfuncs.c:6323 utils/adt/rowtypes.c:927
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "cannot set privileges of array types"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "could not form array type name for type \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgstr "n'a pas pu former le nom du type array pour le type de donnes %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "VARIADIC parameter must be an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "array data types are not binary-compatible"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "array element type cannot be %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "pg_type array OID value not set when in binary upgrade mode"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "cannot alter array type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgstr "ne peut pas modifier le type array %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "You can alter type %s, which will alter the array type as well."
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "target type is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: executor/execExpr.c:2371 executor/execExpr.c:2377 executor/execExprInterp.c:2226 utils/adt/arrayfuncs.c:260 utils/adt/arrayfuncs.c:558 utils/adt/arrayfuncs.c:1288 utils/adt/arrayfuncs.c:3361 utils/adt/arrayfuncs.c:5239 utils/adt/arrayfuncs.c:5756
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "number of array dimensions (%d) exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "cannot merge incompatible arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "multidimensional arrays must have array expressions with matching dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "array subscript in assignment must not be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: executor/execReplication.c:256 parser/parse_oper.c:228 utils/adt/array_userfuncs.c:724 utils/adt/array_userfuncs.c:863 utils/adt/arrayfuncs.c:3639 utils/adt/arrayfuncs.c:4077 utils/adt/arrayfuncs.c:6037 utils/adt/rowtypes.c:1167
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: libpq/pqformat.c:557 libpq/pqformat.c:575 libpq/pqformat.c:596 utils/adt/arrayfuncs.c:1457 utils/adt/rowtypes.c:563
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "could not find array type for data type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "arguments declared \"anyarray\" are not all alike"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgstr "les arguments dclars  anyarray  ne sont pas tous identiques"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "argument declared %s is not an array but type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "type matched to anynonarray is an array type: %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgstr "le type dclar anynonarray est un type tableau : %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "cannot determine type of empty array"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "VARIADIC argument must be an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "cannot subscript type %s because it is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "array subscript must have type integer"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "array assignment requires type %s but expression is of type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "op ANY/ALL (array) requires array on right side"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "op ANY/ALL (array) requires operator to yield boolean"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "op ANY/ALL (array) requires operator not to return a set"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "cannot set an array element to DEFAULT"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "array assignment to \"%s\" requires type %s but expression is of type %s"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "array of serial is not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: postmaster/postmaster.c:2269 storage/ipc/procarray.c:292 storage/ipc/sinvaladt.c:298 storage/lmgr/proc.c:338
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "options array must not be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "array must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "array must have even number of elements"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "invalid zero-length item array in MVDependencies"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "invalid zero-length item array in MVNDistinct"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "ACL array contains wrong data type"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "ACL arrays must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "ACL arrays must not contain null values"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/array_expanded.c:274 utils/adt/arrayfuncs.c:931 utils/adt/arrayfuncs.c:1519 utils/adt/arrayfuncs.c:3251 utils/adt/arrayfuncs.c:3389 utils/adt/arrayfuncs.c:5846 utils/adt/arrayfuncs.c:6157 utils/adt/arrayutils.c:93 utils/adt/arrayutils.c:102 utils/adt/arrayutils.c:109
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "array size exceeds the maximum allowed (%d)"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/array_userfuncs.c:79 utils/adt/array_userfuncs.c:471 utils/adt/array_userfuncs.c:551 utils/adt/json.c:1765 utils/adt/json.c:1860 utils/adt/json.c:1898 utils/adt/jsonb.c:1128 utils/adt/jsonb.c:1157 utils/adt/jsonb.c:1549 utils/adt/jsonb.c:1713 utils/adt/jsonb.c:1723
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/array_userfuncs.c:84
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "input data type is not an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/array_userfuncs.c:132 utils/adt/array_userfuncs.c:186 utils/adt/arrayfuncs.c:1322 utils/adt/float.c:1228 utils/adt/float.c:1287 utils/adt/float.c:3556 utils/adt/float.c:3572 utils/adt/int.c:608 utils/adt/int.c:637 utils/adt/int.c:658 utils/adt/int.c:689 utils/adt/int.c:722 utils/adt/int.c:744 utils/adt/int.c:892 utils/adt/int.c:913 utils/adt/int.c:940 utils/adt/int.c:980 utils/adt/int.c:1001 utils/adt/int.c:1028
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/array_userfuncs.c:139 utils/adt/array_userfuncs.c:196
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "argument must be empty or one-dimensional array"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/array_userfuncs.c:278 utils/adt/array_userfuncs.c:317 utils/adt/array_userfuncs.c:354 utils/adt/array_userfuncs.c:383 utils/adt/array_userfuncs.c:411
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "cannot concatenate incompatible arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/array_userfuncs.c:279
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/array_userfuncs.c:318
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/array_userfuncs.c:355
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/array_userfuncs.c:384 utils/adt/array_userfuncs.c:412
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/array_userfuncs.c:667 utils/adt/array_userfuncs.c:819
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "searching for elements in multidimensional arrays is not supported"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/array_userfuncs.c:691
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:268 utils/adt/arrayfuncs.c:282 utils/adt/arrayfuncs.c:293 utils/adt/arrayfuncs.c:315 utils/adt/arrayfuncs.c:330 utils/adt/arrayfuncs.c:344 utils/adt/arrayfuncs.c:350 utils/adt/arrayfuncs.c:357 utils/adt/arrayfuncs.c:488 utils/adt/arrayfuncs.c:504 utils/adt/arrayfuncs.c:515 utils/adt/arrayfuncs.c:530 utils/adt/arrayfuncs.c:551 utils/adt/arrayfuncs.c:581 utils/adt/arrayfuncs.c:588 utils/adt/arrayfuncs.c:596
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:630 utils/adt/arrayfuncs.c:653 utils/adt/arrayfuncs.c:673 utils/adt/arrayfuncs.c:785 utils/adt/arrayfuncs.c:794 utils/adt/arrayfuncs.c:824 utils/adt/arrayfuncs.c:839 utils/adt/arrayfuncs.c:892
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "malformed array literal: \"%s\""
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:269
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "\"[\" must introduce explicitly-specified array dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:283
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "Missing array dimension value."
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:294 utils/adt/arrayfuncs.c:331
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "Missing \"%s\" after array dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:303 utils/adt/arrayfuncs.c:2870 utils/adt/arrayfuncs.c:2902 utils/adt/arrayfuncs.c:2917
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:316
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:345
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:351 utils/adt/arrayfuncs.c:358
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "Specified array dimensions do not match array contents."
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:489 utils/adt/arrayfuncs.c:516 utils/adt/rangetypes.c:2114 utils/adt/rangetypes.c:2122 utils/adt/rowtypes.c:208 utils/adt/rowtypes.c:216
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:505 utils/adt/arrayfuncs.c:552 utils/adt/arrayfuncs.c:582 utils/adt/arrayfuncs.c:631
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:531 utils/adt/arrayfuncs.c:654
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "Unexpected array element."
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:589
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:597 utils/adt/jsonfuncs.c:2381
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "Multidimensional arrays must have sub-arrays with matching dimensions."
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:674
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:1284 utils/adt/arrayfuncs.c:3357 utils/adt/arrayfuncs.c:5752
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:1295
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "invalid array flags"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:1303
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:1353 utils/adt/rangetypes.c:334 utils/cache/lsyscache.c:2683
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:1493
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "improper binary format in array element %d"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:1574 utils/adt/rangetypes.c:339 utils/cache/lsyscache.c:2716
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:2052
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "slices of fixed-length arrays not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:2230 utils/adt/arrayfuncs.c:2252 utils/adt/arrayfuncs.c:2301 utils/adt/arrayfuncs.c:2537 utils/adt/arrayfuncs.c:2848 utils/adt/arrayfuncs.c:5738 utils/adt/arrayfuncs.c:5764 utils/adt/arrayfuncs.c:5775 utils/adt/json.c:2259 utils/adt/json.c:2334 utils/adt/jsonb.c:1327 utils/adt/jsonb.c:1413 utils/adt/jsonfuncs.c:4158 utils/adt/jsonfuncs.c:4309 utils/adt/jsonfuncs.c:4354 utils/adt/jsonfuncs.c:4401
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "wrong number of array subscripts"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:2235 utils/adt/arrayfuncs.c:2343 utils/adt/arrayfuncs.c:2601 utils/adt/arrayfuncs.c:2907
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "array subscript out of range"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:2240
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "cannot assign null value to an element of a fixed-length array"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:2795
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "updates on slices of fixed-length arrays not implemented"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:2826
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "array slice subscript must provide both boundaries"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:2827
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "When assigning to a slice of an empty array value, slice boundaries must be fully specified."
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:2838 utils/adt/arrayfuncs.c:2933
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "source array too small"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:3513
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "null array element not allowed in this context"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:3615 utils/adt/arrayfuncs.c:3786 utils/adt/arrayfuncs.c:4060
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "cannot compare arrays of different element types"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:3962 utils/adt/rangetypes.c:1253
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:5152
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "data type %s is not an array type"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:5207
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "cannot accumulate null arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:5235
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "cannot accumulate empty arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:5264 utils/adt/arrayfuncs.c:5270
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "cannot accumulate arrays of different dimensionality"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:5636 utils/adt/arrayfuncs.c:5676
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "dimension array or low bound array cannot be null"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:5739 utils/adt/arrayfuncs.c:5765
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "Dimension array must be one dimensional."
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:5744 utils/adt/arrayfuncs.c:5770
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:5776
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "Low bound array has different size than dimensions array."
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:6022
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "removing elements from multidimensional arrays is not supported"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:6299
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "thresholds must be one-dimensional array"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayfuncs.c:6304
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "thresholds array must not contain NULLs"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayutils.c:209
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "typmod array must be type cstring[]"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayutils.c:214
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "typmod array must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#: utils/adt/arrayutils.c:219
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "typmod array must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "Expected array element or \"]\", but found \"%s\"."
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "key value must be scalar, not array, composite, or json"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "array must have two columns"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "mismatched array dimensions"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "number of jsonb array elements exceeds the maximum allowed (%zu)"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "total size of jsonb array elements exceeds the maximum of %u bytes"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "cannot call %s on an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "cannot get array length of a scalar"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "cannot get array length of a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "cannot deconstruct an array as an object"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "cannot call %s on a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "expected json array"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "See the array element %s of key \"%s\"."
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "See the array element %s."
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "malformed json array"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "argument of %s must be an array of objects"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "regexp_split_to_array does not support the global option"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgstr "regexp_split_to_array ne supporte pas l'option globale"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "array of weight must be one-dimensional"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "array of weight is too short"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "array of weight must not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "lexeme array may not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "weight array may not contain nulls"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "invalid array for XML namespace mapping"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "The array must be two-dimensional with length of the second axis equal to 2."
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "Enable input of NULL elements in arrays."
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "When turned on, unquoted NULL in an array input value means a null value; otherwise it is taken literally."
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:msgid "For RAID arrays, this should be approximately the number of drive spindles in the array."
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#~ msgid "wrong range of array subscripts"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#~ msgid "Lower bound of dimension array must be one."
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#~ msgid "neither input type is an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#~ msgid "cannot call json_object_keys on an array"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#~ msgid "cannot extract array element from a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#~ msgid "cannot call json_array_elements on a non-array"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#~ msgstr "ne peut pas appeler json_array_elements sur un objet qui n'est pas un tableau"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#~ msgid "cannot call json_array_elements on a scalar"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#~ msgstr "ne peut pas appeler json_array_elements sur un scalaire"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#~ msgid "must call json_populate_recordset on an array of objects"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#~ msgid "cannot call json_populate_recordset with nested arrays"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#~ msgid "wrong number of array_subscripts"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#~ msgid "cannot display a value of type anynonarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#~ msgstr "ne peut pas afficher une valeur de type anynonarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#~ msgid "cannot accept a value of type anynonarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#~ msgstr "ne peut pas accepter une valeur de type anynonarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#~ msgid "cannot accept a value of type anyarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#~ msgstr "ne peut pas accepter une valeur de type anyarray"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#~ msgid "op ANY/ALL (array) does not support set arguments"
/srvr/z5089358/postgresql-10.4/src/backend/po/fr.po:#~ "l'oprateur ANY/ALL (pour les types array) ne supporte pas les arguments\n"
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:	cm->maxarrayrows = 4;		/* arbitrary initial allocation */
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:	cm->hiarrayrows = 1;		/* but we have only one row/col initially */
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:	cm->hiarraycols = 1;
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:	cm->hicolormap = (color *) MALLOC(cm->maxarrayrows * sizeof(color));
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:	rownum = 0;					/* if no match, use array row zero */
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:	if (cm->hiarraycols > 1)
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:		return cm->hicolormap[rownum * cm->hiarraycols + colnum];
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c: * Returns array index of new row.  Note the array might move.
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:	int			newrow = cm->hiarrayrows;
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:	/* Assign a fresh array row index, enlarging storage if needed */
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:	if (newrow >= cm->maxarrayrows)
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:		color	   *newarray;
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:		if (cm->maxarrayrows >= INT_MAX / (cm->hiarraycols * 2))
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:		newarray = (color *) REALLOC(cm->hicolormap,
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:									 cm->maxarrayrows * 2 *
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:									 cm->hiarraycols * sizeof(color));
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:		if (newarray == NULL)
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:		cm->hicolormap = newarray;
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:		cm->maxarrayrows *= 2;
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:	cm->hiarrayrows++;
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:	newrowptr = &cm->hicolormap[newrow * cm->hiarraycols];
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:		   &cm->hicolormap[oldrow * cm->hiarraycols],
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:		   cm->hiarraycols * sizeof(color));
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:	for (i = 0; i < cm->hiarraycols; i++)
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c: * Essentially, extends the 2-D array to the right with a copy of itself.
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:	color	   *newarray;
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:	if (cm->hiarraycols >= INT_MAX / (cm->maxarrayrows * 2))
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:	newarray = (color *) REALLOC(cm->hicolormap,
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:								 cm->maxarrayrows *
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:								 cm->hiarraycols * 2 * sizeof(color));
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:	if (newarray == NULL)
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:	cm->hicolormap = newarray;
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:	/* Must work backwards in the array because we realloc'd in place */
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:	for (r = cm->hiarrayrows - 1; r >= 0; r--)
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:		color	   *oldrowptr = &newarray[r * cm->hiarraycols];
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:		color	   *newrowptr = &newarray[r * cm->hiarraycols * 2];
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:		color	   *newrowptr2 = newrowptr + cm->hiarraycols;
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:		for (c = 0; c < cm->hiarraycols; c++)
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:	cm->hiarraycols *= 2;
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:		/* Enlarge array if we don't have a column bit assignment for cclass */
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:			cm->classbits[cv->cclasscode] = cm->hiarraycols;
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:		for (r = 0; r < cm->hiarrayrows; r++)
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:			for (c = 0; c < cm->hiarraycols; c++)
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:	pco = &cm->hicolormap[rownum * cm->hiarraycols];
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:	for (i = 0; i < cm->hiarraycols; pco++, i++)
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:	if (cm->hiarrayrows > 1 || cm->hiarraycols > 1)
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:		for (c = 0; c < cm->hiarraycols; c++)
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:			rowptr = &cm->hicolormap[cm->cmranges[r].rownum * cm->hiarraycols];
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_color.c:			for (c = 0; c < cm->hiarraycols; c++)
/srvr/z5089358/postgresql-10.4/src/backend/regex/regprefix.c: * Results are returned into the preallocated chr array string[], with
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_cvec.c: * Only (selected) functions in _this_ file should treat the chr arrays
/srvr/z5089358/postgresql-10.4/src/backend/regex/README:The last two of these are handled with the "struct colordesc" array and
/srvr/z5089358/postgresql-10.4/src/backend/regex/README:Ideally, we'd do the first two operations using a simple linear array
/srvr/z5089358/postgresql-10.4/src/backend/regex/README:linear array is used for character codes up to MAX_SIMPLE_CHR, which can be
/srvr/z5089358/postgresql-10.4/src/backend/regex/README:character or character range as an entry in the "colormaprange" array in
/srvr/z5089358/postgresql-10.4/src/backend/regex/README:certainly don't want to be searching large colormaprange arrays at runtime.
/srvr/z5089358/postgresql-10.4/src/backend/regex/README:the color map for characters above MAX_SIMPLE_CHR is really a 2-D array,
/srvr/z5089358/postgresql-10.4/src/backend/regex/README:character classes, we may have entries in the high color map array that
/srvr/z5089358/postgresql-10.4/src/backend/regex/regexport.c: * Notice that these functions return info into caller-provided arrays
/srvr/z5089358/postgresql-10.4/src/backend/regex/regexport.c: * Write array of outgoing NFA arcs of state number "st" into arcs[],
/srvr/z5089358/postgresql-10.4/src/backend/regex/regexport.c: * Write array of member chrs of color number "co" into chars[],
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_lex.c:/* construct pointer past end of chr array */
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_lex.c:#define ENDOF(array)	((array) + sizeof(array)/sizeof(chr))
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_pg_locale.c: * chrs[] and ranges[] arrays separately from the struct so that we can
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	struct arc **sortarray;
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	/* make an array of arc pointers ... */
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	sortarray = (struct arc **) MALLOC(n * sizeof(struct arc *));
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	if (sortarray == NULL)
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:		sortarray[i++] = a;
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	/* ... sort the array */
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	qsort(sortarray, n, sizeof(struct arc *), sortins_cmp);
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	a = sortarray[0];
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	a->inchain = sortarray[1];
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:		a = sortarray[i];
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:		a->inchain = sortarray[i + 1];
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:		a->inchainRev = sortarray[i - 1];
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	a = sortarray[i];
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	a->inchainRev = sortarray[i - 1];
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	FREE(sortarray);
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	struct arc **sortarray;
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	/* make an array of arc pointers ... */
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	sortarray = (struct arc **) MALLOC(n * sizeof(struct arc *));
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	if (sortarray == NULL)
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:		sortarray[i++] = a;
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	/* ... sort the array */
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	qsort(sortarray, n, sizeof(struct arc *), sortouts_cmp);
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	a = sortarray[0];
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	a->outchain = sortarray[1];
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:		a = sortarray[i];
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:		a->outchain = sortarray[i + 1];
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:		a->outchainRev = sortarray[i - 1];
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	a = sortarray[i];
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	a->outchainRev = sortarray[i - 1];
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	FREE(sortarray);
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c: * This is much like copyins, but the source arcs are listed in an array,
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c: * and are not guaranteed unique.  It's okay to clobber the array contents.
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:		 struct arc **arcarray,
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	qsort(arcarray, arccount, sizeof(struct arc *), sortins_cmp);
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	 * arcarray very likely includes dups, so we must eliminate them.  (This
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:		switch (sortins_cmp(&arcarray[j], &arcarray[i]))
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:				arcarray[++j] = arcarray[i];
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:		struct arc *a = arcarray[i];
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:				/* advance only na; array might have a match later */
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:		struct arc *a = arcarray[i];
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	struct arc **arcarray;
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	arcarray = (struct arc **) MALLOC(totalinarcs * sizeof(struct arc *));
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	if (arcarray == NULL)
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:			/* Add s2's original inarcs to arcarray[], but ignore empties */
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:					arcarray[arccount++] = a;
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:		mergeins(nfa, s, arcarray, arccount);
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c:	FREE(arcarray);
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c: * Since this is only used in fixempties(), we pass in the inarcsorig[] array
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c: * a boolean array showing which source states we've already visited for this
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_nfa.c: * have multiple redundant arc pathways).  Each donemap is a char array
/srvr/z5089358/postgresql-10.4/src/backend/regex/regc_locale.c: * The following arrays define the valid character class names.
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c: * PQconninfoOptions[] is a constant static array that we use to initialize
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c: * array is freed (see PQconninfoFree).
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c:	 * the array so as not to reject conninfo strings from old apps that might
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c:static PQconninfoOption *conninfo_array_parse(const char *const *keywords,
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c: * NULL terminated arrays instead.
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c: * using connection information in two arrays.
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c: * The keywords array is defined as
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c: * The values array is defined as
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c:	 * Parse the conninfo arrays
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c:	connOptions = conninfo_array_parse(keywords, values,
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c:		 * If hostaddr was given, the array was allocated according to the
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c: * Construct a default connection options array, which identifies all the
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c: * NOTE: as of PostgreSQL 7.0, the returned array is dynamically allocated
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c: * versions, the returned array was static, but that's not thread-safe.)
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c: * string of connection options that are parsed and added to the array of
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c: * resulting connection options array.  NULL is returned on failure.
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c: * NOTE: the returned array is dynamically allocated and should
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c: * Build a working copy of the constant PQconninfoOptions array.
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c: * Returns a malloc'd PQconninfoOption array, if parsing is successful.
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c: * Conninfo array parser routine
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c: * If successful, a malloc'd PQconninfoOption array is returned.
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c:conninfo_array_parse(const char *const *keywords, const char *const *values,
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c:	/* Parse the keywords/values arrays */
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c: * options array.
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c: * If successful, returns true while the options array is filled with parsed
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c: * Find an option value corresponding to the keyword in the connOptions array.
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c: * connOptions array.
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-connect.c: * connOptions array.
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/libpq-int.h:	PGresAttValue **tuples;		/* each PGresTuple is an array of
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/libpq-int.h:	int			tupArrSize;		/* allocated size of tuples array */
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/libpq-int.h:/* Typedef for the EnvironmentOptions[] array */
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/libpq-int.h:	PGEvent    *events;			/* expandable array of event data */
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/libpq-int.h:	int			eventArraySize; /* allocated array size */
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/libpq-int.h:	PGdataValue *rowBuf;		/* array for passing values to rowProcessor */
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/libpq-int.h: * direct use of this array is deprecated; call PQresStatus() instead.
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/libpq-fe.h:	char	  **fieldName;		/* null terminated array of replacement field
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/libpq-fe.h: * will release both the val strings and the PQconninfoOption array itself.
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-secure-openssl.c:static pthread_mutex_t *pq_lockarray;
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-secure-openssl.c:		if (pthread_mutex_lock(&pq_lockarray[n]))
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-secure-openssl.c:		if (pthread_mutex_unlock(&pq_lockarray[n]))
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-secure-openssl.c:		 * If necessary, set up an array to hold locks for libcrypto.
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-secure-openssl.c:		 * libcrypto will tell us how big to make this array.
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-secure-openssl.c:		if (pq_lockarray == NULL)
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-secure-openssl.c:			pq_lockarray = malloc(sizeof(pthread_mutex_t) * CRYPTO_num_locks());
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-secure-openssl.c:			if (!pq_lockarray)
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-secure-openssl.c:				if (pthread_mutex_init(&pq_lockarray[i], NULL))
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-secure-openssl.c:					free(pq_lockarray);
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-secure-openssl.c:					pq_lockarray = NULL;
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-secure-openssl.c:		 * We don't free the lock array. If we get another connection in this
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-exec.c: * We also malloc the top-level array of tuple pointers separately, because
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-exec.c: * calls: one for the PGresult, one for the tuples pointer array, and one
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-exec.c: * Copy an array of PGEvents (with no extra space for more).
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-exec.c:		/* add it to the array */
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-exec.c:	/* Free the top-level tuple pointer array */
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-exec.c:		 * Try to grow the array.
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-exec.c:	/* And add the tuple to the PGresult's tuple array */
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-exec.c: *		args			: pointer to an array of function arguments
/srvr/z5089358/postgresql-10.4/src/interfaces/libpq/fe-exec.c: *		nargs			: # of arguments in args array.
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/ecpg_schedule:test: preproc/array_of_struct
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/ecpg_schedule:test: sql/array
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/sql/Makefile:TESTS = array array.c \
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/sql/.gitignore:/array
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/sql/.gitignore:/array.c
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/preproc/define.pgc:exec sql type intarray is int[AMOUNT];
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/preproc/define.pgc:typedef int intarray[AMOUNT];
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/preproc/define.pgc:	intarray amount;
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/preproc/Makefile:TESTS = array_of_struct array_of_struct.c \
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/preproc/Makefile:array_of_struct.c: array_of_struct.pgc $(ECPG_TEST_DEPENDENCIES)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/preproc/.gitignore:/array_of_struct
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/preproc/.gitignore:/array_of_struct.c
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-define.stderr:[NO_PID]: ecpg_get_data on line 43: RESULT: false    offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-define.stderr:[NO_PID]: ecpg_get_data on line 43: RESULT: true     offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-define.stderr:[NO_PID]: ecpg_get_data on line 43: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-define.stderr:[NO_PID]: ecpg_get_data on line 43: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-define.stderr:[NO_PID]: ecpg_get_data on line 43: RESULT: f offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-define.stderr:[NO_PID]: ecpg_get_data on line 43: RESULT: t offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-variable.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT: Mum      offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-variable.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-variable.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-variable.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT: 1987-07-14 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-variable.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT: 3 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-variable.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT: Dad      offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-variable.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT: 19610721 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-variable.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-variable.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT: 1987-07-14 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-variable.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT: 3 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-variable.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT: Child 1  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-variable.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-variable.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT: 16 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-variable.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-variable.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-variable.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT: Child 2  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-variable.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-variable.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT: 14 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-variable.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-variable.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-variable.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT: Child 3  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-variable.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-variable.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT: 9 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-variable.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-variable.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-desc.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-desc.stderr:[NO_PID]: ecpg_get_data on line 61: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-desc.stderr:[NO_PID]: ecpg_get_data on line 61: RESULT: one offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-desc.stderr:[NO_PID]: ecpg_get_data on line 73: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-desc.stderr:[NO_PID]: ecpg_get_data on line 73: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-desc.stderr:[NO_PID]: ecpg_get_data on line 78: RESULT: 3 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-desc.stderr:[NO_PID]: ecpg_get_data on line 78: RESULT: this is a long test offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 111: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 111: RESULT: a offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 111: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 111: RESULT: a          offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 111: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 111: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 111: RESULT: d offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 111: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 111: RESULT: d          offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 141: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 141: RESULT: d offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 141: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 141: RESULT: d          offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 141: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 141: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 141: RESULT: a offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 141: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 141: RESULT: a          offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 185: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 185: RESULT: d offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 185: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 185: RESULT: d          offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 222: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 222: RESULT: d offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 222: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-sqlda.stderr:[NO_PID]: ecpg_get_data on line 222: RESULT: d          offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.stderr:[NO_PID]: ecpg_get_data on line 56: RESULT: John Doe offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.stderr:[NO_PID]: ecpg_get_data on line 56: RESULT: Jane Doe offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.stderr:[NO_PID]: ecpg_get_data on line 56: RESULT: 12345 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.stderr:[NO_PID]: ecpg_get_data on line 56: RESULT: 67890 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.stderr:[NO_PID]: ecpg_get_data on line 64: RESULT: John Doe offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.stderr:[NO_PID]: ecpg_get_data on line 64: RESULT: Jane Doe offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.stderr:[NO_PID]: ecpg_get_data on line 64: RESULT: 12345 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.stderr:[NO_PID]: ecpg_get_data on line 64: RESULT: 67890 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT: John Doe offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT: Jane Doe offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT: 12345 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.stderr:[NO_PID]: ecpg_get_data on line 72: RESULT: 67890 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.stderr:[NO_PID]: ecpg_get_data on line 80: RESULT: John Doe offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.stderr:[NO_PID]: ecpg_get_data on line 80: RESULT: 12345 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.stderr:[NO_PID]: ecpg_get_data on line 85: RESULT: John Doe offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.stderr:[NO_PID]: ecpg_get_data on line 85: RESULT: Jane Doe offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-outofscope.stderr:[NO_PID]: ecpg_get_data on line 49: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-outofscope.stderr:[NO_PID]: ecpg_get_data on line 49: RESULT: a offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-outofscope.stderr:[NO_PID]: ecpg_get_data on line 49: RESULT: 1.0 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-outofscope.stderr:[NO_PID]: ecpg_get_data on line 49: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-outofscope.stderr:[NO_PID]: ecpg_get_data on line 49: RESULT: a          offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-outofscope.stderr:[NO_PID]: ecpg_get_data on line 49: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-outofscope.stderr:[NO_PID]: ecpg_get_data on line 49: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-outofscope.stderr:[NO_PID]: ecpg_get_data on line 49: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-outofscope.stderr:[NO_PID]: ecpg_get_data on line 49: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-outofscope.stderr:[NO_PID]: ecpg_get_data on line 49: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-outofscope.stderr:[NO_PID]: ecpg_get_data on line 49: RESULT: 3 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-outofscope.stderr:[NO_PID]: ecpg_get_data on line 49: RESULT: b offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-outofscope.stderr:[NO_PID]: ecpg_get_data on line 49: RESULT: 2.0 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-outofscope.stderr:[NO_PID]: ecpg_get_data on line 49: RESULT: 3 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-outofscope.stderr:[NO_PID]: ecpg_get_data on line 49: RESULT: b          offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dyntest.stderr:[NO_PID]: ecpg_get_data on line 183: RESULT: first entry    offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dyntest.stderr:[NO_PID]: ecpg_get_data on line 172: RESULT: 14.7 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dyntest.stderr:[NO_PID]: ecpg_get_data on line 168: RESULT: 14 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dyntest.stderr:[NO_PID]: ecpg_get_data on line 187: RESULT: 123045607890 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dyntest.stderr:[NO_PID]: ecpg_get_data on line 163: RESULT: t offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dyntest.stderr:[NO_PID]: ecpg_get_data on line 183: RESULT: The world's most advanced open source database. offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dyntest.stderr:[NO_PID]: ecpg_get_data on line 176: RESULT: 14.07.1987 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dyntest.stderr:[NO_PID]: ecpg_get_data on line 183: RESULT: second entry   offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dyntest.stderr:[NO_PID]: ecpg_get_data on line 172: RESULT: 1407.87 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dyntest.stderr:[NO_PID]: ecpg_get_data on line 168: RESULT: 1407 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dyntest.stderr:[NO_PID]: ecpg_get_data on line 187: RESULT: 987065403210 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dyntest.stderr:[NO_PID]: ecpg_get_data on line 163: RESULT: f offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dyntest.stderr:[NO_PID]: ecpg_get_data on line 183: RESULT: The elephant never forgets. offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dyntest.stderr:[NO_PID]: ecpg_get_data on line 176: RESULT: 05.11.1999 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-binary.stderr:[NO_PID]: ecpg_get_data on line 60: RESULT: first user           offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-binary.stderr:[NO_PID]: ecpg_get_data on line 60: RESULT: 320 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-binary.stderr:[NO_PID]: ecpg_get_data on line 60: RESULT: \001m\000\212 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-binary.stderr:[NO_PID]: ecpg_get_data on line 74: RESULT: BINARY offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-binary.stderr:[NO_PID]: ecpg_get_data on line 74: RESULT: BINARY offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-binary.stderr:[NO_PID]: ecpg_get_data on line 74: RESULT: BINARY offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-binary.stderr:[NO_PID]: ecpg_get_data on line 91: RESULT: BINARY offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-define.stderr:[NO_PID]: ecpg_get_data on line 36: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-define.stderr:[NO_PID]: ecpg_get_data on line 36: RESULT: 29-abcdef offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 39: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 39: RESULT: NaN offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 39: RESULT: NaN offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 39: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 39: RESULT: Infinity offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 39: RESULT: Infinity offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 39: RESULT: 3 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 39: RESULT: -Infinity offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 39: RESULT: -Infinity offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: NaN offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: NaN offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: Infinity offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: Infinity offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: 3 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: -Infinity offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: -Infinity offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: NaN offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: NaN offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: 7 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: NaN offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: NaN offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: 5 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: Infinity offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: Infinity offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: 8 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: Infinity offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: Infinity offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: 6 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: -Infinity offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: -Infinity offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: 9 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: -Infinity offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: -Infinity offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 70: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 70: RESULT: NaN offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 70: RESULT: NaN offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 81: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 81: RESULT: NaN offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 81: RESULT: NaN offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 81: RESULT: 5 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 81: RESULT: NaN offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 81: RESULT: NaN offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 81: RESULT: 6 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 81: RESULT: NaN offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-nan_test.stderr:[NO_PID]: ecpg_get_data on line 81: RESULT: NaN offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-fetch.stderr:[NO_PID]: ecpg_get_data on line 32: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-fetch.stderr:[NO_PID]: ecpg_get_data on line 32: RESULT: text1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-fetch.stderr:[NO_PID]: ecpg_get_data on line 32: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-fetch.stderr:[NO_PID]: ecpg_get_data on line 32: RESULT: text2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-fetch.stderr:[NO_PID]: ecpg_get_data on line 32: RESULT: 3 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-fetch.stderr:[NO_PID]: ecpg_get_data on line 32: RESULT: text3 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-fetch.stderr:[NO_PID]: ecpg_get_data on line 32: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-fetch.stderr:[NO_PID]: ecpg_get_data on line 32: RESULT: text4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-fetch.stderr:[NO_PID]: ecpg_get_data on line 39: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-fetch.stderr:[NO_PID]: ecpg_get_data on line 39: RESULT: text4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-fetch.stderr:[NO_PID]: ecpg_get_data on line 50: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-fetch.stderr:[NO_PID]: ecpg_get_data on line 50: RESULT: text1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-test_informix.stderr:[NO_PID]: ecpg_get_data on line 57: RESULT: 7 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-test_informix.stderr:[NO_PID]: ecpg_get_data on line 57: RESULT: 0 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-test_informix.stderr:[NO_PID]: ecpg_get_data on line 57: RESULT: test    offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-test_informix.stderr:[NO_PID]: ecpg_get_data on line 57: RESULT: 14 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-test_informix.stderr:[NO_PID]: ecpg_get_data on line 57: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-test_informix.stderr:[NO_PID]: ecpg_get_data on line 57: RESULT: a       offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-pointer_to_struct.stderr:[NO_PID]: ecpg_get_data on line 60: RESULT: John Doe offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-pointer_to_struct.stderr:[NO_PID]: ecpg_get_data on line 60: RESULT: Jane Doe offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-pointer_to_struct.stderr:[NO_PID]: ecpg_get_data on line 60: RESULT: 12345 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-pointer_to_struct.stderr:[NO_PID]: ecpg_get_data on line 60: RESULT: 67890 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-pointer_to_struct.stderr:[NO_PID]: ecpg_get_data on line 68: RESULT: John Doe offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-pointer_to_struct.stderr:[NO_PID]: ecpg_get_data on line 68: RESULT: Jane Doe offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-pointer_to_struct.stderr:[NO_PID]: ecpg_get_data on line 68: RESULT: 12345 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-pointer_to_struct.stderr:[NO_PID]: ecpg_get_data on line 68: RESULT: 67890 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-pointer_to_struct.stderr:[NO_PID]: ecpg_get_data on line 76: RESULT: John Doe offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-pointer_to_struct.stderr:[NO_PID]: ecpg_get_data on line 76: RESULT: Jane Doe offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-pointer_to_struct.stderr:[NO_PID]: ecpg_get_data on line 76: RESULT: 12345 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-pointer_to_struct.stderr:[NO_PID]: ecpg_get_data on line 76: RESULT: 67890 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-pointer_to_struct.stderr:[NO_PID]: ecpg_get_data on line 84: RESULT: John Doe offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-pointer_to_struct.stderr:[NO_PID]: ecpg_get_data on line 84: RESULT: 12345 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-pointer_to_struct.stderr:[NO_PID]: ecpg_get_data on line 89: RESULT: John Doe offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-pointer_to_struct.stderr:[NO_PID]: ecpg_get_data on line 89: RESULT: Jane Doe offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 109: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 109: RESULT: a offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 109: RESULT: 1.0 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 109: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 109: RESULT: a          offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 109: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 109: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 109: RESULT: d offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 109: RESULT: 4.0 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 109: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 109: RESULT: d          offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 146: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 146: RESULT: a offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 146: RESULT: 1.0 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 146: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 146: RESULT: a          offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 146: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 146: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 146: RESULT: d offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 146: RESULT: 4.0 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 146: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 146: RESULT: d          offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 184: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 184: RESULT: d offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 184: RESULT: 4.0 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 184: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 184: RESULT: d          offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 221: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 221: RESULT: d offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 221: RESULT: 4.0 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 221: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-sqlda.stderr:[NO_PID]: ecpg_get_data on line 221: RESULT: d          offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-whenever.stderr:[NO_PID]: ecpg_get_data on line 36: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-whenever.stderr:[NO_PID]: ecpg_get_data on line 36: RESULT: abcdefghij offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-whenever.stderr:[NO_PID]: ecpg_get_data on line 64: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-func.stderr:[NO_PID]: ecpg_get_data on line 36: RESULT: my_table_check_trigger offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-parser.stderr:[NO_PID]: ecpg_get_data on line 26: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-parser.stderr:[NO_PID]: ecpg_get_data on line 26: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-parser.stderr:[NO_PID]: ecpg_get_data on line 26: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-autoprep.stderr:[NO_PID]: ecpg_get_data on line 30: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-autoprep.stderr:[NO_PID]: ecpg_get_data on line 30: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-autoprep.stderr:[NO_PID]: ecpg_get_data on line 30: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-autoprep.stderr:[NO_PID]: ecpg_get_data on line 30: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-autoprep.stderr:[NO_PID]: ecpg_get_data on line 39: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-autoprep.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-autoprep.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-autoprep.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-autoprep.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-autoprep.stderr:[NO_PID]: ecpg_get_data on line 30: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-autoprep.stderr:[NO_PID]: ecpg_get_data on line 30: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-autoprep.stderr:[NO_PID]: ecpg_get_data on line 30: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-autoprep.stderr:[NO_PID]: ecpg_get_data on line 30: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-autoprep.stderr:[NO_PID]: ecpg_get_data on line 39: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-autoprep.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-autoprep.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-autoprep.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-autoprep.stderr:[NO_PID]: ecpg_get_data on line 55: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 1 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 3 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 5 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 6 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 7 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 12 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 13 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 14 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 19 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 20 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 21 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 30 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 31 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 32 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 26 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 27 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 33 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 38 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 36 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 37 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 43 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 41 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 42 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 44 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 45 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 46 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 50 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 50 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 50 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 52 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 52 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 52 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 53 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 53 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 53 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 53 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 54 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 54 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 54 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 54 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 56 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 56 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 56 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 56 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 64 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 64 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 64 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 64 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 72 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 72 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 72 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 72 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 80 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 80 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 80 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 80 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 85 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 85 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 85 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 85 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 92 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 92 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-array_of_struct.c:#line 92 "array_of_struct.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 70: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 70: RESULT: a offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 74: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 74: RESULT: b offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 78: RESULT: 3 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 78: RESULT: c offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 83: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 83: RESULT: d offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 90: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 90: RESULT: a offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 95: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 95: RESULT: b offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 111: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 111: RESULT: a offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 115: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 115: RESULT: b offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 119: RESULT: 3 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 119: RESULT: c offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 124: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 124: RESULT: d offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 131: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 131: RESULT: a offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 136: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 136: RESULT: b offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 157: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 157: RESULT: e offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 161: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 161: RESULT: a offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 165: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 165: RESULT: b offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 170: RESULT: 3 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 170: RESULT: c offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 177: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 177: RESULT: a offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 182: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 182: RESULT: b offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 209: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 209: RESULT: a offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 213: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 213: RESULT: b offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 217: RESULT: 3 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 217: RESULT: c offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 222: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 222: RESULT: d offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 229: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 229: RESULT: a offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 234: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-cursor.stderr:[NO_PID]: ecpg_get_data on line 234: RESULT: b offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/connect-test3.stderr:[NO_PID]: ecpg_get_data on line 27: RESULT: ecpg1_regression offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/connect-test3.stderr:[NO_PID]: ecpg_get_data on line 31: RESULT: ecpg2_regression offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc2.stderr:[NO_PID]: ecpg_get_data on line 35: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc2.stderr:[NO_PID]: ecpg_get_data on line 35: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc2.stderr:[NO_PID]: ecpg_get_data on line 35: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc2.stderr:[NO_PID]: ecpg_get_data on line 35: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc2.stderr:[NO_PID]: ecpg_get_data on line 35: RESULT: 5 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc2.stderr:[NO_PID]: ecpg_get_data on line 35: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc2.stderr:[NO_PID]: ecpg_get_data on line 36: RESULT: one offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc2.stderr:[NO_PID]: ecpg_get_data on line 36: RESULT: two offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc2.stderr:[NO_PID]: ecpg_get_data on line 36: RESULT: three offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc2.stderr:[NO_PID]: ecpg_get_data on line 36: RESULT: four offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc2.stderr:[NO_PID]: ecpg_get_data on line 36: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc2.stderr:[NO_PID]: ecpg_get_data on line 36: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-rnull.stderr:[NO_PID]: ecpg_get_data on line 59: RESULT: abc        offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-rnull.stderr:[NO_PID]: ecpg_get_data on line 59: RESULT: 17 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-rnull.stderr:[NO_PID]: ecpg_get_data on line 59: RESULT: -74874 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-rnull.stderr:[NO_PID]: ecpg_get_data on line 59: RESULT: t offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-rnull.stderr:[NO_PID]: ecpg_get_data on line 59: RESULT: 3.71000003814697 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-rnull.stderr:[NO_PID]: ecpg_get_data on line 59: RESULT: 487444 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-rnull.stderr:[NO_PID]: ecpg_get_data on line 59: RESULT: 404.404 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-rnull.stderr:[NO_PID]: ecpg_get_data on line 59: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-rnull.stderr:[NO_PID]: ecpg_get_data on line 59: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-rnull.stderr:[NO_PID]: ecpg_get_data on line 59: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-rnull.stderr:[NO_PID]: ecpg_get_data on line 76: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-rnull.stderr:[NO_PID]: ecpg_get_data on line 76: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-rnull.stderr:[NO_PID]: ecpg_get_data on line 76: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-rnull.stderr:[NO_PID]: ecpg_get_data on line 76: RESULT: t offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-rnull.stderr:[NO_PID]: ecpg_get_data on line 76: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-rnull.stderr:[NO_PID]: ecpg_get_data on line 76: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-rnull.stderr:[NO_PID]: ecpg_get_data on line 76: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-rnull.stderr:[NO_PID]: ecpg_get_data on line 76: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-rnull.stderr:[NO_PID]: ecpg_get_data on line 76: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-rnull.stderr:[NO_PID]: ecpg_get_data on line 76: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 53: RESULT: db: 'r1' offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 53: RESULT: db: 'r1' offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 53: RESULT: db: 'r1' offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 53: RESULT: db: 'r1' offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 53: RESULT: db: 'r1' offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 53: RESULT: db: 'r1' offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 53: RESULT: db: 'r1' offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 53: RESULT: db: 'r1' offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 53: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 53: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 53: RESULT: 11 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 53: RESULT: 12 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 53: RESULT: 101 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 53: RESULT: 102 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 53: RESULT: 111 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 53: RESULT: 112 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 53: RESULT: f offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 53: RESULT: t offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 53: RESULT: f offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 53: RESULT: t offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 53: RESULT: f offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 53: RESULT: t offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 53: RESULT: f offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 53: RESULT: t offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 75: RESULT: db: 'r1' offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 75: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 75: RESULT: f offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 94: RESULT: db: 'r1' offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 94: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-execute.stderr:[NO_PID]: ecpg_get_data on line 94: RESULT: t offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-test_informix2.stderr:[NO_PID]: ecpg_get_data on line 76: RESULT: Wed 07 May 13:28:34 2003 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-test_informix2.stderr:[NO_PID]: ecpg_get_data on line 81: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/compat_informix-test_informix2.stderr:[NO_PID]: ecpg_get_data on line 81: RESULT: Wed 07 May 13:28:34 2003 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/connect-test2.stderr:[NO_PID]: ecpg_get_data on line 28: RESULT: ecpg1_regression offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/connect-test2.stderr:[NO_PID]: ecpg_get_data on line 29: RESULT: ecpg2_regression offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/connect-test2.stderr:[NO_PID]: ecpg_get_data on line 30: RESULT: ecpg1_regression offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/connect-test2.stderr:[NO_PID]: ecpg_get_data on line 33: RESULT: ecpg2_regression offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/connect-test2.stderr:[NO_PID]: ecpg_get_data on line 37: RESULT: ecpg1_regression offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.stderr:[NO_PID]: ecpg_get_data on line 77: RESULT: 14.07 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.stderr:[NO_PID]: ecpg_get_data on line 77: RESULT: 0123456789 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.stderr:[NO_PID]: ecpg_is_type_an_array on line 85: type (1007); C (3); array (yes)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.stderr:[NO_PID]: ecpg_get_data on line 85: RESULT: {9,8,7,6,5,4,3,2,1,0} offset: -1; array: yes
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.stderr:[NO_PID]: ecpg_get_data on line 85: RESULT: klmnopqrst offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.stderr:[NO_PID]: ecpg_is_type_an_array on line 85: type (1115); C (19); array (yes)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.stderr:[NO_PID]: ecpg_get_data on line 85: RESULT: {"Sat Jan 01 00:00:00 2000","Sat Jan 01 01:00:00 2000","Sat Jan 01 02:00:00 2000","Sat Jan 01 03:00:00 2000","Sat Jan 01 04:00:00 2000","Sat Jan 01 05:00:00 2000","Sat Jan 01 06:00:00 2000","Sat Jan 01 07:00:00 2000","Sat Jan 01 08:00:00 2000","Sat Jan 01 09:00:00 2000"} offset: -1; array: yes
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.stderr:[NO_PID]: ecpg_is_type_an_array on line 85: type (1231); C (16); array (yes)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.stderr:[NO_PID]: ecpg_get_data on line 85: RESULT: {0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0} offset: -1; array: yes
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.stderr:[NO_PID]: ecpg_is_type_an_array on line 85: type (1182); C (18); array (yes)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.stderr:[NO_PID]: ecpg_get_data on line 85: RESULT: {01-10-2000,01-11-2000,01-12-2000,01-13-2000,01-14-2000,01-15-2000,01-16-2000,01-17-2000,01-18-2000,01-19-2000} offset: -1; array: yes
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.stderr:[NO_PID]: ecpg_is_type_an_array on line 85: type (1187); C (20); array (yes)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.stderr:[NO_PID]: ecpg_get_data on line 85: RESULT: {"@ 10 hours","@ 11 hours","@ 12 hours","@ 13 hours","@ 14 hours","@ 15 hours","@ 16 hours","@ 17 hours","@ 18 hours","@ 19 hours"} offset: -1; array: yes
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.stderr:[NO_PID]: ecpg_get_data on line 95: RESULT: {9,8,7,6,5,4,3,2,1,0} offset: -1; array: yes
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 1 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 10 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 12 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 13 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 19 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 20 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 21 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 22 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 23 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 24 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 25 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 26 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 27 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 28 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 29 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 53 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 53 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 55 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 55 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 57 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 57 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 59 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 59 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 61 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 61 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 63 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 63 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 65 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 65 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 67 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 67 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 75 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 75 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 80 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 80 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 88 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 88 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 98 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 98 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 102 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 102 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 104 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 104 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 106 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-array.c:#line 106 "array.pgc"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-strings.stderr:[NO_PID]: ecpg_get_data on line 15: RESULT: abcdef offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-strings.stderr:[NO_PID]: ecpg_get_data on line 15: RESULT: abcdef offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-strings.stderr:[NO_PID]: ecpg_get_data on line 15: RESULT: abcdef offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-strings.stderr:[NO_PID]: ecpg_get_data on line 15: RESULT: data offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-strings.stderr:[NO_PID]: ecpg_get_data on line 15: RESULT: data offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-strings.stderr:[NO_PID]: ecpg_get_data on line 15: RESULT: abc$def offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-define.c:/* exec sql type intarray is int [ 6 ] */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-define.c:typedef int intarray[ 6];
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-define.c: intarray amount ;
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-dt_test.stderr:[NO_PID]: ecpg_get_data on line 38: RESULT: 1966-01-17 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-dt_test.stderr:[NO_PID]: ecpg_get_data on line 38: RESULT: 2000-07-12 17:34:29 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-type.stderr:[NO_PID]: ecpg_get_data on line 65: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-type.stderr:[NO_PID]: ecpg_get_data on line 65: RESULT: user name            offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-type.stderr:[NO_PID]: ecpg_get_data on line 65: RESULT: 320 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-type.stderr:[NO_PID]: ecpg_get_data on line 65: RESULT: first str  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-type.stderr:[NO_PID]: ecpg_get_data on line 65: RESULT: second str offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/preproc-type.stderr:[NO_PID]: ecpg_get_data on line 65: RESULT: third str  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/pgtypeslib-num_test.stderr:[NO_PID]: ecpg_get_data on line 66: RESULT: 2369.7000000 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-indicators.stderr:[NO_PID]: ecpg_get_data on line 33: RESULT: 0 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-indicators.stderr:[NO_PID]: ecpg_get_data on line 34: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-indicators.stderr:[NO_PID]: ecpg_get_data on line 36: RESULT: 5 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-indicators.stderr:[NO_PID]: ecpg_get_data on line 42: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-quote.stderr:[NO_PID]: ecpg_get_data on line 24: RESULT: off offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-quote.stderr:[NO_PID]: ecpg_get_data on line 34: RESULT: on offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-quote.stderr:[NO_PID]: ecpg_get_data on line 51: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-quote.stderr:[NO_PID]: ecpg_get_data on line 51: RESULT: a\\b offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-quote.stderr:[NO_PID]: ecpg_get_data on line 51: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-quote.stderr:[NO_PID]: ecpg_get_data on line 51: RESULT: a\\b offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-quote.stderr:[NO_PID]: ecpg_get_data on line 51: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-quote.stderr:[NO_PID]: ecpg_get_data on line 51: RESULT: a\\\\b offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-quote.stderr:[NO_PID]: ecpg_get_data on line 51: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-quote.stderr:[NO_PID]: ecpg_get_data on line 51: RESULT: a\\b offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 54: RESULT: db: 'r1' offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 54: RESULT: db: 'r1' offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 54: RESULT: db: 'r1' offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 54: RESULT: db: 'r1' offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 54: RESULT: db: 'r1' offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 54: RESULT: db: 'r1' offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 54: RESULT: db: 'r1' offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 54: RESULT: db: 'r1' offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 54: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 54: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 54: RESULT: 11 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 54: RESULT: 12 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 54: RESULT: 101 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 54: RESULT: 102 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 54: RESULT: 111 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 54: RESULT: 112 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 54: RESULT: f offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 54: RESULT: t offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 54: RESULT: f offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 54: RESULT: t offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 54: RESULT: f offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 54: RESULT: t offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 54: RESULT: f offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 54: RESULT: t offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 73: RESULT: db: 'r1' offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 73: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-oldexec.stderr:[NO_PID]: ecpg_get_data on line 73: RESULT: f offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-insupd.stderr:[NO_PID]: ecpg_get_data on line 22: RESULT: 3 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-insupd.stderr:[NO_PID]: ecpg_get_data on line 24: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-insupd.stderr:[NO_PID]: ecpg_get_data on line 24: RESULT: 3 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-insupd.stderr:[NO_PID]: ecpg_get_data on line 24: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-insupd.stderr:[NO_PID]: ecpg_get_data on line 28: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-insupd.stderr:[NO_PID]: ecpg_get_data on line 28: RESULT: 4 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-insupd.stderr:[NO_PID]: ecpg_get_data on line 28: RESULT: 5 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-insupd.stderr:[NO_PID]: ecpg_get_data on line 28: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-insupd.stderr:[NO_PID]: ecpg_get_data on line 28: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-insupd.stderr:[NO_PID]: ecpg_get_data on line 28: RESULT: 5 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc.stderr:[NO_PID]: ecpg_get_data on line 43: RESULT: 1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc.stderr:[NO_PID]: ecpg_get_data on line 43: RESULT: 2 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc.stderr:[NO_PID]: ecpg_get_data on line 44: RESULT: 23.456 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc.stderr:[NO_PID]: ecpg_get_data on line 44: RESULT: 2.446 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc.stderr:[NO_PID]: ecpg_get_data on line 45: RESULT: varchar offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc.stderr:[NO_PID]: ecpg_get_data on line 45: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc.stderr:[NO_PID]: ecpg_get_data on line 46: RESULT: v offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc.stderr:[NO_PID]: ecpg_get_data on line 46: RESULT: v offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc.stderr:[NO_PID]: ecpg_get_data on line 47: RESULT: c    offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc.stderr:[NO_PID]: ecpg_get_data on line 47: RESULT: c    offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc.stderr:[NO_PID]: ecpg_get_data on line 48: RESULT: Mon Mar 03 11:33:07 2003 PST offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc.stderr:[NO_PID]: ecpg_get_data on line 48: RESULT: Mon Mar 03 11:33:07 2003 PST offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc.stderr:[NO_PID]: ecpg_get_data on line 49: RESULT: t offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc.stderr:[NO_PID]: ecpg_get_data on line 49: RESULT: f offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc.stderr:[NO_PID]: ecpg_get_data on line 52: RESULT: 2001:4f8:3:ba:2e0:81ff:fe22:d1f1 offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-dynalloc.stderr:[NO_PID]: ecpg_get_data on line 52: RESULT:  offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-show.stderr:[NO_PID]: ecpg_get_data on line 19: RESULT: public offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-show.stderr:[NO_PID]: ecpg_get_data on line 23: RESULT: public offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-show.stderr:[NO_PID]: ecpg_get_data on line 27: RESULT: off offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-show.stderr:[NO_PID]: ecpg_get_data on line 31: RESULT: PST8PDT offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/test/expected/sql-show.stderr:[NO_PID]: ecpg_get_data on line 35: RESULT: read committed offset: -1; array: no
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/pgtypeslib/datetime.c:				 * the value is the index of the month in the array of months
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/pgtypeslib/dt_common.c: * The field[] and ftype[] arrays must have at least MAXDATEFIELDS entries.
Binary file /srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/error.o matches
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:ecpg_type_infocache_push(struct ECPGtype_information_cache **cache, int oid, enum ARRAY_TYPE isarray, int lineno)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:	new_entry->isarray = isarray;
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:ecpg_is_type_an_array(int type, const struct statement *stmt, const struct variable *var)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:	char	   *array_query;
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:	enum ARRAY_TYPE isarray = ECPG_ARRAY_NOT_SET;
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:		 * Text like types are not an array for ecpg, but postgres counts them
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:		 * as an array. This define reminds you to not 'correct' these values.
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:#define not_an_array_in_ecpg ECPG_ARRAY_NONE
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:		if (!ecpg_type_infocache_push(&(stmt->connection->cache_head), NAMEOID, not_an_array_in_ecpg, stmt->lineno))
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:			return cache_entry->isarray;
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:	array_query = (char *) ecpg_alloc(strlen("select typlen from pg_type where oid= and typelem<>0") + 11, stmt->lineno);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:	if (array_query == NULL)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:	sprintf(array_query, "select typlen from pg_type where oid=%d and typelem<>0", type);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:	query = PQexec(stmt->connection->connection, array_query);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:	ecpg_free(array_query);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:			isarray = ECPG_ARRAY_NONE;
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:			isarray = (atol((char *) PQgetvalue(query, 0, 0)) == -1) ? ECPG_ARRAY_ARRAY : ECPG_ARRAY_VECTOR;
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:				 * arrays of character strings are not yet implemented
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:				isarray = ECPG_ARRAY_NONE;
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:	ecpg_type_infocache_push(&(stmt->connection->cache_head), type, isarray, stmt->lineno);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:	ecpg_log("ecpg_is_type_an_array on line %d: type (%d); C (%d); array (%s)\n", stmt->lineno, type, var->type, ECPG_IS_ARRAY(isarray) ? "yes" : "no");
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:	return isarray;
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:	enum ARRAY_TYPE isarray;
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:	if ((isarray = ecpg_is_type_an_array(PQftype(results, act_field), stmt, var)) == ECPG_ARRAY_ERROR)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:	if (isarray == ECPG_ARRAY_NONE)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:			ecpg_log("ecpg_store_result on line %d: incorrect number of matches; %d don't fit into array of %ld\n",
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:		 * since we read an array, the variable has to be an array too
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:		/* filling the array of (char*)s */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:		/* storing the data (after the last array element) */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:							   var->ind_value, len, 0, var->ind_offset, isarray, stmt->compat, stmt->force_indicator))
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:							   var->ind_value, var->varcharsize, var->offset, var->ind_offset, isarray, stmt->compat, stmt->force_indicator))
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:	 * arrays are not possible unless the column is an array, too FIXME: we do
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:	 * not know if the column is an array here array input to singleton column
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c: * in arrays which can be used by PQexecParams().
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:	 * enter it to our parameter array at the first position. Then if there
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:	 * arraysize - 0 for pointer (we don't know the size of the array), 1 for
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:	 * simple variable, size for arrays
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:	 * offset - offset between ith and (i+1)th entry in an array, normally
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:	 * ind_arraysize - arraysize of indicator array
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:			 * Unknown array size means pointer to an array. Unknown
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:			 * character and the array size is known, it is an array of
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:			 * negative values are used to indicate an array without given
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.c:			 * negative values are used to indicate an array without given
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/descriptor.c:					ecpg_log("ECPGget_desc on line %d: incorrect number of matches; %d don't fit into array of %ld\n",
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/descriptor.c:			ecpg_log("ECPGget_desc on line %d: incorrect number of matches (indicator); %d don't fit into array of %ld\n",
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/descriptor.c:		 * negative values are used to indicate an array without given bounds
Binary file /srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/libecpg.so.6.10 matches
Binary file /srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/execute.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.o matches
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/extern.h:	enum ARRAY_TYPE isarray;
Binary file /srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/descriptor.o matches
Binary file /srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/libecpg.a matches
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:/* returns true if character c is a delimiter for the given array type */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:array_delimiter(enum ARRAY_TYPE isarray, char c)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:	if (isarray == ECPG_ARRAY_ARRAY && c == ',')
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:	if (isarray == ECPG_ARRAY_VECTOR && c == ' ')
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:/* returns true if character c marks the boundary for the given array type */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:array_boundary(enum ARRAY_TYPE isarray, char c)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:	if (isarray == ECPG_ARRAY_ARRAY && c == '}')
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:	if (isarray == ECPG_ARRAY_VECTOR && c == '\0')
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:garbage_left(enum ARRAY_TYPE isarray, char **scan_length, enum COMPAT_MODE compat)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:	if (isarray == ECPG_ARRAY_NONE)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:	else if (ECPG_IS_ARRAY(isarray) && !array_delimiter(isarray, **scan_length) && !array_boundary(isarray, **scan_length))
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:			  long ind_offset, enum ARRAY_TYPE isarray, enum COMPAT_MODE compat, bool force_indicator)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:	ecpg_log("ecpg_get_data on line %d: RESULT: %s offset: %ld; array: %s\n", lineno, pval ? (binary ? "BINARY" : pval) : "EMPTY", log_offset, ECPG_IS_ARRAY(isarray) ? "yes" : "no");
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:	/* let's check if it really is an array if it should be one */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:	if (isarray == ECPG_ARRAY_ARRAY)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:					if (garbage_left(isarray, &scan_length, compat))
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:					if (garbage_left(isarray, &scan_length, compat))
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:					if (garbage_left(isarray, &scan_length, compat))
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:					if (garbage_left(isarray, &scan_length, compat))
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:					if (isarray && *pval == '"')
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:					if (isarray && *scan_length == '"')
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:					if (garbage_left(isarray, &scan_length, ECPG_COMPAT_PGSQL))
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:						 * char *, then this variable represents the array of
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:						if (!isarray && garbage_left(isarray, &scan_length, compat))
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:						if (!isarray && garbage_left(isarray, &scan_length, compat))
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:						if (!isarray && garbage_left(isarray, &scan_length, compat))
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:						if (!isarray && garbage_left(isarray, &scan_length, compat))
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:			if (ECPG_IS_ARRAY(isarray))
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:				/* set array to next entry */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:				for (; *pval != '\0' && (string || (!array_delimiter(isarray, *pval) && !array_boundary(isarray, *pval))); ++pval)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:				if (array_delimiter(isarray, *pval))
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/data.c:	} while (*pval != '\0' && !array_boundary(isarray, *pval));
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/sqlda.c:				 * Let's align both the numeric struct and the digits array to
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/error.c:					 ecpg_gettext("variable does not have an array type on line %d"), line);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/error.c:					 ecpg_gettext("data read from server is not an array on line %d"), line);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/error.c:					 ecpg_gettext("inserting an array of variables is not supported on line %d"), line);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/it.po:msgid "variable does not have an array type on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/it.po:msgstr "la variabile non  di tipo array alla riga %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/it.po:msgid "data read from server is not an array on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/it.po:msgstr "i dati letti dal server non sono di tipo array alla riga %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/it.po:msgid "inserting an array of variables is not supported on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/it.po:msgstr "inserire un array di variabili non  supportato alla riga %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/ja.po:msgid "variable does not have an array type on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/ja.po:msgid "data read from server is not an array on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/ja.po:msgid "inserting an array of variables is not supported on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/tr.po:msgid "variable does not have an array type on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/tr.po:msgid "data read from server is not an array on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/tr.po:msgid "inserting an array of variables is not supported on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/ko.po:msgid "variable does not have an array type on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/ko.po:msgid "data read from server is not an array on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/ko.po:msgid "inserting an array of variables is not supported on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/cs.po:msgid "variable does not have an array type on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/cs.po:msgid "data read from server is not an array on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/cs.po:msgid "inserting an array of variables is not supported on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/ru.po:msgid "variable does not have an array type on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/ru.po:msgid "data read from server is not an array on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/ru.po:msgid "inserting an array of variables is not supported on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/pt_BR.po:msgid "variable does not have an array type on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/pt_BR.po:msgid "data read from server is not an array on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/pt_BR.po:msgid "inserting an array of variables is not supported on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/es.po:msgid "variable does not have an array type on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/es.po:msgstr "la variable no tiene tipo array en lnea %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/es.po:msgid "data read from server is not an array on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/es.po:msgstr "el dato ledo del servidor no es un array en lnea %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/es.po:msgid "inserting an array of variables is not supported on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/es.po:msgstr "la insercin de un array de variables no est soportado en lnea %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/sv.po:msgid "variable does not have an array type on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/sv.po:msgstr "variabel har inte array-typ p rad %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/sv.po:msgid "data read from server is not an array on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/sv.po:msgstr "data inlst frn servern r inte en array p rad %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/sv.po:msgid "inserting an array of variables is not supported on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/sv.po:msgstr "stta in en array med variabler stds inte p rad %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/pl.po:msgid "variable does not have an array type on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/pl.po:msgstr "zmienna nie ma typu array, linia %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/pl.po:msgid "data read from server is not an array on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/pl.po:msgid "inserting an array of variables is not supported on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/de.po:msgid "variable does not have an array type on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/de.po:msgid "data read from server is not an array on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/de.po:msgid "inserting an array of variables is not supported on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/zh_CN.po:msgid "variable does not have an array type on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/zh_CN.po:msgid "data read from server is not an array on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/zh_CN.po:msgid "inserting an array of variables is not supported on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/fr.po:msgid "variable does not have an array type on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/fr.po:msgid "data read from server is not an array on line %d"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/ecpglib/po/fr.po:msgid "inserting an array of variables is not supported on line %d"
Binary file /srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/keywords.o matches
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.c:			case ECPGt_array:
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.c:				 * if this array does contain a struct again, we have to
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.c:					type = ECPGmake_array_type(ECPGmake_simple_type(rm->type->u.element->type, rm->type->u.element->size, rm->type->u.element->counter), rm->type->size);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.c:ECPGmake_array_type(struct ECPGtype *type, char *size)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.c:	struct ECPGtype *ne = ECPGmake_simple_type(ECPGt_array, size, 0);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.c:   arrsize is the size of the array in case of array fetches. Otherwise 0.
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.c:   the variable (required to do array fetches of structs).
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.c:		case ECPGt_array:
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.c:			if (indicator_set && ind_type->type != ECPGt_array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.c:				mmfatal(INDICATOR_NOT_ARRAY, "indicator for array/pointer has to be array/pointer");
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.c:				case ECPGt_array:
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.c:					mmerror(PARSE_ERROR, ET_ERROR, "nested arrays are not supported (except strings)"); /* array of array */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.c:				if (indicator_set && (ind_type->type == ECPGt_struct || ind_type->type == ECPGt_array))
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.c:				if (indicator_set && (ind_type->type == ECPGt_struct || ind_type->type == ECPGt_array))
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.c:				if (indicator_set && (ind_type->type == ECPGt_struct || ind_type->type == ECPGt_array))
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.c:   string, it represents the offset needed if we are in an array of structs. */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.c:				 * we have to use the & operator except for arrays and
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.c:				 * we have to use the pointer except for arrays with given
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.c:					 * we have to use the pointer except for arrays with given
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.c:							 * If this is an array of char *, the offset would
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.c:				 * we have to use the pointer except for arrays with given
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.c:			case ECPGt_array:
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.c:					case ECPGt_array:
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.c:						base_yyerror("internal error: found multidimensional array\n");
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/pgc.c: * integer for use as an array index.  If the signed char is negative,
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/pgc.c:static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/pgc.c:		/* Extend the array by 50%, plus the number we really need. */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.h:	char	   *size;			/* For array it is the number of elements. For
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.h:		struct ECPGtype *element;	/* For an array this is the type of the
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.h:struct ECPGtype *ECPGmake_array_type(struct ECPGtype *, char *);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.h:   arrsize is the size of the array in case of array fetches. Otherwise 0.
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.h:	   the variable (required to do array fetches of structs).
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:create_questionmarks(char *name, bool array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:	 * An array is only allowed together with an element argument
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:	if (p->type->type == ECPGt_struct || (array && p->type->type == ECPGt_array && p->type->u.element->type == ECPGt_struct))
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:									  ECPGmake_array_type(ECPGmake_simple_type(ptr->variable->type->u.element->type,
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:			else if (ptr->variable->type->type == ECPGt_array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:										  ECPGmake_array_type(ECPGmake_simple_type(ptr->variable->type->u.element->type,
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:				else if (ptr->indicator->type->type == ECPGt_array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:											  ECPGmake_array_type(ECPGmake_simple_type(ptr->indicator->type->u.element->type,
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:			char *type_dimension, char *type_index, int initializer, int array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:		adjust_array(type_enum, &dimension, &length, type_dimension, type_index, array, true);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:		this->type->type_dimension = dimension; /* dimension of array */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:			mmerror(PARSE_ERROR, ET_ERROR, "multidimensional arrays for simple data types are not supported");
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:/* The size of an array large to enough to hold all stacks, each with
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:  "xml_namespace_list", "xml_namespace_el", "Typename", "opt_array_bounds",
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:  "func_arg_list", "func_arg_expr", "type_list", "array_expr",
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:  "array_expr_list", "extract_list", "extract_arg", "overlay_list",
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c: (yyval.str) = cat_str(4,(yyvsp[-4].str),mm_strdup("array ["),(yyvsp[-1].str),mm_strdup("]"));
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c: (yyval.str) = cat_str(5,mm_strdup("setof"),(yyvsp[-4].str),mm_strdup("array ["),(yyvsp[-1].str),mm_strdup("]"));
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c: (yyval.str) = cat_str(2,(yyvsp[-1].str),mm_strdup("array"));
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c: (yyval.str) = cat_str(3,mm_strdup("setof"),(yyvsp[-1].str),mm_strdup("array"));
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c: (yyval.str) = cat_str(2,mm_strdup("array"),(yyvsp[0].str));
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c: (yyval.str) = cat_str(2,mm_strdup("array"),(yyvsp[0].str));
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c: (yyval.str) = mm_strdup("array");
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:			/* if array see what's inside */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:			if (type == ECPGt_array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:				/* if array see what's inside */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:				if (type == ECPGt_array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:			this->type->type_dimension = mm_strdup("-1"); /* dimension of array */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:			char *dimension = (yyvsp[-2].index).index1;	/* dimension of array */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:			adjust_array(actual_type[struct_level].type_enum, &dimension, &length, actual_type[struct_level].type_dimension, actual_type[struct_level].type_index, strlen((yyvsp[-4].str)), false);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:						type = ECPGmake_array_type(ECPGmake_struct_type(struct_member_list[struct_level], actual_type[struct_level].type_enum, actual_type[struct_level].type_str, actual_type[struct_level].type_sizeof), dimension);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:						type = ECPGmake_array_type(ECPGmake_simple_type(actual_type[struct_level].type_enum, length, varchar_counter), dimension);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:						type = ECPGmake_array_type(ECPGmake_simple_type(actual_type[struct_level].type_enum, length, 0), dimension);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:						type = ECPGmake_array_type(ECPGmake_simple_type(actual_type[struct_level].type_enum, mm_strdup("1"), 0), dimension);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:				adjust_array((yyvsp[-2].type).type_enum, &dimension, &length, (yyvsp[-2].type).type_dimension, (yyvsp[-2].type).type_index, *(yyvsp[0].str)?1:0, false);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:							type = ECPGmake_array_type(ECPGmake_struct_type(struct_member_list[struct_level], (yyvsp[-2].type).type_enum, (yyvsp[-2].type).type_str, (yyvsp[-2].type).type_sizeof), dimension);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:							type = ECPGmake_array_type(ECPGmake_simple_type((yyvsp[-2].type).type_enum, length, 0), dimension);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:							type = ECPGmake_array_type(ECPGmake_simple_type((yyvsp[-2].type).type_enum, length, 0), dimension);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:							mmerror(PARSE_ERROR, ET_ERROR, "multidimensional arrays for simple data types are not supported");
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:							type = ECPGmake_array_type(ECPGmake_simple_type((yyvsp[-2].type).type_enum, mm_strdup("1"), 0), dimension);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:			if (find_variable((yyvsp[0].str))->type->type == ECPGt_array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:				mmerror(PARSE_ERROR, ET_ERROR, "arrays of indicators are not allowed on input");
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:			/* As long as multidimensional arrays are not implemented we have to check for those here */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.c:								mmfatal(PARSE_ERROR, "multidimensional arrays for simple data types are not supported");
Binary file /srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/type.o matches
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/extern.h:extern void adjust_array(enum ECPGttype, char **, char **, char *, char *, int, bool);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.addons:ECPG: TypenameSimpleTypenameopt_array_bounds block
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.addons:ECPG: TypenameSETOFSimpleTypenameopt_array_bounds block
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.addons:ECPG: opt_array_boundsopt_array_bounds'['']' block
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.addons:	| opt_array_bounds '[' Iresult ']'
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.addons:ECPG: opt_array_bounds
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/variable.c:					case ECPGt_array:
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/variable.c:						return (new_variable(name, ECPGmake_array_type(ECPGmake_simple_type(members->type->u.element->type, members->type->u.element->size, members->type->u.element->counter), members->type->size), brace_level));
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/variable.c:					 * We don't care about what's inside the array braces so
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/variable.c:								 * an array element */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/variable.c:						if (members->type->type != ECPGt_array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/variable.c:							case ECPGt_array:
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/variable.c:								return (new_variable(name, ECPGmake_array_type(ECPGmake_simple_type(members->type->u.element->u.element->type, members->type->u.element->u.element->size, members->type->u.element->u.element->counter), members->type->u.element->size), brace_level));
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/variable.c:						if (members->type->type == ECPGt_array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/variable.c:						if (members->type->type == ECPGt_array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/variable.c:		if (p->type->type != ECPGt_array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/variable.c:			if (p->type->type != ECPGt_array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/variable.c:				mmfatal(PARSE_ERROR, "variable \"%s\" is not an array", name);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/variable.c:			 * We don't care about what's inside the array braces so just eat
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/variable.c:					case ECPGt_array:
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/variable.c:						return (new_variable(name, ECPGmake_array_type(ECPGmake_simple_type(p->type->u.element->u.element->type, p->type->u.element->u.element->size, p->type->u.element->u.element->counter), p->type->u.element->size), p->brace_level));
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/variable.c:		case ECPGt_array:
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/variable.c:adjust_array(enum ECPGttype type_enum, char **dimension, char **length, char *type_dimension, char *type_index, int pointer_len, bool type_definition)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/variable.c:			mmfatal(PARSE_ERROR, "multidimensional arrays are not supported");
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/variable.c:			mmfatal(PARSE_ERROR, "multidimensional arrays are not supported");
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/variable.c:		mmfatal(PARSE_ERROR, "multidimensional arrays are not supported");
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/variable.c:		mmfatal(PARSE_ERROR, "multidimensional arrays are not supported");
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/variable.c:				mmfatal(PARSE_ERROR, "multidimensional arrays for structures are not supported");
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/variable.c:				 * make sure we return length = -1 for arrays without given
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/variable.c:				mmfatal(PARSE_ERROR, "multidimensional arrays for simple data types are not supported");
Binary file /srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/variable.o matches
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/pgc.l:array			({ident_cont}|{whitespace}|[\[\]\+\-\*\%\/\(\)\>\.])*
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/pgc.l:<SQL>:{identifier}((("->"|\.){identifier})|(\[{array}\]))*	{
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.trailer:			/* if array see what's inside */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.trailer:			if (type == ECPGt_array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.trailer:				/* if array see what's inside */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.trailer:				if (type == ECPGt_array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.trailer:	var_type opt_pointer ECPGColLabelCommon opt_array_bounds ';'
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.trailer:			this->type->type_dimension = mm_strdup("-1"); /* dimension of array */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.trailer:variable: opt_pointer ECPGColLabel opt_array_bounds opt_bit_field opt_initializer
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.trailer:			char *dimension = $3.index1;	/* dimension of array */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.trailer:			adjust_array(actual_type[struct_level].type_enum, &dimension, &length, actual_type[struct_level].type_dimension, actual_type[struct_level].type_index, strlen($1), false);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.trailer:						type = ECPGmake_array_type(ECPGmake_struct_type(struct_member_list[struct_level], actual_type[struct_level].type_enum, actual_type[struct_level].type_str, actual_type[struct_level].type_sizeof), dimension);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.trailer:						type = ECPGmake_array_type(ECPGmake_simple_type(actual_type[struct_level].type_enum, length, varchar_counter), dimension);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.trailer:						type = ECPGmake_array_type(ECPGmake_simple_type(actual_type[struct_level].type_enum, length, 0), dimension);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.trailer:						type = ECPGmake_array_type(ECPGmake_simple_type(actual_type[struct_level].type_enum, mm_strdup("1"), 0), dimension);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.trailer:		ECPGColLabelCommon IS var_type opt_array_bounds opt_reference
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.trailer:		ColLabel IS var_type opt_array_bounds opt_reference
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.trailer:				adjust_array($5.type_enum, &dimension, &length, $5.type_dimension, $5.type_index, *$7?1:0, false);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.trailer:							type = ECPGmake_array_type(ECPGmake_struct_type(struct_member_list[struct_level], $5.type_enum, $5.type_str, $5.type_sizeof), dimension);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.trailer:							type = ECPGmake_array_type(ECPGmake_simple_type($5.type_enum, length, 0), dimension);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.trailer:							type = ECPGmake_array_type(ECPGmake_simple_type($5.type_enum, length, 0), dimension);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.trailer:							mmerror(PARSE_ERROR, ET_ERROR, "multidimensional arrays for simple data types are not supported");
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.trailer:							type = ECPGmake_array_type(ECPGmake_simple_type($5.type_enum, mm_strdup("1"), 0), dimension);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.trailer:			if (find_variable($2)->type->type == ECPGt_array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.trailer:				mmerror(PARSE_ERROR, ET_ERROR, "arrays of indicators are not allowed on input");
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.trailer:			/* As long as multidimensional arrays are not implemented we have to check for those here */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.trailer:								mmfatal(PARSE_ERROR, "multidimensional arrays for simple data types are not supported");
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.header:create_questionmarks(char *name, bool array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.header:	 * An array is only allowed together with an element argument
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.header:	if (p->type->type == ECPGt_struct || (array && p->type->type == ECPGt_array && p->type->u.element->type == ECPGt_struct))
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.header:									  ECPGmake_array_type(ECPGmake_simple_type(ptr->variable->type->u.element->type,
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.header:			else if (ptr->variable->type->type == ECPGt_array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.header:										  ECPGmake_array_type(ECPGmake_simple_type(ptr->variable->type->u.element->type,
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.header:				else if (ptr->indicator->type->type == ECPGt_array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.header:											  ECPGmake_array_type(ECPGmake_simple_type(ptr->indicator->type->u.element->type,
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.header:			char *type_dimension, char *type_index, int initializer, int array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.header:		adjust_array(type_enum, &dimension, &length, type_dimension, type_index, array, true);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.header:		this->type->type_dimension = dimension; /* dimension of array */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg.header:			mmerror(PARSE_ERROR, ET_ERROR, "multidimensional arrays for simple data types are not supported");
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/parse.pl:	'opt_array_bounds' => '<index>',
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/parse.pl:	"opt_array_boundsopt_array_bounds'['Iconst']'" => 'ignore',
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/parse.pl:	#We have an array to add to the buffer, we'll add it ourself instead of
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/parse.pl:	#calling add_to_buffer, which does not know about arrays
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/parse.pl:	# if we added something (ie there are lines in our array), return 1
Binary file /srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.o matches
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:create_questionmarks(char *name, bool array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:	 * An array is only allowed together with an element argument
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:	if (p->type->type == ECPGt_struct || (array && p->type->type == ECPGt_array && p->type->u.element->type == ECPGt_struct))
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:									  ECPGmake_array_type(ECPGmake_simple_type(ptr->variable->type->u.element->type,
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:			else if (ptr->variable->type->type == ECPGt_array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:										  ECPGmake_array_type(ECPGmake_simple_type(ptr->variable->type->u.element->type,
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:				else if (ptr->indicator->type->type == ECPGt_array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:											  ECPGmake_array_type(ECPGmake_simple_type(ptr->indicator->type->u.element->type,
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:			char *type_dimension, char *type_index, int initializer, int array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:		adjust_array(type_enum, &dimension, &length, type_dimension, type_index, array, true);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:		this->type->type_dimension = dimension; /* dimension of array */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:			mmerror(PARSE_ERROR, ET_ERROR, "multidimensional arrays for simple data types are not supported");
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:%type <index> opt_array_bounds
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:%type <str> array_expr
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:%type <str> array_expr_list
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y: SimpleTypename opt_array_bounds
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:|  SETOF SimpleTypename opt_array_bounds
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y: $$ = cat_str(4,$1,mm_strdup("array ["),$4,mm_strdup("]"));
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y: $$ = cat_str(5,mm_strdup("setof"),$2,mm_strdup("array ["),$5,mm_strdup("]"));
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y: $$ = cat_str(2,$1,mm_strdup("array"));
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y: $$ = cat_str(3,mm_strdup("setof"),$2,mm_strdup("array"));
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y: opt_array_bounds:
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y: opt_array_bounds '[' ']'
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:	| opt_array_bounds '[' Iresult ']'
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y: $$ = cat_str(2,mm_strdup("array"),$2);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:|  ARRAY array_expr
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y: $$ = cat_str(2,mm_strdup("array"),$2);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y: array_expr:
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:|  '[' array_expr_list ']'
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y: array_expr_list:
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y: array_expr
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:|  array_expr_list ',' array_expr
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y: $$ = mm_strdup("array");
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:			/* if array see what's inside */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:			if (type == ECPGt_array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:				/* if array see what's inside */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:				if (type == ECPGt_array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:	var_type opt_pointer ECPGColLabelCommon opt_array_bounds ';'
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:			this->type->type_dimension = mm_strdup("-1"); /* dimension of array */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:variable: opt_pointer ECPGColLabel opt_array_bounds opt_bit_field opt_initializer
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:			char *dimension = $3.index1;	/* dimension of array */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:			adjust_array(actual_type[struct_level].type_enum, &dimension, &length, actual_type[struct_level].type_dimension, actual_type[struct_level].type_index, strlen($1), false);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:						type = ECPGmake_array_type(ECPGmake_struct_type(struct_member_list[struct_level], actual_type[struct_level].type_enum, actual_type[struct_level].type_str, actual_type[struct_level].type_sizeof), dimension);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:						type = ECPGmake_array_type(ECPGmake_simple_type(actual_type[struct_level].type_enum, length, varchar_counter), dimension);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:						type = ECPGmake_array_type(ECPGmake_simple_type(actual_type[struct_level].type_enum, length, 0), dimension);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:						type = ECPGmake_array_type(ECPGmake_simple_type(actual_type[struct_level].type_enum, mm_strdup("1"), 0), dimension);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:		ECPGColLabelCommon IS var_type opt_array_bounds opt_reference
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:		ColLabel IS var_type opt_array_bounds opt_reference
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:				adjust_array($5.type_enum, &dimension, &length, $5.type_dimension, $5.type_index, *$7?1:0, false);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:							type = ECPGmake_array_type(ECPGmake_struct_type(struct_member_list[struct_level], $5.type_enum, $5.type_str, $5.type_sizeof), dimension);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:							type = ECPGmake_array_type(ECPGmake_simple_type($5.type_enum, length, 0), dimension);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:							type = ECPGmake_array_type(ECPGmake_simple_type($5.type_enum, length, 0), dimension);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:							mmerror(PARSE_ERROR, ET_ERROR, "multidimensional arrays for simple data types are not supported");
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:							type = ECPGmake_array_type(ECPGmake_simple_type($5.type_enum, mm_strdup("1"), 0), dimension);
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:			if (find_variable($2)->type->type == ECPGt_array)
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:				mmerror(PARSE_ERROR, ET_ERROR, "arrays of indicators are not allowed on input");
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:			/* As long as multidimensional arrays are not implemented we have to check for those here */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/preproc.y:								mmfatal(PARSE_ERROR, "multidimensional arrays for simple data types are not supported");
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/zh_TW.po:msgid "multidimensional arrays for simple data types are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/zh_TW.po:msgid "arrays of indicators are not allowed on input"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/zh_TW.po:msgid "indicator for array/pointer has to be array/pointer"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/zh_TW.po:msgid "nested arrays are not supported (except strings)"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/zh_TW.po:msgid "variable \"%s\" is not an array"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/zh_TW.po:msgid "multidimensional arrays are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/zh_TW.po:msgid "multidimensional arrays for structures are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/it.po:msgid "multidimensional arrays for simple data types are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/it.po:msgstr "gli array multidimensionali per tipi dato semplici non sono supportati"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/it.po:msgid "arrays of indicators are not allowed on input"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/it.po:msgstr "array di indicatori non sono permessi"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/it.po:msgid "indicator for array/pointer has to be array/pointer"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/it.po:msgstr "un indicatore per un array/puntatore deve essere un array/puntatore"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/it.po:msgid "nested arrays are not supported (except strings)"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/it.po:msgstr "array annidati non sono supportati (tranne che per le stringhe)"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/it.po:msgid "variable \"%s\" is not an array"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/it.po:msgstr "la variabile \"%s\" non  un array"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/it.po:msgid "multidimensional arrays are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/it.po:msgstr "gli array multidimensionali non sono supportati"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/it.po:msgid "multidimensional arrays for structures are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/it.po:msgstr "gli array multidimensionali per strutture non sono supportati"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/ja.po:msgid "multidimensional arrays for simple data types are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/ja.po:msgid "arrays of indicators are not allowed on input"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/ja.po:msgid "indicator for array/pointer has to be array/pointer"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/ja.po:msgid "nested arrays are not supported (except strings)"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/ja.po:msgid "variable \"%s\" is not an array"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/ja.po:msgid "multidimensional arrays are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/ja.po:msgid "multidimensional arrays for structures are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/tr.po:msgid "multidimensional arrays for simple data types are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/tr.po:msgid "arrays of indicators are not allowed on input"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/tr.po:msgid "indicator for array/pointer has to be array/pointer"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/tr.po:msgstr "array/pointer iin gsterici array/pointer olmaldr"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/tr.po:msgid "nested arrays are not supported (except strings)"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/tr.po:msgid "variable \"%s\" is not an array"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/tr.po:msgid "multidimensional arrays are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/tr.po:msgid "multidimensional arrays for structures are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/ko.po:msgid "multidimensional arrays for simple data types are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/ko.po:msgid "arrays of indicators are not allowed on input"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/ko.po:msgid "indicator for array/pointer has to be array/pointer"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/ko.po:msgid "nested arrays are not supported (except strings)"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/ko.po:msgid "variable \"%s\" is not an array"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/ko.po:msgid "multidimensional arrays are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/ko.po:msgid "multidimensional arrays for structures are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/cs.po:msgid "multidimensional arrays for simple data types are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/cs.po:msgid "arrays of indicators are not allowed on input"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/cs.po:msgid "indicator for array/pointer has to be array/pointer"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/cs.po:msgid "nested arrays are not supported (except strings)"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/cs.po:msgid "variable \"%s\" is not an array"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/cs.po:msgid "multidimensional arrays are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/cs.po:msgid "multidimensional arrays for structures are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/ru.po:msgid "multidimensional arrays for simple data types are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/ru.po:msgid "arrays of indicators are not allowed on input"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/ru.po:msgid "indicator for array/pointer has to be array/pointer"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/ru.po:msgid "nested arrays are not supported (except strings)"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/ru.po:msgid "variable \"%s\" is not an array"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/ru.po:msgid "multidimensional arrays are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/ru.po:msgid "multidimensional arrays for structures are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/pt_BR.po:msgid "multidimensional arrays for simple data types are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/pt_BR.po:msgid "arrays of indicators are not allowed on input"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/pt_BR.po:msgid "indicator for array/pointer has to be array/pointer"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/pt_BR.po:msgid "nested arrays are not supported (except strings)"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/pt_BR.po:msgid "variable \"%s\" is not an array"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/pt_BR.po:msgid "multidimensional arrays are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/pt_BR.po:msgid "multidimensional arrays for structures are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/es.po:msgid "multidimensional arrays for simple data types are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/es.po:msgstr "los arrays multidimensionales para tipos de datos simples no estn soportados"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/es.po:msgid "arrays of indicators are not allowed on input"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/es.po:msgstr "no se permiten los arrays de indicadores en la entrada"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/es.po:msgid "indicator for array/pointer has to be array/pointer"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/es.po:msgstr "indicador para array/puntero debe ser array/puntero"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/es.po:msgid "nested arrays are not supported (except strings)"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/es.po:msgstr "no se permiten arrays anidados (excepto cadenas de caracteres)"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/es.po:msgid "variable \"%s\" is not an array"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/es.po:msgstr "la variable %s no es un array"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/es.po:msgid "multidimensional arrays are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/es.po:msgstr "los arrays multidimensionales no estn soportados"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/es.po:msgid "multidimensional arrays for structures are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/es.po:msgstr "los arrays multidimensionales para estructuras no estn soportados"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/sv.po:msgid "multidimensional arrays for simple data types are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/sv.po:msgstr "multidimensionella array:er fr enkla datatyper stds inte"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/sv.po:msgid "arrays of indicators are not allowed on input"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/sv.po:msgstr "array:er av indikatorer tillts inte vid indata"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/sv.po:msgid "indicator for array/pointer has to be array/pointer"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/sv.po:msgstr "indikator fr array/pekare mste vara en array/pekare"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/sv.po:msgid "nested arrays are not supported (except strings)"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/sv.po:msgstr "nstlade array:er stds inte (frutom strngar)"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/sv.po:msgid "variable \"%s\" is not an array"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/sv.po:msgstr "variabel \"%s\" r inte en array"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/sv.po:msgid "multidimensional arrays are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/sv.po:msgstr "multidimensionella array:er stds inte"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/sv.po:msgid "multidimensional arrays for structures are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/sv.po:msgstr "multidimensionella array:er av strukturer stds inte"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/pl.po:msgid "multidimensional arrays for simple data types are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/pl.po:msgid "arrays of indicators are not allowed on input"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/pl.po:msgid "indicator for array/pointer has to be array/pointer"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/pl.po:msgstr "wskanik do array/pointer musi by array/pointer"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/pl.po:msgid "nested arrays are not supported (except strings)"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/pl.po:msgid "variable \"%s\" is not an array"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/pl.po:msgid "multidimensional arrays are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/pl.po:msgid "multidimensional arrays for structures are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/de.po:msgid "multidimensional arrays for simple data types are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/de.po:msgid "arrays of indicators are not allowed on input"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/de.po:msgid "indicator for array/pointer has to be array/pointer"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/de.po:msgid "nested arrays are not supported (except strings)"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/de.po:msgid "variable \"%s\" is not an array"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/de.po:msgid "multidimensional arrays are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/de.po:msgid "multidimensional arrays for structures are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/zh_CN.po:msgid "multidimensional arrays for simple data types are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/zh_CN.po:msgid "arrays of indicators are not allowed on input"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/zh_CN.po:msgid "indicator for array/pointer has to be array/pointer"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/zh_CN.po:msgstr "/array/pointer"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/zh_CN.po:msgid "nested arrays are not supported (except strings)"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/zh_CN.po:msgid "variable \"%s\" is not an array"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/zh_CN.po:msgid "multidimensional arrays are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/zh_CN.po:msgid "multidimensional arrays for structures are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/fr.po:msgid "multidimensional arrays for simple data types are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/fr.po:msgid "arrays of indicators are not allowed on input"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/fr.po:msgid "indicator for array/pointer has to be array/pointer"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/fr.po:msgid "nested arrays are not supported (except strings)"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/fr.po:msgid "variable \"%s\" is not an array"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/fr.po:msgid "multidimensional arrays are not supported"
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/po/fr.po:msgid "multidimensional arrays for structures are not supported"
Binary file /srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/preproc/ecpg matches
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/include/ecpgtype.h: * Records build of simple types, arrays and other structs.
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/include/ecpgtype.h:								 * a malloced array */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/include/ecpgtype.h:								 * a fixed array */
/srvr/z5089358/postgresql-10.4/src/interfaces/ecpg/include/ecpgtype.h:	ECPGt_array,
Binary file /srvr/z5089358/postgresql-10.4/src/timezone/zic matches
/srvr/z5089358/postgresql-10.4/src/timezone/zic.c:	char	  **array;
/srvr/z5089358/postgresql-10.4/src/timezone/zic.c:	array = emalloc(size_product(strlen(cp) + 1, sizeof *array));
/srvr/z5089358/postgresql-10.4/src/timezone/zic.c:		array[nsubs++] = dp = cp;
/srvr/z5089358/postgresql-10.4/src/timezone/zic.c:	array[nsubs] = NULL;
/srvr/z5089358/postgresql-10.4/src/timezone/zic.c:	return array;
/srvr/z5089358/postgresql-10.4/src/timezone/localtime.c: *	objects: a broken-down time structure and an array of char.
